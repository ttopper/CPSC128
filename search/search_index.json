{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CPSC 128 - Object Oriented Programming 1 The course is divided into 12 content modules (01-12 below) bracketed up front by a module with information about the course, and one at the end about preparing for the exam. 00 Meta (Information about the course) 01 Introduction to Computers and Programming 02 SIPO (Sequential, Input, Processing, Output) Programming 03 Selection Control Structures 04 Repetition Control Structures 05 Aggregate data types 1: Lists and Strings 06 Functions and Modules 07 Aggregate data types 2: Dictionaries 08 Persistence: Processing text files 09 Object-Oriented Programming 1: Encapsulation 10 Object-Oriented Design (OOD) 11 Object-Oriented Programming 2: Polymorphism & Inheritance 12 Testing and Documentation 13 Exam Preparation","title":"Welcome to CPSC 128 - Object Oriented Programming 1"},{"location":"#welcome-to-cpsc-128-object-oriented-programming-1","text":"The course is divided into 12 content modules (01-12 below) bracketed up front by a module with information about the course, and one at the end about preparing for the exam. 00 Meta (Information about the course) 01 Introduction to Computers and Programming 02 SIPO (Sequential, Input, Processing, Output) Programming 03 Selection Control Structures 04 Repetition Control Structures 05 Aggregate data types 1: Lists and Strings 06 Functions and Modules 07 Aggregate data types 2: Dictionaries 08 Persistence: Processing text files 09 Object-Oriented Programming 1: Encapsulation 10 Object-Oriented Design (OOD) 11 Object-Oriented Programming 2: Polymorphism & Inheritance 12 Testing and Documentation 13 Exam Preparation","title":"Welcome to CPSC 128 - Object Oriented Programming 1"},{"location":"00_Preparing/","text":"Orientation and Preparation Before going on a hike you need to gather supplies, get to the trailhead, and have a map of where you're going. Beginning a course is similar: you should know what you are getting into, know what resources will be available to you, and gather the tools you will need. This means you need to: Know what you're getting into. Know where to find the course resources. Install the software the course will use on your personal computer. 1. Know what you are getting into The official course outline . Start here. It's not exciting reading, but it is important, and will give you a clear idea what you are getting yourself into. If anything is unclear, or if you would like further information, don't hesitate to ask in class, or post your question to the Moodle Discussion Forum. (Aside: The forum is preferred over email because the questions and answers accumulate. This way if another person has the same question the information is shared. Feel free to answer other people's questions too!) Then you can read about: The course philosophy What language we'll use (and why) How your assignments will be graded And even What will be on the final exam! 2. Know where to find the course resources Familiarize yourself with the two 1 (2!) course websites. The Moodle site will be used for the administrative side of the course. The Github site provides the learning resources. It is our online textbook. Github Site (Textbook) Moodle site (Administration) - Course Notes and Videos - Discussion forum - Assignment descriptions - Schedule and Calendar (so you can see when the next assignment is due!) - Your Grades (so you can see how you are doing) - Assignment submission If you like having options, there are several good free online Python textbooks available. 3. Install Python on your personal computer [Optional, but desirable] Python is free and available for Windows, MacOS, and Linux. The Installing Python page will get you started installing it on your system. Be sure to test your installation as described on the page! Why two? The software behind Moodle makes it awkward to post and edit computer code (and this course has a lot of that), and difficult to produce visually clean web pages. \u21a9","title":"Orientation and Preparation"},{"location":"00_Preparing/#orientation-and-preparation","text":"Before going on a hike you need to gather supplies, get to the trailhead, and have a map of where you're going. Beginning a course is similar: you should know what you are getting into, know what resources will be available to you, and gather the tools you will need. This means you need to: Know what you're getting into. Know where to find the course resources. Install the software the course will use on your personal computer.","title":"Orientation and Preparation"},{"location":"00_Preparing/#1-know-what-you-are-getting-into","text":"The official course outline . Start here. It's not exciting reading, but it is important, and will give you a clear idea what you are getting yourself into. If anything is unclear, or if you would like further information, don't hesitate to ask in class, or post your question to the Moodle Discussion Forum. (Aside: The forum is preferred over email because the questions and answers accumulate. This way if another person has the same question the information is shared. Feel free to answer other people's questions too!) Then you can read about: The course philosophy What language we'll use (and why) How your assignments will be graded And even What will be on the final exam!","title":"1. Know what you are getting into"},{"location":"00_Preparing/#2-know-where-to-find-the-course-resources","text":"Familiarize yourself with the two 1 (2!) course websites. The Moodle site will be used for the administrative side of the course. The Github site provides the learning resources. It is our online textbook. Github Site (Textbook) Moodle site (Administration) - Course Notes and Videos - Discussion forum - Assignment descriptions - Schedule and Calendar (so you can see when the next assignment is due!) - Your Grades (so you can see how you are doing) - Assignment submission If you like having options, there are several good free online Python textbooks available.","title":"2. Know where to find the course resources"},{"location":"00_Preparing/#3-install-python-on-your-personal-computer-optional-but-desirable","text":"Python is free and available for Windows, MacOS, and Linux. The Installing Python page will get you started installing it on your system. Be sure to test your installation as described on the page! Why two? The software behind Moodle makes it awkward to post and edit computer code (and this course has a lot of that), and difficult to produce visually clean web pages. \u21a9","title":"3. Install Python on your personal computer [Optional, but desirable]"},{"location":"00_Preparing/10_Course_schedule/","text":"Course Schedule Week Topic Assignment Jan 1 0. Course start-up. Part I: Procedural programming Jan 1 1. Introduction to computer science. 1 Jan 8 2. SIPO (sequence, input, processing and output) programming. 2 Jan 15 3. Selection control structures. 3 Jan 22 4. Repetition control structures. 4 Part II: Object-based programming Jan 29 5. Aggregate data types 1: Lists and strings. 5 Feb 5 6. Functions. 6 Feb 12 7. Aggregate data types 2: Dictionaries. 7 Feb 26 8. Text Files. 8 Part III: Object-oriented programming Mar 4 9. Object-oriented programming (OOP) 1: Encapsulation 9 Mar 7 Last day to withdraw without academic penalty. Mar 11 10. Object-oriented design (OOD). 10 Mar 18 OOD continued Mar 25 11. Object-oriented programming (OOP) 2: Polymorphism and inheritance 11 Apr 1 12. Testing (doctest) and documentation (UML) 12 Apr 8 Final Exam Preparation","title":"Course Schedule"},{"location":"00_Preparing/10_Course_schedule/#course-schedule","text":"Week Topic Assignment Jan 1 0. Course start-up. Part I: Procedural programming Jan 1 1. Introduction to computer science. 1 Jan 8 2. SIPO (sequence, input, processing and output) programming. 2 Jan 15 3. Selection control structures. 3 Jan 22 4. Repetition control structures. 4 Part II: Object-based programming Jan 29 5. Aggregate data types 1: Lists and strings. 5 Feb 5 6. Functions. 6 Feb 12 7. Aggregate data types 2: Dictionaries. 7 Feb 26 8. Text Files. 8 Part III: Object-oriented programming Mar 4 9. Object-oriented programming (OOP) 1: Encapsulation 9 Mar 7 Last day to withdraw without academic penalty. Mar 11 10. Object-oriented design (OOD). 10 Mar 18 OOD continued Mar 25 11. Object-oriented programming (OOP) 2: Polymorphism and inheritance 11 Apr 1 12. Testing (doctest) and documentation (UML) 12 Apr 8 Final Exam Preparation","title":"Course Schedule"},{"location":"00_Preparing/11_Course_outline/","text":"The official course outline","title":"11 Course outline"},{"location":"00_Preparing/12_Course_philosophy/","text":"Course Philosophy I think Kernighan and Plauger nailed it on the cover of their seminal book Software Tools in Pascal 1 : The fine print in the image says: Good programming is not learned from generalities, but by seeing how significant programs can be made clean, easy to read, easy to maintain and modify, human-engineered, efficient, and reliable, by the application of common sense and good programming practices. Careful study and imitation of good programs leads to better writing. This has certainly been true for me, and most of the students I have taught. Accordingly this course is designed around modelling and practice. I model for you how to write programs either by describing it on web pages or, when something is better shown than told, showing you in video screencasts. In many modules additional example programs are provided for you to study. Finally, the assignments (with the exception of the first introductory module) all aim to get you writing code in a careful sequence that will take you in stages from writing simplistic programs to writing subtle and powerful ones. Kernighan, Brian W. and P. J. Plauger Software Tools in Pascal , Reading, Massachusetts: Addison-Wesley, 1981. \u21a9","title":"Course Philosophy"},{"location":"00_Preparing/12_Course_philosophy/#course-philosophy","text":"I think Kernighan and Plauger nailed it on the cover of their seminal book Software Tools in Pascal 1 : The fine print in the image says: Good programming is not learned from generalities, but by seeing how significant programs can be made clean, easy to read, easy to maintain and modify, human-engineered, efficient, and reliable, by the application of common sense and good programming practices. Careful study and imitation of good programs leads to better writing. This has certainly been true for me, and most of the students I have taught. Accordingly this course is designed around modelling and practice. I model for you how to write programs either by describing it on web pages or, when something is better shown than told, showing you in video screencasts. In many modules additional example programs are provided for you to study. Finally, the assignments (with the exception of the first introductory module) all aim to get you writing code in a careful sequence that will take you in stages from writing simplistic programs to writing subtle and powerful ones. Kernighan, Brian W. and P. J. Plauger Software Tools in Pascal , Reading, Massachusetts: Addison-Wesley, 1981. \u21a9","title":"Course Philosophy"},{"location":"00_Preparing/13_What_language/","text":"What Language? I've read the course description but I still don't know what language we will be using. Careful readers will have noticed that the particular language the course will use is not mentioned in the course description. This is by design, not accident. Like fashions programming languages come and go but the fundamentals change much more slowly. This course is decidedly about the fundamentals, and hopefully the course description will outlast current language fashions. No, really, what language will we be using? We'll be using the language Python . Why Python? Python was designed to be a teaching language. This means that concepts can be introduced one at a time, and lots of messy details delayed until they are needed. Industrial-strength languages like Java and C++ are good for developing huge software systems, after all that's what they were designed for, but they are problematic as first languages. For instance in Java to write a very simple program, one that just displays the message \"Hi\" on the screen, the code would look like this: class myfirstjavaprog { public static void main(String args[]) { System.out.println(\"Hi!\"); } } and in C++ it would look like this: #include <iostream> int main() { std::cout << \"Hi!\\n\"; } As you can see in Java and C++ there are a lot of concepts that have to be explained (e.g. in Java: class , public , static , void , main , String , arg[] , System.out.println ) before one can write even a very simple program. In Python the program is just: print( \"Hi!\" ) which is self-explanatory. If you're still not convinced think about learning to fly. Your goal might be to fly 747s or F14s but you don't learn to fly on those planes because they are too complicated, and too unforgiving of mistakes. You learn to fly in a small Cessna. Once you have mastered the principles of flying you move on and upwards. Interestingly the charms of Python are so seductive that some programmers never leave it (it is for example one of only three internally supported languages at Google). (It's also free in both * senses and available across most platforms.) And there's this... \ud83d\ude00 [*]\"free as in beer\" and \"free as in speech\" see Wikipedia or just Google \"free as in beer\".","title":"What Language?"},{"location":"00_Preparing/13_What_language/#what-language","text":"","title":"What Language?"},{"location":"00_Preparing/13_What_language/#ive-read-the-course-description-but-i-still-dont-know-what-language-we-will-be-using","text":"Careful readers will have noticed that the particular language the course will use is not mentioned in the course description. This is by design, not accident. Like fashions programming languages come and go but the fundamentals change much more slowly. This course is decidedly about the fundamentals, and hopefully the course description will outlast current language fashions.","title":"I've read the course description but I still don't know what language we will be using."},{"location":"00_Preparing/13_What_language/#no-really-what-language-will-we-be-using","text":"We'll be using the language Python .","title":"No, really, what language will we be using?"},{"location":"00_Preparing/13_What_language/#why-python","text":"Python was designed to be a teaching language. This means that concepts can be introduced one at a time, and lots of messy details delayed until they are needed. Industrial-strength languages like Java and C++ are good for developing huge software systems, after all that's what they were designed for, but they are problematic as first languages. For instance in Java to write a very simple program, one that just displays the message \"Hi\" on the screen, the code would look like this: class myfirstjavaprog { public static void main(String args[]) { System.out.println(\"Hi!\"); } } and in C++ it would look like this: #include <iostream> int main() { std::cout << \"Hi!\\n\"; } As you can see in Java and C++ there are a lot of concepts that have to be explained (e.g. in Java: class , public , static , void , main , String , arg[] , System.out.println ) before one can write even a very simple program. In Python the program is just: print( \"Hi!\" ) which is self-explanatory. If you're still not convinced think about learning to fly. Your goal might be to fly 747s or F14s but you don't learn to fly on those planes because they are too complicated, and too unforgiving of mistakes. You learn to fly in a small Cessna. Once you have mastered the principles of flying you move on and upwards. Interestingly the charms of Python are so seductive that some programmers never leave it (it is for example one of only three internally supported languages at Google). (It's also free in both * senses and available across most platforms.)","title":"Why Python?"},{"location":"00_Preparing/13_What_language/#and-theres-this","text":"[*]\"free as in beer\" and \"free as in speech\" see Wikipedia or just Google \"free as in beer\".","title":"And there's this... \ud83d\ude00"},{"location":"00_Preparing/14_Marking_scheme/","text":"Assignment Marking Scheme Programming problems will usually be marked out of 10 according to the following scheme. 9, 10 \u2192 Excellent work. Does (or exceeds!) what the assignment requested exceptionally well. The final product is simple, yet elegant. 7, 8 \u2192 Good work. Does what the assignment requested, and does it well: thought has been given to the design, attention has been paid to details, and care taken in the implementation. 6 \u2192 Acceptable work. Does what the assignment requested, but no more, and without elegance or craft, i.e. your program works correctly, can be read, is not horribly inefficient. 5 \u2192 Marginal work. Barely does what the assignment requested. 0 , 1 , 2 , 3 , 4 \u2192 Unacceptable work. Does not do the minimum specified by the assignment. Sometimes it is helpful to remind ourselves what key words mean: ex\u00b7cel\u00b7lent \u2014adj. 1. Of the highest or finest quality; exceptionally good of its kind. good \u2014adj. 1. Having positive or desirable qualities; not bad or poor. ac\u00b7cept\u00b7a\u00b7ble \u2014adj. 1. Worthy of being accepted. 2. Adequate enough to satisfy a need, requirement, or standard; satisfactory. 3. Designating an amount or level that can be endured or allowed. Source: The American Heritage Dictionary and Electronic Thesaurus are licensed from Houghton Mifflin Company. Copyright \u00a9 1986, 1987 by Houghton Mifflin Company. All rights reserved. Based upon The American Heritage Dictionary.","title":"Assignment Marking Scheme"},{"location":"00_Preparing/14_Marking_scheme/#assignment-marking-scheme","text":"Programming problems will usually be marked out of 10 according to the following scheme. 9, 10 \u2192 Excellent work. Does (or exceeds!) what the assignment requested exceptionally well. The final product is simple, yet elegant. 7, 8 \u2192 Good work. Does what the assignment requested, and does it well: thought has been given to the design, attention has been paid to details, and care taken in the implementation. 6 \u2192 Acceptable work. Does what the assignment requested, but no more, and without elegance or craft, i.e. your program works correctly, can be read, is not horribly inefficient. 5 \u2192 Marginal work. Barely does what the assignment requested. 0 , 1 , 2 , 3 , 4 \u2192 Unacceptable work. Does not do the minimum specified by the assignment. Sometimes it is helpful to remind ourselves what key words mean: ex\u00b7cel\u00b7lent \u2014adj. 1. Of the highest or finest quality; exceptionally good of its kind. good \u2014adj. 1. Having positive or desirable qualities; not bad or poor. ac\u00b7cept\u00b7a\u00b7ble \u2014adj. 1. Worthy of being accepted. 2. Adequate enough to satisfy a need, requirement, or standard; satisfactory. 3. Designating an amount or level that can be endured or allowed. Source: The American Heritage Dictionary and Electronic Thesaurus are licensed from Houghton Mifflin Company. Copyright \u00a9 1986, 1987 by Houghton Mifflin Company. All rights reserved. Based upon The American Heritage Dictionary.","title":"Assignment Marking Scheme"},{"location":"00_Preparing/15_Examinable_topics_pointer/","text":"Examinable Topics If the learning outcomes in the official course outline seem a little vague or general to you, you might find the list of examinable topics more concrete.","title":"Examinable Topics"},{"location":"00_Preparing/15_Examinable_topics_pointer/#examinable-topics","text":"If the learning outcomes in the official course outline seem a little vague or general to you, you might find the list of examinable topics more concrete.","title":"Examinable Topics"},{"location":"00_Preparing/20_Textbooks/","text":"Textbooks Enough material will be posted on this website to enable you to complete the course, but if you are an information glutton who enjoys devouring multiple information resources there are several good online books available: Think Python: How to Think Like a Computer Scientist 2e by Allen B. Downey. A simple and clear text. The presentation in this book is closest to my presentation of the course material, though a couple of topics are covered out of sequence. It does not cover as much material as our course, but is a useful supplement for the material it does cover. Learn Python 3 The Hard Way, 2nd Edition . This one is for hands-on learners: it emphasizes typing code examples in. Hands-on Python 3 Tutorial by Andrew N. Harrington. Has the least-polished on-screen presentation, but solid information. All on one HTML page so you can use Ctrl-F to search it easily. Dive into Python 3 by Mark Pilgrim. Excellent, but advanced. Assumes you already know how to program in some language. Most useful once you have completed Part I of this course.","title":"Textbooks"},{"location":"00_Preparing/20_Textbooks/#textbooks","text":"Enough material will be posted on this website to enable you to complete the course, but if you are an information glutton who enjoys devouring multiple information resources there are several good online books available: Think Python: How to Think Like a Computer Scientist 2e by Allen B. Downey. A simple and clear text. The presentation in this book is closest to my presentation of the course material, though a couple of topics are covered out of sequence. It does not cover as much material as our course, but is a useful supplement for the material it does cover. Learn Python 3 The Hard Way, 2nd Edition . This one is for hands-on learners: it emphasizes typing code examples in. Hands-on Python 3 Tutorial by Andrew N. Harrington. Has the least-polished on-screen presentation, but solid information. All on one HTML page so you can use Ctrl-F to search it easily. Dive into Python 3 by Mark Pilgrim. Excellent, but advanced. Assumes you already know how to program in some language. Most useful once you have completed Part I of this course.","title":"Textbooks"},{"location":"00_Preparing/30_Installing_python/","text":"Installing Python Here are some brief guidelines for installing Python. They have been sufficient for most students to get it installed, but don't hesitate to let me know if you get stuck or are uncertain about how to proceed at some point in the process. Version : We will be using Python 3.x (where x \u2265 10). Windows users : Go to the Python download page and select version 3.11. This will download an MSI file that you can then execute to install Python. Macintosh users : Python comes pre-installed on Mac OS X but may not include a graphical development environment. Check the Python.org page Python on the Mac for more information. Linux users : If you are using a Linux system you probably already have Python installed. Check your menus and see. If you don't see an entry for Python, try typing which python at a shell prompt. If you get back a path, e.g. /usr/bin/python , it means Python is installed and you're good to go. If not, use your package manager to install Python 3.x. (If you don't know what your package manager is, or what a shell prompt is, you might not be ready for Linux). Testing your installation You can run Python at an unadorned command line or in a more helpful GUI ( G raphical U ser I nterface) environment. The standard Python GUI is called IDLE, and is what I will describe using throughout the course. (If you have some programming experience or just like trying software out there are numerous other more powerful Pyton IDEs you can explore. Let the Google guide you!) If you run IDLE you will get a window that looks something like this (allowing for OS and version differences, and probably larger\u2014I scaled it down a bit to keep the image compact), You can check that Python is working by typing a couple of commands. First type: print( \"Hello Python\" ) and then press the Enter key. Then try typing: print( 2**16 ) and pressing Enter. If you see this, it's working! And you've learned your first Python statement: print . If you don't see that, get in touch, and we'll sort things out.","title":"Installing Python"},{"location":"00_Preparing/30_Installing_python/#installing-python","text":"Here are some brief guidelines for installing Python. They have been sufficient for most students to get it installed, but don't hesitate to let me know if you get stuck or are uncertain about how to proceed at some point in the process. Version : We will be using Python 3.x (where x \u2265 10). Windows users : Go to the Python download page and select version 3.11. This will download an MSI file that you can then execute to install Python. Macintosh users : Python comes pre-installed on Mac OS X but may not include a graphical development environment. Check the Python.org page Python on the Mac for more information. Linux users : If you are using a Linux system you probably already have Python installed. Check your menus and see. If you don't see an entry for Python, try typing which python at a shell prompt. If you get back a path, e.g. /usr/bin/python , it means Python is installed and you're good to go. If not, use your package manager to install Python 3.x. (If you don't know what your package manager is, or what a shell prompt is, you might not be ready for Linux).","title":"Installing Python"},{"location":"00_Preparing/30_Installing_python/#testing-your-installation","text":"You can run Python at an unadorned command line or in a more helpful GUI ( G raphical U ser I nterface) environment. The standard Python GUI is called IDLE, and is what I will describe using throughout the course. (If you have some programming experience or just like trying software out there are numerous other more powerful Pyton IDEs you can explore. Let the Google guide you!) If you run IDLE you will get a window that looks something like this (allowing for OS and version differences, and probably larger\u2014I scaled it down a bit to keep the image compact), You can check that Python is working by typing a couple of commands. First type: print( \"Hello Python\" ) and then press the Enter key. Then try typing: print( 2**16 ) and pressing Enter. If you see this, it's working! And you've learned your first Python statement: print . If you don't see that, get in touch, and we'll sort things out.","title":"Testing your installation"},{"location":"01_Course_Introduction/","text":"Introduction: The big picture \ud83d\udd2d This week focusses on the Big Picture of Computer Science, and we just dip our toes into Python itself. With the big picture clear in our minds the remaining weeks of the course focus on Python and programming. This week's assignment is quite different from all the others in the course. Assignment 1 is somewhat artificial, because I need a way to know that you have read the things I ask you to, so it has short answer questions, and an exercise as well. The remaining assignments are more natural and authentic since they all ask you to write programs. Have a good week, and I Iook forward to hearing from you, and seeing your work. p.s. My goal is to always respond to email during the week within 24 hours. If I haven't it's probably because I've overlooked your message. Please give me a nudge if that happens! Big Picture 1: Computer Science Big Picture 2: Computers and Programs Big Picture 3: Programming The World of the Computer: Six (+1) Key Programming Concepts Operation #1: Input Operation #2: Processing Operation #3: Output Control Structures Operation #4: Sequential Execution Operation #5: Selection Operation #6: Repetition Bonus Operation: Modularity Summary Using the Python Shell Assignment 1","title":"Introduction: The big picture \ud83d\udd2d"},{"location":"01_Course_Introduction/#introduction-the-big-picture","text":"This week focusses on the Big Picture of Computer Science, and we just dip our toes into Python itself. With the big picture clear in our minds the remaining weeks of the course focus on Python and programming. This week's assignment is quite different from all the others in the course. Assignment 1 is somewhat artificial, because I need a way to know that you have read the things I ask you to, so it has short answer questions, and an exercise as well. The remaining assignments are more natural and authentic since they all ask you to write programs. Have a good week, and I Iook forward to hearing from you, and seeing your work. p.s. My goal is to always respond to email during the week within 24 hours. If I haven't it's probably because I've overlooked your message. Please give me a nudge if that happens! Big Picture 1: Computer Science Big Picture 2: Computers and Programs Big Picture 3: Programming The World of the Computer: Six (+1) Key Programming Concepts Operation #1: Input Operation #2: Processing Operation #3: Output Control Structures Operation #4: Sequential Execution Operation #5: Selection Operation #6: Repetition Bonus Operation: Modularity Summary Using the Python Shell Assignment 1","title":"Introduction: The big picture \ud83d\udd2d"},{"location":"01_Course_Introduction/01_Big_picture_1_Computer_science/","text":"Big Picture 1: Computer Science Let's start with this quote from an eminent computer scientist: Computer Science is no more about computers than astronomy is about telescopes. \u2014 Edsger W. Dijkstra Surprised? Dijkstra is saying that the real study of computer science is not computers, but something else, and that computers are merely the tools computer scientists use to study this something else, in the same way that astronomers use telescopes to study the stars and planets. Q: What could this something else be? A: Computation! If we could redo history knowing what we do now, we would have made sure the field was called computational science not computer science. Q: Well, what on earth would the goals of a science of computation be? A: To determine what can be computed and how it can best be computed. Q: But what exactly does computed mean? Q: By computed we mean the manipulation of data by a computational procedure. We will be studying the class of computational procedures called algorithms. Algorithms are computational procedures that are guaranteed to work, i.e. find the correct answer, and to do so in a finite amount of time. (You might wonder what good a procedure that doesn't work might be, and well you might. The answer is that in some problem areas it is more important to have a quick answer that is close enough, than to take a long time to get an exact answer. Computational procedures that do not guarantee the correct/most accurate answer, but do usually produce good answers, are called heuristics.) A: What about the meaning of best up above? A: By best we mean the algorithm that makes the most efficient use of our computational resources. Q: But what are our computational resources ? A: At its heart a computer can be thought of as a processor (surprisingly similar to your hand calculator), strapped to a bank of memory. So the resources we have are the time of that processor, and the space in the memory bank. The \"best\" algorithm is the one that finds the answer or completes the computations using the least amount of processor time and the least amount of memory. One of the core interests of the field of computer science is the search for ever better algorithms. Q: How good are the algorithms they have developed? A: That varies greatly. In a few areas computer scientists have been able to prove mathematically that they have indeed found the best possible algorithm. In other areas no useful algorithm is known. And the rest of the field lies between those extremes with much of it wide open. There is another subtlety to be aware of when discussing the quality of algorithms: it is helpful to identify the computational resources to be used efficiently (processor time and memory space), but that alone isn't enough to identify the best algorithm. Consider an algorithm that uses 1 unit of time and 10 units of storage, and another that uses 10 units of time and 1 unit of storage. Which is best? The answer depends on what you have the most of in any particular application, or on the real-world demands placed on the solution, e.g. the importance of timeliness versus the \"costs\" of memory. In fact computer scientists do not generally discuss a single best algorithm, but instead talk about the envelope of solutions to a particular class of problems. The graph below plots the time and space required by alternative solutions to a particular problem. On these axes the best possible algorithm would be plotted at the origin, i.e. it would take no time and no memory to compute the answer. Notice that the fastest algorithm is A, the smallest is C, and B represents some sort of middle ground in the space. The other algorithms are less attractive. We can draw a curve through A, B, and C that represents the leading edge of what is possible. This curve is sometimes referred to as the \"envelope\", and computer scientists talk about pushing the envelope: finding algorithms that push this boundary downward closer to the origin.","title":"Big Picture 1: Computer Science"},{"location":"01_Course_Introduction/01_Big_picture_1_Computer_science/#big-picture-1-computer-science","text":"Let's start with this quote from an eminent computer scientist: Computer Science is no more about computers than astronomy is about telescopes. \u2014 Edsger W. Dijkstra Surprised? Dijkstra is saying that the real study of computer science is not computers, but something else, and that computers are merely the tools computer scientists use to study this something else, in the same way that astronomers use telescopes to study the stars and planets. Q: What could this something else be? A: Computation! If we could redo history knowing what we do now, we would have made sure the field was called computational science not computer science. Q: Well, what on earth would the goals of a science of computation be? A: To determine what can be computed and how it can best be computed. Q: But what exactly does computed mean? Q: By computed we mean the manipulation of data by a computational procedure. We will be studying the class of computational procedures called algorithms. Algorithms are computational procedures that are guaranteed to work, i.e. find the correct answer, and to do so in a finite amount of time. (You might wonder what good a procedure that doesn't work might be, and well you might. The answer is that in some problem areas it is more important to have a quick answer that is close enough, than to take a long time to get an exact answer. Computational procedures that do not guarantee the correct/most accurate answer, but do usually produce good answers, are called heuristics.) A: What about the meaning of best up above? A: By best we mean the algorithm that makes the most efficient use of our computational resources. Q: But what are our computational resources ? A: At its heart a computer can be thought of as a processor (surprisingly similar to your hand calculator), strapped to a bank of memory. So the resources we have are the time of that processor, and the space in the memory bank. The \"best\" algorithm is the one that finds the answer or completes the computations using the least amount of processor time and the least amount of memory. One of the core interests of the field of computer science is the search for ever better algorithms. Q: How good are the algorithms they have developed? A: That varies greatly. In a few areas computer scientists have been able to prove mathematically that they have indeed found the best possible algorithm. In other areas no useful algorithm is known. And the rest of the field lies between those extremes with much of it wide open. There is another subtlety to be aware of when discussing the quality of algorithms: it is helpful to identify the computational resources to be used efficiently (processor time and memory space), but that alone isn't enough to identify the best algorithm. Consider an algorithm that uses 1 unit of time and 10 units of storage, and another that uses 10 units of time and 1 unit of storage. Which is best? The answer depends on what you have the most of in any particular application, or on the real-world demands placed on the solution, e.g. the importance of timeliness versus the \"costs\" of memory. In fact computer scientists do not generally discuss a single best algorithm, but instead talk about the envelope of solutions to a particular class of problems. The graph below plots the time and space required by alternative solutions to a particular problem. On these axes the best possible algorithm would be plotted at the origin, i.e. it would take no time and no memory to compute the answer. Notice that the fastest algorithm is A, the smallest is C, and B represents some sort of middle ground in the space. The other algorithms are less attractive. We can draw a curve through A, B, and C that represents the leading edge of what is possible. This curve is sometimes referred to as the \"envelope\", and computer scientists talk about pushing the envelope: finding algorithms that push this boundary downward closer to the origin.","title":"Big Picture 1: Computer Science"},{"location":"01_Course_Introduction/02_Big_picture_2_Computers_and_programs/","text":"Big Picture 2: Computers and Programs Q: Well what about computers? What are they, and how do computer scientists use them? A: A computer is a machine that manipulates symbols. Q: What is a symbol? A: Any discrete entity can be thought of as a symbol. Common symbols are letters, numbers, punctuation marks, and strings of characters. One important implication of this is that computers can be used to manipulate anything that can be represented symbolically. Q: How does the computer manipulate the symbols? A: According to rules. Q: What rules? A: The rules you\u2014the programmer\u2014specify. Q: How do I do that? A: First you find/develop a computational procedure that solves the problem at hand. (This is known as an algorithm). Next you write that procedure as a computer program. Then you load it into the computer. Finally you run/execute the program enabling it take control of the computer and its resources, and admire your handiwork. Q: Great. But what's a program? A: A list of instructions telling the computer what to do.","title":"Big Picture 2: Computers and Programs"},{"location":"01_Course_Introduction/02_Big_picture_2_Computers_and_programs/#big-picture-2-computers-and-programs","text":"Q: Well what about computers? What are they, and how do computer scientists use them? A: A computer is a machine that manipulates symbols. Q: What is a symbol? A: Any discrete entity can be thought of as a symbol. Common symbols are letters, numbers, punctuation marks, and strings of characters. One important implication of this is that computers can be used to manipulate anything that can be represented symbolically. Q: How does the computer manipulate the symbols? A: According to rules. Q: What rules? A: The rules you\u2014the programmer\u2014specify. Q: How do I do that? A: First you find/develop a computational procedure that solves the problem at hand. (This is known as an algorithm). Next you write that procedure as a computer program. Then you load it into the computer. Finally you run/execute the program enabling it take control of the computer and its resources, and admire your handiwork. Q: Great. But what's a program? A: A list of instructions telling the computer what to do.","title":"Big Picture 2: Computers and Programs"},{"location":"01_Course_Introduction/03_Big_picture_3_Programming/","text":"Big Picture 3: Programming Q : So I had an idea of what a computer is, and what a program is, but I still wasn't sure what computer programming was so I googled \"computer programming is\" and it led me to this: Computer Programming is a field that involves the methodology behind the programming, software abstraction, algorithms, data structures, design, testing, and maintenance of computer software. \u2014 Wikiversity which is more detail than I needed. Could you just tell me what a computer program is? A : A list of instructions telling the computer what to do. Q : And programming is writing down those instructions? A : Well you have to think of them first, but yes. Q : That sounds pretty straightforward. Why do some people find it hard? A : Well there are a few catches. Sometimes it's not obvious how to represent things using symbols. The computer doesn't speak English, so you have to learn its language. Computer languages don't refer to the natural world we are used to of sun, sky, trees, people, desks, etc. They refer to objects in their own worlds. The computer can only do very simple manipulations at each step (remember its processor is not much more powerful than a handheld calculator), so you have to specify things in (sometimes excruciating) detail. Q : That doesn't sound so good. Is there a bright side? A : Sure, While the words in computer languages may refer to an unfamiliar world, it is a shockingly simple world. For example many of them are built on just six key concepts. Although computers don't speak English, the languages they do use contain very few words (the complete list of Python keywords contains only 35 words). A large set of techniques has been developed to deal with commonly occuring situations, so you almost never have to start from scratch. As a student your job is to learn those techniques. The main goal of this course is to teach you those concepts, in that language, and to put them to use using those techniques. Further reading (Optional) For more see Wikipedia's page on Computer Programming . You won't be examined on it, but reading it over will provide you with invaluable background information. It introduces many of the major concepts and concerns that occupy programmers. You won't understand every bit of it on first reading, but that's okay; the ideas will recur as you move through the course.","title":"Big Picture 3: Programming"},{"location":"01_Course_Introduction/03_Big_picture_3_Programming/#big-picture-3-programming","text":"Q : So I had an idea of what a computer is, and what a program is, but I still wasn't sure what computer programming was so I googled \"computer programming is\" and it led me to this: Computer Programming is a field that involves the methodology behind the programming, software abstraction, algorithms, data structures, design, testing, and maintenance of computer software. \u2014 Wikiversity which is more detail than I needed. Could you just tell me what a computer program is? A : A list of instructions telling the computer what to do. Q : And programming is writing down those instructions? A : Well you have to think of them first, but yes. Q : That sounds pretty straightforward. Why do some people find it hard? A : Well there are a few catches. Sometimes it's not obvious how to represent things using symbols. The computer doesn't speak English, so you have to learn its language. Computer languages don't refer to the natural world we are used to of sun, sky, trees, people, desks, etc. They refer to objects in their own worlds. The computer can only do very simple manipulations at each step (remember its processor is not much more powerful than a handheld calculator), so you have to specify things in (sometimes excruciating) detail. Q : That doesn't sound so good. Is there a bright side? A : Sure, While the words in computer languages may refer to an unfamiliar world, it is a shockingly simple world. For example many of them are built on just six key concepts. Although computers don't speak English, the languages they do use contain very few words (the complete list of Python keywords contains only 35 words). A large set of techniques has been developed to deal with commonly occuring situations, so you almost never have to start from scratch. As a student your job is to learn those techniques. The main goal of this course is to teach you those concepts, in that language, and to put them to use using those techniques. Further reading (Optional) For more see Wikipedia's page on Computer Programming . You won't be examined on it, but reading it over will provide you with invaluable background information. It introduces many of the major concepts and concerns that occupy programmers. You won't understand every bit of it on first reading, but that's okay; the ideas will recur as you move through the course.","title":"Big Picture 3: Programming"},{"location":"01_Course_Introduction/04_The_world_of_the_computer_Six_key_programming_concepts/","text":"The World of the Computer: Six (+1) Key Programming Concepts Most programmers (and by most, I mean the overwhelming majority) use imperative programming techniques that would have been familiar to their distant ancestors in the 1970s. Those techniques may be wrapped up in objects, but still basically push bits around using assignment, indexing, loops, conditionals, and function calls. \u2014 Greg Wilson There are just six crucial programming operations. These six are sufficient to express any computation in any field 1 , whether it is a scientific calculation, altering the pixels in an image, transmitting a file across a network, compiling a report from a database, or triggering the iginition in a car. Since these operations are instructions to the computer to do things we first need a model of a computer. Here's one sufficient to understand most of the programming we will do in this course. It doesn't look very much like the computer in front of you. There is no monitor, no keyboard, no mouse, no system unit. That's because it is a functional diagram of a computer not a physical diagram, and from a programming point of view, from the computer's point of view , this is all there is to a computer. In fact this is all there is to any computer. They all share these components. a processor that manipulates data, usually confined to very simple arithmetic (think addition, multiplication) and logical (think of light switches controlling lights) operations. a block of memory to store values created during processing. This can vary in size from a few bytes for dedicated processors to gigabytes on large servers. an input channel used to load values into the processor. Your keyboard, mouse, microphone, network all feed into the input channel. an output channel that can be used to emit values from the processor or memory. Your screen, speakers and network connection are fed by the output channel. The six operations consist of three elementary operations: input processing, and output and three control structures, sequence selection, and repetition See The Structured Program Theorem . \u21a9","title":"The World of the Computer:<br> Six (+1) Key Programming Concepts"},{"location":"01_Course_Introduction/04_The_world_of_the_computer_Six_key_programming_concepts/#the-world-of-the-computer-six-1-key-programming-concepts","text":"Most programmers (and by most, I mean the overwhelming majority) use imperative programming techniques that would have been familiar to their distant ancestors in the 1970s. Those techniques may be wrapped up in objects, but still basically push bits around using assignment, indexing, loops, conditionals, and function calls. \u2014 Greg Wilson There are just six crucial programming operations. These six are sufficient to express any computation in any field 1 , whether it is a scientific calculation, altering the pixels in an image, transmitting a file across a network, compiling a report from a database, or triggering the iginition in a car. Since these operations are instructions to the computer to do things we first need a model of a computer. Here's one sufficient to understand most of the programming we will do in this course. It doesn't look very much like the computer in front of you. There is no monitor, no keyboard, no mouse, no system unit. That's because it is a functional diagram of a computer not a physical diagram, and from a programming point of view, from the computer's point of view , this is all there is to a computer. In fact this is all there is to any computer. They all share these components. a processor that manipulates data, usually confined to very simple arithmetic (think addition, multiplication) and logical (think of light switches controlling lights) operations. a block of memory to store values created during processing. This can vary in size from a few bytes for dedicated processors to gigabytes on large servers. an input channel used to load values into the processor. Your keyboard, mouse, microphone, network all feed into the input channel. an output channel that can be used to emit values from the processor or memory. Your screen, speakers and network connection are fed by the output channel. The six operations consist of three elementary operations: input processing, and output and three control structures, sequence selection, and repetition See The Structured Program Theorem . \u21a9","title":"The World of the Computer: Six (+1) Key Programming Concepts"},{"location":"01_Course_Introduction/05_Operation_1_Input/","text":"Operation #1: Input The first programming operation is input . A quick glance at our functional diagram will show you that the computer is empty, there is nothing in memory. We can't do any processing until we have something to process. The way we get something to process is to input it into the computer. An input statement accepts one value from the input channel and stores it in memory. An example will illustrate the details. Conveniently Python names the input command input . To input a value and store it with the name speed and then input a second value and store it with the name duration we use the commands, speed = int(input()) duration = int(input()) Each of these statements will look to the input channel, take the next value from it, store it in memory and label the value as a number (int). The first statement labels the value it stores speed and the second labels its value duration . Why label them? So we have a way to refer to them later when we want to use them. The effect on our computer is shown below (assuming the values entered are 90 and 4).","title":"Operation #1: Input"},{"location":"01_Course_Introduction/05_Operation_1_Input/#operation-1-input","text":"The first programming operation is input . A quick glance at our functional diagram will show you that the computer is empty, there is nothing in memory. We can't do any processing until we have something to process. The way we get something to process is to input it into the computer. An input statement accepts one value from the input channel and stores it in memory. An example will illustrate the details. Conveniently Python names the input command input . To input a value and store it with the name speed and then input a second value and store it with the name duration we use the commands, speed = int(input()) duration = int(input()) Each of these statements will look to the input channel, take the next value from it, store it in memory and label the value as a number (int). The first statement labels the value it stores speed and the second labels its value duration . Why label them? So we have a way to refer to them later when we want to use them. The effect on our computer is shown below (assuming the values entered are 90 and 4).","title":"Operation #1: Input"},{"location":"01_Course_Introduction/06_Operation_2_Processing/","text":"Operation #2: Processing Once we have the necessary data in memory we \"process\" it. Processing refers to the manipulation of data stored in memory. Most procedural languages use an assignment statement to specify the processing to be performed. The form of an assignment statement is: name = expression . The assignment statement instructs the computer to calculate the value of expression and to store the result and label it name . Here's an example in Python, distance = duration * speed This statement causes the processor to retrieve the values of duration and speed from memory, multiply them, store the result in memory and label it distance . The effect on the state of the computer is shown below. That assignment statement looks a lot like a mathematical equation. This is a holdover from one of the earliest programming languages FORTRAN (short for FORmula TRANslator), and is both a blessing and a curse. It is a blessing because most people have some experience with equations, and assignment statements are a lot like equations. It is a curse because they are not exactly like equations. The first unimportant difference is that the statement above uses an asterisk to specify multiplication where we are used to using a times symbol, \u00d7, that looks like an x. However most computer languages can't use an x for multiplication because x could be a name, and computers don't have an easy way to tell which x's in your program mean perform a multiplication and which ones are names. To avoid confusion an entirely different symbol, * , is used for multiplication. This is not Python-specific all the mainstream languages use the * for multiplication. In fact humans don't really use x for both multiplication and names, we just think we do because of the limited choices on our computer keyboard. When we write with a more flexible tool though, like a pen on paper, we usually use x as a name and \u00d7 for multiplication. The other basic operators are the ones you are used to: + for addition - for subtraction / for division The other basic operation is exponentiation or informally \"powers\". When we do math on paper we write 2 3 for \"two cubed\" or 2 \u00d7 2 \u00d7 2 but early programming languages had no easy way to type a superscript and so adopted other notations. Python uses ** for exponentiation so 2**3 for two-cubed (the other common choice in programming languages is ^ or 2^3). The pair of asterisks is to remind us of repeated multiplication. The fact that assignment statements look a bit like equations, has prompted many people to refer to the names of memory locations (i.e. rate , duration and distance ) as variables , and programmers do this too. It's not inaccurate since the same name can refer to different values at different times in the life of a program. But it is crucial to remember that assignment statements are not equations. To emphasize this consider the following example, x = x + 1 Depending on how long it's been since you thought about equations carefully this may not look odd at first, but mathematically it is nonsense because there is no number that is equal to itself plus 1! It is however perfectly valid and sensible Python. Here's how the computer interprets it. Fetch the value of x from memory, add 1 to it, and then store the result back in memory labelling the new value x. So in Python this assignment statement says to increment the value of x by 1. The key here is that assignment statements should be read from right to left. Remember the form of the assignment statement was: name = expression . The expression on the right is evaluated and the result stored using the name on the left. Note that the expression is always on the right and the name always on the left. While it is ok to write x = x + 1 Python will complain and generate an error message if you write x + 1 = x . Try it in IDLE and see.","title":"Operation #2: Processing"},{"location":"01_Course_Introduction/06_Operation_2_Processing/#operation-2-processing","text":"Once we have the necessary data in memory we \"process\" it. Processing refers to the manipulation of data stored in memory. Most procedural languages use an assignment statement to specify the processing to be performed. The form of an assignment statement is: name = expression . The assignment statement instructs the computer to calculate the value of expression and to store the result and label it name . Here's an example in Python, distance = duration * speed This statement causes the processor to retrieve the values of duration and speed from memory, multiply them, store the result in memory and label it distance . The effect on the state of the computer is shown below. That assignment statement looks a lot like a mathematical equation. This is a holdover from one of the earliest programming languages FORTRAN (short for FORmula TRANslator), and is both a blessing and a curse. It is a blessing because most people have some experience with equations, and assignment statements are a lot like equations. It is a curse because they are not exactly like equations. The first unimportant difference is that the statement above uses an asterisk to specify multiplication where we are used to using a times symbol, \u00d7, that looks like an x. However most computer languages can't use an x for multiplication because x could be a name, and computers don't have an easy way to tell which x's in your program mean perform a multiplication and which ones are names. To avoid confusion an entirely different symbol, * , is used for multiplication. This is not Python-specific all the mainstream languages use the * for multiplication. In fact humans don't really use x for both multiplication and names, we just think we do because of the limited choices on our computer keyboard. When we write with a more flexible tool though, like a pen on paper, we usually use x as a name and \u00d7 for multiplication. The other basic operators are the ones you are used to: + for addition - for subtraction / for division The other basic operation is exponentiation or informally \"powers\". When we do math on paper we write 2 3 for \"two cubed\" or 2 \u00d7 2 \u00d7 2 but early programming languages had no easy way to type a superscript and so adopted other notations. Python uses ** for exponentiation so 2**3 for two-cubed (the other common choice in programming languages is ^ or 2^3). The pair of asterisks is to remind us of repeated multiplication. The fact that assignment statements look a bit like equations, has prompted many people to refer to the names of memory locations (i.e. rate , duration and distance ) as variables , and programmers do this too. It's not inaccurate since the same name can refer to different values at different times in the life of a program. But it is crucial to remember that assignment statements are not equations. To emphasize this consider the following example, x = x + 1 Depending on how long it's been since you thought about equations carefully this may not look odd at first, but mathematically it is nonsense because there is no number that is equal to itself plus 1! It is however perfectly valid and sensible Python. Here's how the computer interprets it. Fetch the value of x from memory, add 1 to it, and then store the result back in memory labelling the new value x. So in Python this assignment statement says to increment the value of x by 1. The key here is that assignment statements should be read from right to left. Remember the form of the assignment statement was: name = expression . The expression on the right is evaluated and the result stored using the name on the left. Note that the expression is always on the right and the name always on the left. While it is ok to write x = x + 1 Python will complain and generate an error message if you write x + 1 = x . Try it in IDLE and see.","title":"Operation #2: Processing"},{"location":"01_Course_Introduction/07_Operation_3_Output/","text":"Operation #3: Output Our statements so far, speed = int(input()) duration = int(input()) distance = duration * speed have calculated the quantity distance based on the input values of speed and duration , but we don't know what it is because that value exists only inside the memory of our computer. To see it we need to output it where we can look at it. The most common output command in Python is the print statement. To print the value of distance we would simply use the command, print(distance) We can also print the values of expressions, e.g. print(2**8 - 1)","title":"Operation #3: Output"},{"location":"01_Course_Introduction/07_Operation_3_Output/#operation-3-output","text":"Our statements so far, speed = int(input()) duration = int(input()) distance = duration * speed have calculated the quantity distance based on the input values of speed and duration , but we don't know what it is because that value exists only inside the memory of our computer. To see it we need to output it where we can look at it. The most common output command in Python is the print statement. To print the value of distance we would simply use the command, print(distance) We can also print the values of expressions, e.g. print(2**8 - 1)","title":"Operation #3: Output"},{"location":"01_Course_Introduction/08_Control_structures/","text":"Control Structures The first three statements we have seen are the elementary processing operations. The question that arises is how to specify the order in which the commands should be executed. The next three statements control the order of execution of the elementary statements, and so are often called control statements, or sometimes control structures. The first is not actually a statement, but just the presentation of a program.","title":"Control Structures"},{"location":"01_Course_Introduction/08_Control_structures/#control-structures","text":"The first three statements we have seen are the elementary processing operations. The question that arises is how to specify the order in which the commands should be executed. The next three statements control the order of execution of the elementary statements, and so are often called control statements, or sometimes control structures. The first is not actually a statement, but just the presentation of a program.","title":"Control Structures"},{"location":"01_Course_Introduction/09_Operation_4_Sequential_execution/","text":"Operation #4: Sequential Execution Together our first four commands make a little program and illustrate the fourth operation: sequential execution. speed = int(input()) duration = int(input()) distance = duration * speed print(distance) By default the computer executes statements in the order they are presented, from first to last, top to bottom (the same order in which we are used to reading). Note that the order can be crucial. Our program will still work if we swap the first two statements, but most other reorderings will produce errors. For example swapping the second and third ones, speed = int(input()) distance = duration * speed duration = int(input()) print(distance) or the second and fourth ones, speed = int(input()) print(distance) distance = duration * speed duration = int(input()) or the third and fourth ones, speed = int(input()) duration = int(input()) print(distance) distance = duration * speed To understand why each of these other orderings results in an error try stepping through the effects of the statements using a functional diagram of a computer. If you do so precisely you will soon see the problem created by each reordering. This ability to step through a program precisely (or to play computer) is the key skill in debugging programs. It is also instructive to try running each of these programs in Python (you'll see how to do this shortly) to see the error messages they generate. You'll be seeing a lot of error messages this term, and until you know what conditions create them they can appear inscrutable. So the sooner you get to know them the easier it will be for you to debug your own programs. With the first three commands, and the default sequential execution behaviour, we can write programs that gather input, process it, and output results. But with only sequential execution they must always process the input in the same way. These programs are calculator like: You gather the numbers you need, process them and look at the answer. We will refer to them as SIPO (Sequential Input, Processing, Output) programs. This is the only type of program you will need to write for the next module's assignment, but since there are only two more fundamental operations I want to introduce them to you now. We'll look at them in depth in Modules 3 and 4.","title":"Operation #4: Sequential Execution"},{"location":"01_Course_Introduction/09_Operation_4_Sequential_execution/#operation-4-sequential-execution","text":"Together our first four commands make a little program and illustrate the fourth operation: sequential execution. speed = int(input()) duration = int(input()) distance = duration * speed print(distance) By default the computer executes statements in the order they are presented, from first to last, top to bottom (the same order in which we are used to reading). Note that the order can be crucial. Our program will still work if we swap the first two statements, but most other reorderings will produce errors. For example swapping the second and third ones, speed = int(input()) distance = duration * speed duration = int(input()) print(distance) or the second and fourth ones, speed = int(input()) print(distance) distance = duration * speed duration = int(input()) or the third and fourth ones, speed = int(input()) duration = int(input()) print(distance) distance = duration * speed To understand why each of these other orderings results in an error try stepping through the effects of the statements using a functional diagram of a computer. If you do so precisely you will soon see the problem created by each reordering. This ability to step through a program precisely (or to play computer) is the key skill in debugging programs. It is also instructive to try running each of these programs in Python (you'll see how to do this shortly) to see the error messages they generate. You'll be seeing a lot of error messages this term, and until you know what conditions create them they can appear inscrutable. So the sooner you get to know them the easier it will be for you to debug your own programs. With the first three commands, and the default sequential execution behaviour, we can write programs that gather input, process it, and output results. But with only sequential execution they must always process the input in the same way. These programs are calculator like: You gather the numbers you need, process them and look at the answer. We will refer to them as SIPO (Sequential Input, Processing, Output) programs. This is the only type of program you will need to write for the next module's assignment, but since there are only two more fundamental operations I want to introduce them to you now. We'll look at them in depth in Modules 3 and 4.","title":"Operation #4: Sequential Execution"},{"location":"01_Course_Introduction/10_Operation_5_Selection/","text":"Operation #5: Selection SIPO style programming is not enough for all situations because there are many areas in which the processing to be done depends on the input, e.g. the tax you pay depends on how much you earn the grade you receive depends on the quality of your work the formula to calculate the area of a figure depends on its shape the amount of leave an employee accumulates depends on their employment status To accommodate such situations we need the ability to process data selectively. Imperative/procedural programming languages (like Python) achieve this by using selection statements. To handle the cases above we test something (your earnings, your work quality, the shape of the figure, or someone's employment status) to determine how processing should proceed. The result of the test is used to select the processing to carry out. The most common selection command is the if statement. In Python the basic if statement looks like this (we'll see some variations next week), if test : statements to do if the test is true else : statements to do if the test is false The test evaluates some condition, e.g. that the input is less than 100. If it is (that is, if the test is true), the first group of statements are executed, and the second group of statements (after else ) are skipped. If the test is not true, then the first group of statements is skipped, and the second group of statements are executed. In either case only one of the two groups of statements is executed. Thus the if statement selects which group of statements to execute depending on the outcome of the test. This can be presented diagramatically by a flowchart like this:","title":"Operation #5: Selection"},{"location":"01_Course_Introduction/10_Operation_5_Selection/#operation-5-selection","text":"SIPO style programming is not enough for all situations because there are many areas in which the processing to be done depends on the input, e.g. the tax you pay depends on how much you earn the grade you receive depends on the quality of your work the formula to calculate the area of a figure depends on its shape the amount of leave an employee accumulates depends on their employment status To accommodate such situations we need the ability to process data selectively. Imperative/procedural programming languages (like Python) achieve this by using selection statements. To handle the cases above we test something (your earnings, your work quality, the shape of the figure, or someone's employment status) to determine how processing should proceed. The result of the test is used to select the processing to carry out. The most common selection command is the if statement. In Python the basic if statement looks like this (we'll see some variations next week), if test : statements to do if the test is true else : statements to do if the test is false The test evaluates some condition, e.g. that the input is less than 100. If it is (that is, if the test is true), the first group of statements are executed, and the second group of statements (after else ) are skipped. If the test is not true, then the first group of statements is skipped, and the second group of statements are executed. In either case only one of the two groups of statements is executed. Thus the if statement selects which group of statements to execute depending on the outcome of the test. This can be presented diagramatically by a flowchart like this:","title":"Operation #5: Selection"},{"location":"01_Course_Introduction/11_Operation_6_Repetition/","text":"Operation #6: Repetition Some procedures require even more than SIPO-plus-Selection; they require the ability to repeat a group of instructions, e.g. continue firing the boiler while the temperature is below the set point process records from the file until there are none left increase the brightness by 10% for every pixel in the image In all these cases the same instructions are carried out multiple times (and sometimes on multiple items). The final control structure allows us to specify the repetition of commands. Python provides two repetition statements while , and for . We will consider while here to get a flavour of repetition. The format of the while statement is: while test : statements to repeat The effect of this construct is to continue executing the statements \"inside\" the while, as long as the test is true, e.g. while the temperature is low : fire the boiler Although the italicized portions are not Python statements I hope this gives you a sense of the construct. When the program reaches the while statement it evaluates the test. If the test is false it skips over the indented statements and continues with the next statement in the program (i.e. if the temperature is not low we do not fire the boiler). If it is true however it executes the statements, and then reevaluates the test (i.e. if the temperature is low we fire the boiler and then check to see if the temperature is still low). If the test is still true it executes the statements and reevaluates the test (i.e. if the temperature is still low, fire the boiler again). If the test is still true it executes the statements and reevaluates the test. This continues until the test is false. Thus the statements are done while the test is true. Diagramatically this can be represented as,","title":"Operation #6: Repetition"},{"location":"01_Course_Introduction/11_Operation_6_Repetition/#operation-6-repetition","text":"Some procedures require even more than SIPO-plus-Selection; they require the ability to repeat a group of instructions, e.g. continue firing the boiler while the temperature is below the set point process records from the file until there are none left increase the brightness by 10% for every pixel in the image In all these cases the same instructions are carried out multiple times (and sometimes on multiple items). The final control structure allows us to specify the repetition of commands. Python provides two repetition statements while , and for . We will consider while here to get a flavour of repetition. The format of the while statement is: while test : statements to repeat The effect of this construct is to continue executing the statements \"inside\" the while, as long as the test is true, e.g. while the temperature is low : fire the boiler Although the italicized portions are not Python statements I hope this gives you a sense of the construct. When the program reaches the while statement it evaluates the test. If the test is false it skips over the indented statements and continues with the next statement in the program (i.e. if the temperature is not low we do not fire the boiler). If it is true however it executes the statements, and then reevaluates the test (i.e. if the temperature is low we fire the boiler and then check to see if the temperature is still low). If the test is still true it executes the statements and reevaluates the test (i.e. if the temperature is still low, fire the boiler again). If the test is still true it executes the statements and reevaluates the test. This continues until the test is false. Thus the statements are done while the test is true. Diagramatically this can be represented as,","title":"Operation #6: Repetition"},{"location":"01_Course_Introduction/12_Bonus_operation_modularity/","text":"Bonus Operation: Modularity The six commands we have seen so far are logically sufficient to write any program. But in pragmatic terms another is required. As programs become large it becomes more and more difficult to work on them, because there are too many interconnected parts to think about at once. What's needed is a way to break a large program up into smaller pieces, each of which can be developed in isolation of the others. These small pieces are generically called modules. As a rough guide, many programmers believe that no module should be more than a page long, i.e. about 50 lines. Beyond a page it becomes too hard to think about, and more errors are made. (Aside. How large can programs get? Thousands of lines is typical. Hundreds of thousands and millions is common. Windows 10 for example consists of around 50,000,000 lines of code, the google chrome browser has 35 million lines, and as of 2020 the Linux kernel contains around 27,800,000 lines of code.) In Python, modularization is enabled by using functions (via the def statement), classes (via the class statement) and modules (each Python program file is a module).","title":"Bonus Operation: Modularity"},{"location":"01_Course_Introduction/12_Bonus_operation_modularity/#bonus-operation-modularity","text":"The six commands we have seen so far are logically sufficient to write any program. But in pragmatic terms another is required. As programs become large it becomes more and more difficult to work on them, because there are too many interconnected parts to think about at once. What's needed is a way to break a large program up into smaller pieces, each of which can be developed in isolation of the others. These small pieces are generically called modules. As a rough guide, many programmers believe that no module should be more than a page long, i.e. about 50 lines. Beyond a page it becomes too hard to think about, and more errors are made. (Aside. How large can programs get? Thousands of lines is typical. Hundreds of thousands and millions is common. Windows 10 for example consists of around 50,000,000 lines of code, the google chrome browser has 35 million lines, and as of 2020 the Linux kernel contains around 27,800,000 lines of code.) In Python, modularization is enabled by using functions (via the def statement), classes (via the class statement) and modules (each Python program file is a module).","title":"Bonus Operation: Modularity"},{"location":"01_Course_Introduction/13_Summary/","text":"Summary The most common programming model is imperative programming which conceives of a program as a set of instructions issued to the computer. There are only six+1 key instruction types: Three elementary ones: input gets a value from the input stream and stores it in memory, processing processes/combines/manipulates values stored in memory and stores the result in memory, output sends a value to the output stream. and four control structures: sequential processing in which statements are executed one at a time in sequence, selection in which one group of statements or another, but not both, are executed, repetition in which a group of statements is executed repeatedly, modularity in which code is broken into chunks that can be named and manipulated.","title":"Summary"},{"location":"01_Course_Introduction/13_Summary/#summary","text":"The most common programming model is imperative programming which conceives of a program as a set of instructions issued to the computer. There are only six+1 key instruction types: Three elementary ones: input gets a value from the input stream and stores it in memory, processing processes/combines/manipulates values stored in memory and stores the result in memory, output sends a value to the output stream. and four control structures: sequential processing in which statements are executed one at a time in sequence, selection in which one group of statements or another, but not both, are executed, repetition in which a group of statements is executed repeatedly, modularity in which code is broken into chunks that can be named and manipulated.","title":"Summary"},{"location":"01_Course_Introduction/14_Using_the_python_shell/","text":"Using the Python Shell Python is an interpreted language as opposed to a compiled language. This means that the commands making up a Python program are translated and executed one at a time as they are encountered. This is in contrast to compiled languages where all the commands making up the program are translated at once to produce an executable program that is run after compilation is complete. One handy consequence of interpreted languages is that you can \"speak\" to the interpreter directly by entering Python commands at a prompt. The commands are executed and their effects are immediately visible. This is helpful both for learning Python commands by exploring their results and for debugging because you can run chunks of statements on their own to verify that they are producing what you expect. One way to speak to the interpreter is to enter Python commands in the Python Shell. The shell is always running a REPL, which just stands for R ead E valuate P rint L oop. That means that it will read whatever you type, try to evaluate it as a Python expression, and then print the result. The loop part means that it continues to do this forever. The three greater-than signs, >>> , are the shell's prompt that it is ready for you to enter a Python expression. You can enter any of the Python commands we have seen so far at these prompts. The shell will interpret and execute the commands and display their output. Here is a sample session that demonstrates a few commands that will be useful on the assignment. You should read through it noticing what commands produce what output, and then try recreating it in your own shell. Remember that the text after the >>> signs is what I typed and the rest is what the Python shell produced. Points to ponder: What is the difference between the arithmetic operators * and ** ? Traceback 's are error messages. You'll see many of those. What does the import command seem to do?","title":"Using the Python Shell"},{"location":"01_Course_Introduction/14_Using_the_python_shell/#using-the-python-shell","text":"Python is an interpreted language as opposed to a compiled language. This means that the commands making up a Python program are translated and executed one at a time as they are encountered. This is in contrast to compiled languages where all the commands making up the program are translated at once to produce an executable program that is run after compilation is complete. One handy consequence of interpreted languages is that you can \"speak\" to the interpreter directly by entering Python commands at a prompt. The commands are executed and their effects are immediately visible. This is helpful both for learning Python commands by exploring their results and for debugging because you can run chunks of statements on their own to verify that they are producing what you expect. One way to speak to the interpreter is to enter Python commands in the Python Shell. The shell is always running a REPL, which just stands for R ead E valuate P rint L oop. That means that it will read whatever you type, try to evaluate it as a Python expression, and then print the result. The loop part means that it continues to do this forever. The three greater-than signs, >>> , are the shell's prompt that it is ready for you to enter a Python expression. You can enter any of the Python commands we have seen so far at these prompts. The shell will interpret and execute the commands and display their output. Here is a sample session that demonstrates a few commands that will be useful on the assignment. You should read through it noticing what commands produce what output, and then try recreating it in your own shell. Remember that the text after the >>> signs is what I typed and the rest is what the Python shell produced. Points to ponder: What is the difference between the arithmetic operators * and ** ? Traceback 's are error messages. You'll see many of those. What does the import command seem to do?","title":"Using the Python Shell"},{"location":"01_Course_Introduction/90_Assignment_1/","text":"Assignment 1 Part I: Short Answer Questions This part of the assignment is a crude and blatant attempt to check that you have read over the course information materials, but I hope that writing the answers down will help you to remember some key points from the material in this module. I am not looking for creativity in the answers: feel free to cut and paste from the course notes. In fact, you could think of it as a scavenger hunt for answers in the notes. What would you like to get out of this course? How much are the assignments in the course worth? What should computer science really be called? What are our two key computational resources? What does the \"envelope of algorithm performance\" refer to? What is a computer program? What is an algorithm? List the key operations imperative programming relies on. What are the four functional components of a computer? How many keywords are there in Python? Part II: Installing the Python Shell If you want to use Python on your own computer here is the link to download and install it: https://www.python.org/downloads/ Part III: Using the Python Shell Provide the transcript of your Python shell session (including the output!) after you have used the Python shell to: Print 'Hello world!' Display the value of 2 100 . Calculate the volume of a sphere of radius 2.0 metres. (The formula for the volume of a sphere is 4\u03c0r 3 /3.) Run the following code: >>> if 10**20 > 20**10: print('10**20 wins!') else: print('20**10 wins!') Run the following code: >>> n = 6400000 >>> size = 0 >>> while n > 1: n = n // 2 size = size + 1 >>> print('6400000 is approximately 2**', size) Run the following code: >>> for c in 'Yukon': print(c) Part IV: Writing Algorithms To get some practice specifying algorithms write instructions to enable someone to recreate each of the sugar cube structures pictured below. (To mark this question, I will try and follow your instructions precisely and see how closely the result matches the goal. You might want to give the instructions to a friend and see what they construct before submitting them to me.) (i) (ii) (iii) Part V: Trading off Processors and Memory In Big Picture 1: Computer Science you read that algorithms are ranked according to how much space and time (or memory and processing) they use with the goal being to use as little of each as possible. The flipside is that most problems can be solved more quickly the more of each of those resources you have available. We'll demonstrate this in the following exercise (and we'll share our data to confirm it across trials, and perhaps get our competitive juices going). We're going to compare the time it takes to complete some processing depending on how many processors and how much memory we have. Get a deck of cards and a stopwatch (if not an actual stopwatch, any watch where you can measure time in seconds). Shuffle the deck of cards. Time how long it takes you to sort the cards into order 1 using your hands and a table top (i.e. you can spread the cards out or stack them anyway you want on the table top). Get three friends and shuffle the deck and time how long it takes the four of you to sort the cards using the tabletop. Give some thought to how you should organize your efforts. (How you do this represents your algorithm.) You might want to do multiple timings here because you will probably be faster the second and third times than the first. After a couple of attempts the rate of your improvement will probably decrease (and you'll be getting bored). Before your friends flee, shuffle the deck and then time yourselves sorting the cards again but without using the table top, i.e. all the cards have to be held in your eight hands at all times (no placing cards on your kness, head or anywhere else, or holding any in your mouth etc. Although the desire to do these things shows you just how valuable a little more memory can be.). Now that your friends have left, shuffle the deck and time yourself sorting the deck one last time but this time using only your two hands, i.e. no table top! (Or knees etc.) We'll use Bridge order where the order of the suits will be Clubs-Diamonds-Hearts-Spades and the cards within each suit will be ordered from Ace to King. \u21a9","title":"Assignment 1"},{"location":"01_Course_Introduction/90_Assignment_1/#assignment-1","text":"","title":"Assignment 1"},{"location":"01_Course_Introduction/90_Assignment_1/#part-i-short-answer-questions","text":"This part of the assignment is a crude and blatant attempt to check that you have read over the course information materials, but I hope that writing the answers down will help you to remember some key points from the material in this module. I am not looking for creativity in the answers: feel free to cut and paste from the course notes. In fact, you could think of it as a scavenger hunt for answers in the notes. What would you like to get out of this course? How much are the assignments in the course worth? What should computer science really be called? What are our two key computational resources? What does the \"envelope of algorithm performance\" refer to? What is a computer program? What is an algorithm? List the key operations imperative programming relies on. What are the four functional components of a computer? How many keywords are there in Python?","title":"Part I: Short Answer Questions"},{"location":"01_Course_Introduction/90_Assignment_1/#part-ii-installing-the-python-shell","text":"If you want to use Python on your own computer here is the link to download and install it: https://www.python.org/downloads/","title":"Part II: Installing the Python Shell"},{"location":"01_Course_Introduction/90_Assignment_1/#part-iii-using-the-python-shell","text":"Provide the transcript of your Python shell session (including the output!) after you have used the Python shell to: Print 'Hello world!' Display the value of 2 100 . Calculate the volume of a sphere of radius 2.0 metres. (The formula for the volume of a sphere is 4\u03c0r 3 /3.) Run the following code: >>> if 10**20 > 20**10: print('10**20 wins!') else: print('20**10 wins!') Run the following code: >>> n = 6400000 >>> size = 0 >>> while n > 1: n = n // 2 size = size + 1 >>> print('6400000 is approximately 2**', size) Run the following code: >>> for c in 'Yukon': print(c)","title":"Part III: Using the Python Shell"},{"location":"01_Course_Introduction/90_Assignment_1/#part-iv-writing-algorithms","text":"To get some practice specifying algorithms write instructions to enable someone to recreate each of the sugar cube structures pictured below. (To mark this question, I will try and follow your instructions precisely and see how closely the result matches the goal. You might want to give the instructions to a friend and see what they construct before submitting them to me.) (i) (ii) (iii)","title":"Part IV: Writing Algorithms"},{"location":"01_Course_Introduction/90_Assignment_1/#part-v-trading-off-processors-and-memory","text":"In Big Picture 1: Computer Science you read that algorithms are ranked according to how much space and time (or memory and processing) they use with the goal being to use as little of each as possible. The flipside is that most problems can be solved more quickly the more of each of those resources you have available. We'll demonstrate this in the following exercise (and we'll share our data to confirm it across trials, and perhaps get our competitive juices going). We're going to compare the time it takes to complete some processing depending on how many processors and how much memory we have. Get a deck of cards and a stopwatch (if not an actual stopwatch, any watch where you can measure time in seconds). Shuffle the deck of cards. Time how long it takes you to sort the cards into order 1 using your hands and a table top (i.e. you can spread the cards out or stack them anyway you want on the table top). Get three friends and shuffle the deck and time how long it takes the four of you to sort the cards using the tabletop. Give some thought to how you should organize your efforts. (How you do this represents your algorithm.) You might want to do multiple timings here because you will probably be faster the second and third times than the first. After a couple of attempts the rate of your improvement will probably decrease (and you'll be getting bored). Before your friends flee, shuffle the deck and then time yourselves sorting the cards again but without using the table top, i.e. all the cards have to be held in your eight hands at all times (no placing cards on your kness, head or anywhere else, or holding any in your mouth etc. Although the desire to do these things shows you just how valuable a little more memory can be.). Now that your friends have left, shuffle the deck and time yourself sorting the deck one last time but this time using only your two hands, i.e. no table top! (Or knees etc.) We'll use Bridge order where the order of the suits will be Clubs-Diamonds-Hearts-Spades and the cards within each suit will be ordered from Ace to King. \u21a9","title":"Part V: Trading off Processors and Memory"},{"location":"02_SIPO/","text":"Introduction: Our first programs \ud83d\udc23 The wait is over! Week 0 was about preparing for the course, and Week 1 was about course information and the \"Big Picture\", but starting now we focus on writing programs. The goals for the week are for you to become comfortable writing SIPO style programs using Python, and to get some practice in moving from a problem described in English, through a solution procedure described using English to one expressed in Python. This week we'll move on and begin writing short programs to calculate things. These programs sometimes go by the acronym SIPO to remind us of the operations they use: Sequence, Input, Processing and Output. They are just like sequences of calculator commands placed one after another. This week we will put the first four (of six) computational constructs to work to write SIPO programs. These are calculator-style programs that use a sequence ( S ) of instructions to take some data (input or I ), process it ( P ), and display the result (output or O ). I say \"calculator-style\" because the problems are ones people often use calculators for. While the programs themselves are quite short, they will introduce you to the need to keep three separate things in mind as you program: The program code What is going on in the computer's memory What is displayed on the screen One of the first challenges in learning to program is to develop the ability to keep all three things in mind as you develop your program. There are also several points of programming craft that come up for the first, but definitely not the last, time this week, including choosing good variable names, program layout, documentation, and using symbolic constants. And one arithmetic operator that is very useful in a wide variety of programs, but may be new to you: modulo. Assignment 1 was somewhat artificial, because I needed a way to know that you had read the things I'd asked you to, and that you had installed Python, but the remaining assignments are more authentic. They will usually ask you to write around 4 small programs, though our idea of what \"small\" is will grow as the course progresses! The remaining assignments are more homogeneous than the first one. There won't be more short answer questions, cards to sort, or sculptures to describe, just programs to write from here almost to the end of the course. Four programs most weeks. Recall: Programming is... The Problem Do The Problem By Hand Translate the Algorithm into Python Enter, run and test the program Naming Values What will it look like onscreen? Documentation Our second program (Same as the first only backwards) html#translate-to-python) Our third program (dhms2s.py) SIPO Summary Translate into Python Modulo: A Sixth Arithmetic Operator Symbolic Constants Intermission: Summary (so far) Object Types 1: int s and float s Example: Calculating Tree Radius Example: Value of your change Example: Making change Pythonic Details Triple Quoted Strings The Continuation Character The done trick Output Formatting The Pythonic Process Exercise sheet 1 Assignment 2","title":"Introduction: Our first programs \ud83d\udc23"},{"location":"02_SIPO/#introduction-our-first-programs","text":"The wait is over! Week 0 was about preparing for the course, and Week 1 was about course information and the \"Big Picture\", but starting now we focus on writing programs. The goals for the week are for you to become comfortable writing SIPO style programs using Python, and to get some practice in moving from a problem described in English, through a solution procedure described using English to one expressed in Python. This week we'll move on and begin writing short programs to calculate things. These programs sometimes go by the acronym SIPO to remind us of the operations they use: Sequence, Input, Processing and Output. They are just like sequences of calculator commands placed one after another. This week we will put the first four (of six) computational constructs to work to write SIPO programs. These are calculator-style programs that use a sequence ( S ) of instructions to take some data (input or I ), process it ( P ), and display the result (output or O ). I say \"calculator-style\" because the problems are ones people often use calculators for. While the programs themselves are quite short, they will introduce you to the need to keep three separate things in mind as you program: The program code What is going on in the computer's memory What is displayed on the screen One of the first challenges in learning to program is to develop the ability to keep all three things in mind as you develop your program. There are also several points of programming craft that come up for the first, but definitely not the last, time this week, including choosing good variable names, program layout, documentation, and using symbolic constants. And one arithmetic operator that is very useful in a wide variety of programs, but may be new to you: modulo. Assignment 1 was somewhat artificial, because I needed a way to know that you had read the things I'd asked you to, and that you had installed Python, but the remaining assignments are more authentic. They will usually ask you to write around 4 small programs, though our idea of what \"small\" is will grow as the course progresses! The remaining assignments are more homogeneous than the first one. There won't be more short answer questions, cards to sort, or sculptures to describe, just programs to write from here almost to the end of the course. Four programs most weeks. Recall: Programming is... The Problem Do The Problem By Hand Translate the Algorithm into Python Enter, run and test the program Naming Values What will it look like onscreen? Documentation Our second program (Same as the first only backwards) html#translate-to-python) Our third program (dhms2s.py) SIPO Summary Translate into Python Modulo: A Sixth Arithmetic Operator Symbolic Constants Intermission: Summary (so far) Object Types 1: int s and float s Example: Calculating Tree Radius Example: Value of your change Example: Making change Pythonic Details Triple Quoted Strings The Continuation Character The done trick Output Formatting The Pythonic Process Exercise sheet 1 Assignment 2","title":"Introduction: Our first programs \ud83d\udc23"},{"location":"02_SIPO/01_Recall_Programming_is/","text":"Recall: Programming is... In the discussing the big picture of programming I offered you the following, Q : Could you just tell me what a computer program is? A : A list of instructions telling the computer what to do. Q : And programming is writing down those instructions? A : Well you have to think of them first, but yes. To be a little more specific the process of writing a computer program usually involves: Solving the problem by hand to make sure we know how. Consciously identifying our solution method, i.e. algorithm. Translating that algorithm into Python. Entering and running the resulting program, and verifying that it works. These are the steps we will follow throughout this course as we develop programs.","title":"Recall: Programming is..."},{"location":"02_SIPO/01_Recall_Programming_is/#recall-programming-is","text":"In the discussing the big picture of programming I offered you the following, Q : Could you just tell me what a computer program is? A : A list of instructions telling the computer what to do. Q : And programming is writing down those instructions? A : Well you have to think of them first, but yes. To be a little more specific the process of writing a computer program usually involves: Solving the problem by hand to make sure we know how. Consciously identifying our solution method, i.e. algorithm. Translating that algorithm into Python. Entering and running the resulting program, and verifying that it works. These are the steps we will follow throughout this course as we develop programs.","title":"Recall: Programming is..."},{"location":"02_SIPO/02_The_problem/","text":"The Problem We need to convert a temperature measured on the Fahrenheit scale to its equivalent on the Celsius scale. An aside : This is not a realistic programming problem. It would be faster to use a hand held calculator to do this than to write a computer program to do it. But, it would not be practical to use a hand held calculator to convert 20 years worth of daily temperatures stored in a file from Fahrenheit to Celsius, and before we can change a file full of temperatures we need to figure out how to change just one of them. Now we will work through the solution of this problem as follows: Solving the problem by hand to make sure we know how to do it. Consciously identifying our solution method, i.e. the solution algorithm. Translating that algorithm into Python. Entering and running the resulting program and verifying that it works.","title":"The Problem"},{"location":"02_SIPO/02_The_problem/#the-problem","text":"We need to convert a temperature measured on the Fahrenheit scale to its equivalent on the Celsius scale. An aside : This is not a realistic programming problem. It would be faster to use a hand held calculator to do this than to write a computer program to do it. But, it would not be practical to use a hand held calculator to convert 20 years worth of daily temperatures stored in a file from Fahrenheit to Celsius, and before we can change a file full of temperatures we need to figure out how to change just one of them. Now we will work through the solution of this problem as follows: Solving the problem by hand to make sure we know how to do it. Consciously identifying our solution method, i.e. the solution algorithm. Translating that algorithm into Python. Entering and running the resulting program and verifying that it works.","title":"The Problem"},{"location":"02_SIPO/03_Do_the_problem_by_hand/","text":"Do The Problem By Hand We can't instruct the computer to do something unles we know how to do it first. So let's begin by doing a temperature conversion by hand. Here's what I wrote down as I converted 40 degrees Fahrenheit to its Celsius equivalent. Here's what I did step by step: I began by writing down the amount to be converted, 40. Next I subtracted 32 from it. Then I multiplied the difference by 5/9. The result was 4, meaning that 40 degrees Fahrenheit is equivalent to 4 degrees Celsius. The next step is to look at what we did by hand and identify the corresponding computer commands.","title":"Do The Problem By Hand"},{"location":"02_SIPO/03_Do_the_problem_by_hand/#do-the-problem-by-hand","text":"We can't instruct the computer to do something unles we know how to do it first. So let's begin by doing a temperature conversion by hand. Here's what I wrote down as I converted 40 degrees Fahrenheit to its Celsius equivalent. Here's what I did step by step: I began by writing down the amount to be converted, 40. Next I subtracted 32 from it. Then I multiplied the difference by 5/9. The result was 4, meaning that 40 degrees Fahrenheit is equivalent to 4 degrees Celsius. The next step is to look at what we did by hand and identify the corresponding computer commands.","title":"Do The Problem By Hand"},{"location":"02_SIPO/04_Translate_the_algorithm_into_python/","text":"Translate the Algorithm into Python The next step in developing our program is to look at what we did by hand and identify the corresponding computer commands. Here are the numbered steps we identified: I began by writing down the amount to be converted, 40. Next I subtracted 32 from it. Then I multiplied the difference by 5/9. The result was 4, meaning that 40 degrees Fahrenheit is equivalent to 4 degrees Celsius. Now we'll translate these English commands into their Python equivalents. Step 1 above, getting the amount to be converted, is equivalent to the input operation, temp_in_f = int(input()) The next two operations (steps 2 and 3) can be combined into one processing (or assignment) statement as follows, temp_in_c = (temp_in_f - 32) * 5 / 9 Finally the last step (4) is equivalent to an output statement, print(temp_in_c) If we write these three statements down in sequence we have the core of a very small Python program. temp_in_f = int(input()) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_c) To check that this seems reasonable let's mentally trace its step-by-step operation on our functional computer model. The first statement instructs the processor to watch the input channel for a value, store it and label it temp_in_F . As users we place the value into the input stream by typing it on the keyboard and then pressing the Enter key. The second statement has the processor fetch the value named temp_in_F , subtract 32 from it, multiply the result by 5 and divide that result by 9. The final value is stored and labelled temp_in_C . The final statement instructs the processor to fetch the value named temp_in_C and send it to the output stream. This makes it appear on our screen. The final step is to enter, run and test our program.","title":"Translate the Algorithm into Python"},{"location":"02_SIPO/04_Translate_the_algorithm_into_python/#translate-the-algorithm-into-python","text":"The next step in developing our program is to look at what we did by hand and identify the corresponding computer commands. Here are the numbered steps we identified: I began by writing down the amount to be converted, 40. Next I subtracted 32 from it. Then I multiplied the difference by 5/9. The result was 4, meaning that 40 degrees Fahrenheit is equivalent to 4 degrees Celsius. Now we'll translate these English commands into their Python equivalents. Step 1 above, getting the amount to be converted, is equivalent to the input operation, temp_in_f = int(input()) The next two operations (steps 2 and 3) can be combined into one processing (or assignment) statement as follows, temp_in_c = (temp_in_f - 32) * 5 / 9 Finally the last step (4) is equivalent to an output statement, print(temp_in_c) If we write these three statements down in sequence we have the core of a very small Python program. temp_in_f = int(input()) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_c) To check that this seems reasonable let's mentally trace its step-by-step operation on our functional computer model. The first statement instructs the processor to watch the input channel for a value, store it and label it temp_in_F . As users we place the value into the input stream by typing it on the keyboard and then pressing the Enter key. The second statement has the processor fetch the value named temp_in_F , subtract 32 from it, multiply the result by 5 and divide that result by 9. The final value is stored and labelled temp_in_C . The final statement instructs the processor to fetch the value named temp_in_C and send it to the output stream. This makes it appear on our screen. The final step is to enter, run and test our program.","title":"Translate the Algorithm into Python"},{"location":"02_SIPO/05_Enter_run_and_test_the_program/","text":"Enter, run and test the program The last step in writing our program is also the first where we actually use the computer. Within IDLE choose File \u2192 New Window and type in our three statement wonder. temp_in_f = int(input()) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_c) Save the result (File \u2192 Save) into a file called f2c.py . Note how IDLE colourizes the program once it knows the file extension. Press F5 to run your program. This will bring the Python shell window to the front where you will interact with your program. Type 4 0 and then watch what number appears. If it isn't approximately 4 you've got a problem. Step 4 is a test of our program but it isn't sufficient testing to be confident our program will work correctly with all possible values. We should try a couple of other known-correct values to be sure it works correctly. In later programs I'll have much more to say about choosing test values and testing procedures. This is the core of our first Python program, but just the core. Now we have to attend to several other important issues: Naming values What will we see on the screen when we run the program? Documentation","title":"Enter, run and test the program"},{"location":"02_SIPO/05_Enter_run_and_test_the_program/#enter-run-and-test-the-program","text":"The last step in writing our program is also the first where we actually use the computer. Within IDLE choose File \u2192 New Window and type in our three statement wonder. temp_in_f = int(input()) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_c) Save the result (File \u2192 Save) into a file called f2c.py . Note how IDLE colourizes the program once it knows the file extension. Press F5 to run your program. This will bring the Python shell window to the front where you will interact with your program. Type 4 0 and then watch what number appears. If it isn't approximately 4 you've got a problem. Step 4 is a test of our program but it isn't sufficient testing to be confident our program will work correctly with all possible values. We should try a couple of other known-correct values to be sure it works correctly. In later programs I'll have much more to say about choosing test values and testing procedures. This is the core of our first Python program, but just the core. Now we have to attend to several other important issues: Naming values What will we see on the screen when we run the program? Documentation","title":"Enter, run and test the program"},{"location":"02_SIPO/06_Naming_values/","text":"Naming Values What names can you choose for the values you store? The names must begin with a letter, but can be followed by any sequence of letters, numbers, and the underscore character _ . A more important question is what names should you choose for your values? The names you choose should be, descriptive of the values they refer to, to enhance program readability, short, for convenience, all lowercase, to adhere to Python convention. The computer doesn't care what you call them. For example our program would run as well if we changed the variable names to be, x = int(input()) y = (x - 32) * 5 / 9 print(y) or even, fish_guts = int(input()) corn_flakes = (fish_guts - 32) * 5 / 9 print(corn_flakes) I, however, care very much what you call them, as will the other programmers you work with, and even you when you come back to modify your code in six months, or six years. The two versions above are respectively, obscure, and downright misleading, and would be graded accordingly!","title":"Naming Values"},{"location":"02_SIPO/06_Naming_values/#naming-values","text":"What names can you choose for the values you store? The names must begin with a letter, but can be followed by any sequence of letters, numbers, and the underscore character _ . A more important question is what names should you choose for your values? The names you choose should be, descriptive of the values they refer to, to enhance program readability, short, for convenience, all lowercase, to adhere to Python convention. The computer doesn't care what you call them. For example our program would run as well if we changed the variable names to be, x = int(input()) y = (x - 32) * 5 / 9 print(y) or even, fish_guts = int(input()) corn_flakes = (fish_guts - 32) * 5 / 9 print(corn_flakes) I, however, care very much what you call them, as will the other programmers you work with, and even you when you come back to modify your code in six months, or six years. The two versions above are respectively, obscure, and downright misleading, and would be graded accordingly!","title":"Naming Values"},{"location":"02_SIPO/07_What_will_it_look_like_onscreen/","text":"What will it look like onscreen? Our first consideration of user interface and user interaction. As you've seen when you ran the program, the disappointing answer is that not much appears on-screen. When we run the program it will watch the input channel and wait for a value to appear there. Specifically, it will wait for the Enter key on the keyboard to be pressed, and then look in the keyboard buffer to see what keys were pressed before the Enter key. From these keypresses it will attempt to construct an integer value which it will store in temp_in_f . It will not instruct us to type anything; we must just remember to do so. When we do type, we will see the characters we type appear on-screen, and have until we press the Enter key to Backspace over the line making changes. Pressing the Enter key forwards the line we have typed to the processor. If we have typed 40, then after it has calculated the equivalent temperature on the Celsius scale it will display 4 beneath our 40 on the screen. So the screen might look something like this: 40 4.444444444444445 Hardly inspiring, and no casual user would realize they were supposed to type anything, nor, on the off chance they did type a number, would they realize what the output was. (This is a good chance to experience another error message. Press F5 again to run your program and instead of typing a number type the word help and then press the Enter key.) To make our program more useful we need to provide instructions to the user, and explain the output. We do this by inserting extra print statements into the program. For example: print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10) and press Enter.\") temp_in_f = int(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\") Now the screen will look like this: This program converts temperatures from Fahrenheit to Celsius. Enter a temperature in Fahrenheit (e.g. 10) and press Enter. Temperature in Fahrenheit: 40 40 degrees Fahrenheit = 4.444444444444445 degrees Celsius. Still not earth-shattering, but a marked improvement. There are quite a few things to note in this small example: print statements aren't limited to printing values that are in memory, they can also print messages (formally: string literals). To do so just enclose the string of characters you would like to display on-screen in quotes. This means the statements print(\"rate\") and print(rate) do very different things. The first one prints the letters r , a , t , and e on-screen. The second one looks for a value named rate and displays the value (and if it can't find one displays an error message!). Try adding and removing some of the quotes in the sample program above and see what happens. You can combine values and string literals in one print statement, as the last line of the program does, to produce more meaningful output. To do so just separate successive items with commas. The commas are required. An input statement can include a string literal that acts as a prompt to the user, in which case the string will be displayed and_then_the computer will watch for input from the user. This gives you a way to instruct the user. Note that the string must be enclosed in quotes. If your prompt is too long to fit inside the parentheses just put some of it into print statements preceding the input statement. To get a sense of how precision matters in programming try removing the space after the colon (:) in the input prompt and re-running your program. Do you notice how the on-screen appearance is different? You should, and you should prefer it with the space. I've added some blank lines into the program to visually separate the I, P and O blocks of the program to make it easier to see the program's structure. I do this for me and for you; Python could care less. Using string literals judiciously it is possible to create clear input instructions, and clearly (if modestly) formatted output.","title":"What will it look like onscreen?"},{"location":"02_SIPO/07_What_will_it_look_like_onscreen/#what-will-it-look-like-onscreen","text":"Our first consideration of user interface and user interaction. As you've seen when you ran the program, the disappointing answer is that not much appears on-screen. When we run the program it will watch the input channel and wait for a value to appear there. Specifically, it will wait for the Enter key on the keyboard to be pressed, and then look in the keyboard buffer to see what keys were pressed before the Enter key. From these keypresses it will attempt to construct an integer value which it will store in temp_in_f . It will not instruct us to type anything; we must just remember to do so. When we do type, we will see the characters we type appear on-screen, and have until we press the Enter key to Backspace over the line making changes. Pressing the Enter key forwards the line we have typed to the processor. If we have typed 40, then after it has calculated the equivalent temperature on the Celsius scale it will display 4 beneath our 40 on the screen. So the screen might look something like this: 40 4.444444444444445 Hardly inspiring, and no casual user would realize they were supposed to type anything, nor, on the off chance they did type a number, would they realize what the output was. (This is a good chance to experience another error message. Press F5 again to run your program and instead of typing a number type the word help and then press the Enter key.) To make our program more useful we need to provide instructions to the user, and explain the output. We do this by inserting extra print statements into the program. For example: print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10) and press Enter.\") temp_in_f = int(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\") Now the screen will look like this: This program converts temperatures from Fahrenheit to Celsius. Enter a temperature in Fahrenheit (e.g. 10) and press Enter. Temperature in Fahrenheit: 40 40 degrees Fahrenheit = 4.444444444444445 degrees Celsius. Still not earth-shattering, but a marked improvement. There are quite a few things to note in this small example: print statements aren't limited to printing values that are in memory, they can also print messages (formally: string literals). To do so just enclose the string of characters you would like to display on-screen in quotes. This means the statements print(\"rate\") and print(rate) do very different things. The first one prints the letters r , a , t , and e on-screen. The second one looks for a value named rate and displays the value (and if it can't find one displays an error message!). Try adding and removing some of the quotes in the sample program above and see what happens. You can combine values and string literals in one print statement, as the last line of the program does, to produce more meaningful output. To do so just separate successive items with commas. The commas are required. An input statement can include a string literal that acts as a prompt to the user, in which case the string will be displayed and_then_the computer will watch for input from the user. This gives you a way to instruct the user. Note that the string must be enclosed in quotes. If your prompt is too long to fit inside the parentheses just put some of it into print statements preceding the input statement. To get a sense of how precision matters in programming try removing the space after the colon (:) in the input prompt and re-running your program. Do you notice how the on-screen appearance is different? You should, and you should prefer it with the space. I've added some blank lines into the program to visually separate the I, P and O blocks of the program to make it easier to see the program's structure. I do this for me and for you; Python could care less. Using string literals judiciously it is possible to create clear input instructions, and clearly (if modestly) formatted output.","title":"What will it look like onscreen?"},{"location":"02_SIPO/08_Documentation/","text":"Documentation The final step in producing a complete program is to document our program. For a large project documentation includes in-program comments explaining the code, various charts showing the program structure, a user manual, etc. However for now we will constrain ourselves to in-program comments. Two types of comments are usually included: meta-comments, and internal comments. Meta-comments document who created the program, and when and why they did so. Internal comments on the other hand are used to document the internal workings of the program. As a rule of thumb you should comment any statements that you had to puzzle over to figure out, on the assumption that when you reencounter them in six months you will again have to puzzle them out. Both types of comments are produced by the same simple mechanism: the computer ignores any text on a line that follows a hash mark outside of a string literal, i.e. a # . Thus a # at the start of a line instructs the computer to ignore the entire line, and a # part way along a line instructs the computer to ignore the remainder of the line. (Fine print: unless the # is enclosed in a string literal.) Our first program is short and straightforward enough to get by without internal comments (the variable names are descriptive, and the output statements make clear what the program is intended to do). So we will simply add a small banner of meta-information at the top. The result is our first complete Python program. # f2c.py -- converts a temperature in Fahrenheit to its equivalent in Celsius. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10) and press Enter.\") temp_in_f = int(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\")","title":"Documentation"},{"location":"02_SIPO/08_Documentation/#documentation","text":"The final step in producing a complete program is to document our program. For a large project documentation includes in-program comments explaining the code, various charts showing the program structure, a user manual, etc. However for now we will constrain ourselves to in-program comments. Two types of comments are usually included: meta-comments, and internal comments. Meta-comments document who created the program, and when and why they did so. Internal comments on the other hand are used to document the internal workings of the program. As a rule of thumb you should comment any statements that you had to puzzle over to figure out, on the assumption that when you reencounter them in six months you will again have to puzzle them out. Both types of comments are produced by the same simple mechanism: the computer ignores any text on a line that follows a hash mark outside of a string literal, i.e. a # . Thus a # at the start of a line instructs the computer to ignore the entire line, and a # part way along a line instructs the computer to ignore the remainder of the line. (Fine print: unless the # is enclosed in a string literal.) Our first program is short and straightforward enough to get by without internal comments (the variable names are descriptive, and the output statements make clear what the program is intended to do). So we will simply add a small banner of meta-information at the top. The result is our first complete Python program. # f2c.py -- converts a temperature in Fahrenheit to its equivalent in Celsius. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10) and press Enter.\") temp_in_f = int(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\")","title":"Documentation"},{"location":"02_SIPO/09_Our_second_program_Same_as_the_first_only_backwards/","text":"Our second program (Same as the first only backwards) Let's write a program to undo the conversion from Fahrenheit to Celsius we did above. It should convert a temperature measurement in Celsius to one in Fahrenheit. Do it by hand As before we begin by doing it by hand. Suppose I want to convert 11 degrees Celsius to its Fahrenheit equivalent. I would write: Now we need to look at what we have written, and try to view it in terms of the computer operations: input, processing and output operations. The input operations gather the necessary information. In this case the only information necessary is the value to convert, i.e. 11. The processing operations are to take the input value, multiply it by 9/5, and add 32. The output operation is to display the result, i.e. 51. Translate to Python Translating each of those steps into Python gives us: temp_in_c = int(input()) temp_in_f = temp_in_c * 9/5 + 32 print(temp_in_f) This is the computational core of our program, but we need to add documentation and an interface. By interface we mean that we need to provide a way for the user to interact with the program. Specifically we need to give the user some initial instructions, and then some meaningful output. Adding a minimal set of instructions and pulling all the pieces together gives us this program. # c2f.py -- converts a temperature in Celsius to its equivalent in Fahrenheit. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 # Input: print \"This program converts temperatures from Celsius to Fahrenheit.\" print \"Enter a temperature in Celsius (e.g. 10) and press Enter.\" temp_in_c = int(input(\"Enter temperature in Celsius: \")) # Processing: temp_in_f = temp_in_c * 9/5 + 32 # Output: print(temp_in_c, \"degrees Celsius =\", temp_in_f, \"degrees Fahrenheit.\")","title":"Our second program (Same as the first only backwards)"},{"location":"02_SIPO/09_Our_second_program_Same_as_the_first_only_backwards/#our-second-program-same-as-the-first-only-backwards","text":"Let's write a program to undo the conversion from Fahrenheit to Celsius we did above. It should convert a temperature measurement in Celsius to one in Fahrenheit.","title":"Our second program (Same as the first only backwards)"},{"location":"02_SIPO/09_Our_second_program_Same_as_the_first_only_backwards/#do-it-by-hand","text":"As before we begin by doing it by hand. Suppose I want to convert 11 degrees Celsius to its Fahrenheit equivalent. I would write: Now we need to look at what we have written, and try to view it in terms of the computer operations: input, processing and output operations. The input operations gather the necessary information. In this case the only information necessary is the value to convert, i.e. 11. The processing operations are to take the input value, multiply it by 9/5, and add 32. The output operation is to display the result, i.e. 51.","title":"Do it by hand"},{"location":"02_SIPO/09_Our_second_program_Same_as_the_first_only_backwards/#translate-to-python","text":"Translating each of those steps into Python gives us: temp_in_c = int(input()) temp_in_f = temp_in_c * 9/5 + 32 print(temp_in_f) This is the computational core of our program, but we need to add documentation and an interface. By interface we mean that we need to provide a way for the user to interact with the program. Specifically we need to give the user some initial instructions, and then some meaningful output. Adding a minimal set of instructions and pulling all the pieces together gives us this program. # c2f.py -- converts a temperature in Celsius to its equivalent in Fahrenheit. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 # Input: print \"This program converts temperatures from Celsius to Fahrenheit.\" print \"Enter a temperature in Celsius (e.g. 10) and press Enter.\" temp_in_c = int(input(\"Enter temperature in Celsius: \")) # Processing: temp_in_f = temp_in_c * 9/5 + 32 # Output: print(temp_in_c, \"degrees Celsius =\", temp_in_f, \"degrees Fahrenheit.\")","title":"Translate to Python"},{"location":"02_SIPO/10_Our_third_program_dhms2s.py/","text":"Our third program (dhms2s.py) We'll finish by writing another program; one that takes several input values instead of just one. The problem is to convert a time given in days, hours, minutes, and seconds to the equivalent number of seconds. For example 1 day, 8 hours, 23 minutes and 11 seconds is (doing it by hand), (1 \u00d7 24 \u00d7 60 \u00d7 60) + (8 \u00d7 60 \u00d7 60) + (23 \u00d7 60) + 11 = 116,591 seconds The calculation is based on the fact that each day has 24 hours, each hour has 60 minutes, and each minute has 60 seconds. The input is the number of days, hours, minutes, and seconds. The processing is the calculation above. And the output is the equivalent number of seconds. The core (I say core because I am leaving out the documentation and some interactive elements so you can better focus on what matters) of a Python program to do this calculation might look like this, print(\"Enter your values now,\") days = int(input(\"Enter days: \")) hours = int(input(\"Enter hours: \")) minutes = int(input(\"Enter minutes: \")) seconds = int(input(\"Enter seconds: \")) tot_seconds = days*24*60*60 + hours*60*60 + minutes*60 + seconds print(\"Total seconds is\", tot_seconds) It seems to work but there is one improvement that can be made. The small improvement is that we can rewrite the processing statement so it does fewer calculations. As it stands the statement, tot_seconds = days*24*60*60 + hours*60*60 + minutes*60 + seconds; does 3 additions and 6 multiplications. If we factor the expression and rewrite it as, tot_seconds = ((days*24 + hours)*60 + minutes)*60 + seconds; we reduce the count of multiplications from 6 to 3: a significant 50% reduction.","title":"Our third program (dhms2s.py)"},{"location":"02_SIPO/10_Our_third_program_dhms2s.py/#our-third-program-dhms2spy","text":"We'll finish by writing another program; one that takes several input values instead of just one. The problem is to convert a time given in days, hours, minutes, and seconds to the equivalent number of seconds. For example 1 day, 8 hours, 23 minutes and 11 seconds is (doing it by hand), (1 \u00d7 24 \u00d7 60 \u00d7 60) + (8 \u00d7 60 \u00d7 60) + (23 \u00d7 60) + 11 = 116,591 seconds The calculation is based on the fact that each day has 24 hours, each hour has 60 minutes, and each minute has 60 seconds. The input is the number of days, hours, minutes, and seconds. The processing is the calculation above. And the output is the equivalent number of seconds. The core (I say core because I am leaving out the documentation and some interactive elements so you can better focus on what matters) of a Python program to do this calculation might look like this, print(\"Enter your values now,\") days = int(input(\"Enter days: \")) hours = int(input(\"Enter hours: \")) minutes = int(input(\"Enter minutes: \")) seconds = int(input(\"Enter seconds: \")) tot_seconds = days*24*60*60 + hours*60*60 + minutes*60 + seconds print(\"Total seconds is\", tot_seconds) It seems to work but there is one improvement that can be made. The small improvement is that we can rewrite the processing statement so it does fewer calculations. As it stands the statement, tot_seconds = days*24*60*60 + hours*60*60 + minutes*60 + seconds; does 3 additions and 6 multiplications. If we factor the expression and rewrite it as, tot_seconds = ((days*24 + hours)*60 + minutes)*60 + seconds; we reduce the count of multiplications from 6 to 3: a significant 50% reduction.","title":"Our third program (dhms2s.py)"},{"location":"02_SIPO/11_SIPO_summary/","text":"SIPO Summary Using input, processing (via assignment), and output statements we can write sequential or SIPO programs. These programs have a standard structure containing three parts: A block of statements to get the necessary input values from the user, A block of statements to process these values (typically to calculate new values based on them), And a block of statements to output the calculated values. The number of statements in each block will vary, as will the particular processing operations, but those three fundamental parts will always be present. This program structure can be represented using a flowchart as follows:","title":"SIPO Summary"},{"location":"02_SIPO/11_SIPO_summary/#sipo-summary","text":"Using input, processing (via assignment), and output statements we can write sequential or SIPO programs. These programs have a standard structure containing three parts: A block of statements to get the necessary input values from the user, A block of statements to process these values (typically to calculate new values based on them), And a block of statements to output the calculated values. The number of statements in each block will vary, as will the particular processing operations, but those three fundamental parts will always be present. This program structure can be represented using a flowchart as follows:","title":"SIPO Summary"},{"location":"02_SIPO/12_Packaging_quantities/","text":"Packaging Quantities The problem We want to write a program that does the opposite of our last program, i.e. instead of taking a time in days, hours, minutes and seconds and calculating the equivalent number of seconds, we want to take a large number of seconds and find the equivalent number of days, hours, minutes, and seconds. For example, we would like to divide 200,000 seconds into the equivalent number of days, hours, minutes, and seconds. Packaging Quantities: Do it by hand Our first step is to figure out how many days worth of seconds this is. So we divide 200,000 by (24*60*60) : days = 200,000 / (24 * 60 * 60) = 2 Note that the result is two because we do an integer (not \"decimal\") division; what we want to know is how many whole days worth of seconds will go into 200,000. Now we calculate how many seconds are left over after taking out two days worth of seconds. remainder = 200,000 - 2 * (24 * 60 * 60) = 27,200 Next we want to calculate how many hours worth of seconds this is. We do this similarly to the days calculation above. hours = 27,200 / (60 * 60) = 7 And find the remainder, remainder = 27,200 - 7 * (60 * 60) = 2,000 Finally we calculate the number of minutes, minutes = 2,000 / 60 = 33 and the remainder of that is the leftover seconds, seconds = 2,000 - 33 * 60 = 20 So 200,000 seconds is equivalent to 2 days, 7 hours, 33 minutes and 20 seconds. In terms of input, processing and output: the input is the number of seconds (200,000), the processing consists of several steps to find the number of days, hours, minutes and seconds, including intermediate steps to find the remainders along the way, and the output is the number of days, hours, minutes and seconds. Translate into Python A literal translation of our manual steps, days = 200,000 / (24*60*60) = 2 remainder = 200,000 - 2*(24*60*60) = 27,200 hours = 27,200 / (60*60) = 7 remainder = 27,200 - 7*(60*60) = 2,000 minutes = 2,000 / 60 = 33 seconds = 2,000 - 33*60 = 20 into Python might look like this (we used the // symbol to tell python to use integer division): tot_seconds = int(input(\"Enter the number of seconds: \")) days = tot_seconds // (24*60*60) remainder = tot_seconds - days * (24*60*60) hours = remainder // (60*60) remainder = remainder - hours * (60*60) minutes = remainder // 60 remainder = remainder - minutes*60 print(tot_seconds, \"seconds is\", days, \"days,\") print(hours, \"hours,\", minutes, \"minutes and\") print(remainder, \" seconds.\") Notes: This is just the core of the program and the instructions are minimal, for now ... Note that the final value output is remainder , do you understand why? As written (with the addition of \u2014 you already know this right? \u2014 interface and documentation) this program would run and calculate the answer correctly, but a couple of improvements are possible.","title":"Packaging Quantities"},{"location":"02_SIPO/12_Packaging_quantities/#packaging-quantities","text":"","title":"Packaging Quantities"},{"location":"02_SIPO/12_Packaging_quantities/#the-problem","text":"We want to write a program that does the opposite of our last program, i.e. instead of taking a time in days, hours, minutes and seconds and calculating the equivalent number of seconds, we want to take a large number of seconds and find the equivalent number of days, hours, minutes, and seconds. For example, we would like to divide 200,000 seconds into the equivalent number of days, hours, minutes, and seconds.","title":"The problem"},{"location":"02_SIPO/12_Packaging_quantities/#packaging-quantities-do-it-by-hand","text":"Our first step is to figure out how many days worth of seconds this is. So we divide 200,000 by (24*60*60) : days = 200,000 / (24 * 60 * 60) = 2 Note that the result is two because we do an integer (not \"decimal\") division; what we want to know is how many whole days worth of seconds will go into 200,000. Now we calculate how many seconds are left over after taking out two days worth of seconds. remainder = 200,000 - 2 * (24 * 60 * 60) = 27,200 Next we want to calculate how many hours worth of seconds this is. We do this similarly to the days calculation above. hours = 27,200 / (60 * 60) = 7 And find the remainder, remainder = 27,200 - 7 * (60 * 60) = 2,000 Finally we calculate the number of minutes, minutes = 2,000 / 60 = 33 and the remainder of that is the leftover seconds, seconds = 2,000 - 33 * 60 = 20 So 200,000 seconds is equivalent to 2 days, 7 hours, 33 minutes and 20 seconds. In terms of input, processing and output: the input is the number of seconds (200,000), the processing consists of several steps to find the number of days, hours, minutes and seconds, including intermediate steps to find the remainders along the way, and the output is the number of days, hours, minutes and seconds.","title":"Packaging Quantities: Do it by hand"},{"location":"02_SIPO/12_Packaging_quantities/#translate-into-python","text":"A literal translation of our manual steps, days = 200,000 / (24*60*60) = 2 remainder = 200,000 - 2*(24*60*60) = 27,200 hours = 27,200 / (60*60) = 7 remainder = 27,200 - 7*(60*60) = 2,000 minutes = 2,000 / 60 = 33 seconds = 2,000 - 33*60 = 20 into Python might look like this (we used the // symbol to tell python to use integer division): tot_seconds = int(input(\"Enter the number of seconds: \")) days = tot_seconds // (24*60*60) remainder = tot_seconds - days * (24*60*60) hours = remainder // (60*60) remainder = remainder - hours * (60*60) minutes = remainder // 60 remainder = remainder - minutes*60 print(tot_seconds, \"seconds is\", days, \"days,\") print(hours, \"hours,\", minutes, \"minutes and\") print(remainder, \" seconds.\") Notes: This is just the core of the program and the instructions are minimal, for now ... Note that the final value output is remainder , do you understand why? As written (with the addition of \u2014 you already know this right? \u2014 interface and documentation) this program would run and calculate the answer correctly, but a couple of improvements are possible.","title":"Translate into Python"},{"location":"02_SIPO/13_Modulo_A_sixth_arithmetic_operator/","text":"Modulo: A Sixth Arithmetic Operator The first improvement we can make to our program is to take advantage of an operator Python (and most programming languges) provides to calculate remainders. Everyday arithmetic gets by with addition, +, subtraction, -, multiplication, *, division /, and integer division // but remainders occur in a host of common algorithms so programming languages provide a fifth arithmetic operator in addition to the common four. The fifth operation is named modulo and is denoted in Python by the symbol % . It returns the remainder of a division. For example 17 // 5 is 3 because 5 goes into 17 three times, but what if we need to know how much was \"left over\"? We use the modulo operator like this: 17 % 5 to get 2, the remainder when 17 is divided by 5. We wrote instructions of our own to calculate the remainder above but using modulo will be more compact, i.e. make our program shorter, and may well be more efficient (because the language writers will have implemented it as efficiently as possible), and will at any rate not be less efficient. Using modulo we can rewrite the processing portion of our program like this: days = tot_seconds // (24*60*60) remainder = tot_seconds % (24*60*60) hours = remainder // (60*60) remainder = remainder % (60*60) minutes = remainder // 60 remainder = remainder % 60 Summary The remainder of a division can be found using the modulo operator % . This operation is useful for packaging a large quantity into smaller packages, e.g. a large number of seconds into packages of days, hours, minutes and seconds. This sort of packaging turns out to be a common operation in many kinds of problems.","title":"Modulo: A Sixth Arithmetic Operator"},{"location":"02_SIPO/13_Modulo_A_sixth_arithmetic_operator/#modulo-a-sixth-arithmetic-operator","text":"The first improvement we can make to our program is to take advantage of an operator Python (and most programming languges) provides to calculate remainders. Everyday arithmetic gets by with addition, +, subtraction, -, multiplication, *, division /, and integer division // but remainders occur in a host of common algorithms so programming languages provide a fifth arithmetic operator in addition to the common four. The fifth operation is named modulo and is denoted in Python by the symbol % . It returns the remainder of a division. For example 17 // 5 is 3 because 5 goes into 17 three times, but what if we need to know how much was \"left over\"? We use the modulo operator like this: 17 % 5 to get 2, the remainder when 17 is divided by 5. We wrote instructions of our own to calculate the remainder above but using modulo will be more compact, i.e. make our program shorter, and may well be more efficient (because the language writers will have implemented it as efficiently as possible), and will at any rate not be less efficient. Using modulo we can rewrite the processing portion of our program like this: days = tot_seconds // (24*60*60) remainder = tot_seconds % (24*60*60) hours = remainder // (60*60) remainder = remainder % (60*60) minutes = remainder // 60 remainder = remainder % 60","title":"Modulo: A Sixth Arithmetic Operator"},{"location":"02_SIPO/13_Modulo_A_sixth_arithmetic_operator/#summary","text":"The remainder of a division can be found using the modulo operator % . This operation is useful for packaging a large quantity into smaller packages, e.g. a large number of seconds into packages of days, hours, minutes and seconds. This sort of packaging turns out to be a common operation in many kinds of problems.","title":"Summary"},{"location":"02_SIPO/14_Symbolic_constants/","text":"Symbolic Constants A second improvement is possible. Looking at our program we see that several calculations are performed more than once, i.e. (24 * 60 * 60) and (60 * 60). There should be a way to avoid the unnecessary recalculation, and there is. All we have to do is to calculate the quantities and store them so we can reuse the pre-calculated quantity. We could store them in a variable, but the quantity shouldn't change, so it would be wise to prevent it from changing if we can. A second small concern is that it may not be clear to a someone reading our program (say someone maintaining it, or even ourselves rereading it a few months later) what the quantity 60 * 60 is. Python has a convention we will adhere to to help deal with these issues. We will calculate our reused values once near the top of the program and give them names in all caps to indicate that these values are intended to remain unchanged. SECS_PER_DAY = 24 * 60 * 60 SECS_PER_HOUR = 60 * 60 SECS_PER_MINUTE = 60 days = tot_seconds // SECS_PER_DAY remainder = tot_seconds % SECS_PER_DAY hours = remainder // SECS_PER_HOUR remainder = remainder % SECS_PER_HOUR minutes = remainder // SECS_PER_MIN remainder = remainder % SECS_PER_MIN Notes: By convention constants are given capitalized names. This makes them stand out, and serves as a cue for people reading the program to the fixed nature of the quantity. These quantities are called symbolic constants, because we get to label them symbolically, i.e. we get to name them. The advantage of naming them is increased readability. Readers may not know what (24 * 60 * 60) is but SECS_PER_DAY will be meaningful to most. Putting all these changes together and adding the declarations, overhead, and some instructions gives us the following complete program. # s2dhms.py -- converts a time in seconds to # its equivalent in days, hours, minutes and seconds. # # CPSC 128 Demonstration Program # # Kate Chatfield-Reed, Winter 2023 SECS_PER_DAY = 24 * 60 * 60 SECS_PER_HOUR = 60 * 60 SECS_PER_MINUTE = 60 # Input. print(\"=====================================================\") print(\" Seconds to Days, Hours, Minutes and Seconds\") print(\"-----------------------------------------------------\") print() print(\"This program converts a number of seconds to its\") print(\"equivalent in days, hours, minutes and seconds.\") tot_seconds = int(input(\"Enter the number of seconds now (e.g. 116529): \")) print() # Processing. days = tot_seconds // SECS_PER_DAY remainder = tot_seconds % SECS_PER_DAY hours = remainder // SECS_PER_HOUR remainder = remainder % SECS_PER_HOUR minutes = remainder // SECS_PER_MINUTE remainder = remainder % SECS_PER_MINUTE # Output. print(tot_seconds, \"seconds =\", days, \"days,\", hours, \"hours,\",end=' ') print(minutes, \"minutes and\", remainder, \"seconds\") Notes: Note the effect of including end = ' ' in the second last line. Try removing it and the comma and see how the output changes. How would you describe what it does? Note the empty print() statements, i.e. print() statements with no items in the brackets. These are used to output blank lines. Summary Symbolic constants can be used to avoid repeating calculations unnecessarily and to increase readability. They are identified by being given names in ALLCAPS.","title":"Symbolic Constants"},{"location":"02_SIPO/14_Symbolic_constants/#symbolic-constants","text":"A second improvement is possible. Looking at our program we see that several calculations are performed more than once, i.e. (24 * 60 * 60) and (60 * 60). There should be a way to avoid the unnecessary recalculation, and there is. All we have to do is to calculate the quantities and store them so we can reuse the pre-calculated quantity. We could store them in a variable, but the quantity shouldn't change, so it would be wise to prevent it from changing if we can. A second small concern is that it may not be clear to a someone reading our program (say someone maintaining it, or even ourselves rereading it a few months later) what the quantity 60 * 60 is. Python has a convention we will adhere to to help deal with these issues. We will calculate our reused values once near the top of the program and give them names in all caps to indicate that these values are intended to remain unchanged. SECS_PER_DAY = 24 * 60 * 60 SECS_PER_HOUR = 60 * 60 SECS_PER_MINUTE = 60 days = tot_seconds // SECS_PER_DAY remainder = tot_seconds % SECS_PER_DAY hours = remainder // SECS_PER_HOUR remainder = remainder % SECS_PER_HOUR minutes = remainder // SECS_PER_MIN remainder = remainder % SECS_PER_MIN Notes: By convention constants are given capitalized names. This makes them stand out, and serves as a cue for people reading the program to the fixed nature of the quantity. These quantities are called symbolic constants, because we get to label them symbolically, i.e. we get to name them. The advantage of naming them is increased readability. Readers may not know what (24 * 60 * 60) is but SECS_PER_DAY will be meaningful to most. Putting all these changes together and adding the declarations, overhead, and some instructions gives us the following complete program. # s2dhms.py -- converts a time in seconds to # its equivalent in days, hours, minutes and seconds. # # CPSC 128 Demonstration Program # # Kate Chatfield-Reed, Winter 2023 SECS_PER_DAY = 24 * 60 * 60 SECS_PER_HOUR = 60 * 60 SECS_PER_MINUTE = 60 # Input. print(\"=====================================================\") print(\" Seconds to Days, Hours, Minutes and Seconds\") print(\"-----------------------------------------------------\") print() print(\"This program converts a number of seconds to its\") print(\"equivalent in days, hours, minutes and seconds.\") tot_seconds = int(input(\"Enter the number of seconds now (e.g. 116529): \")) print() # Processing. days = tot_seconds // SECS_PER_DAY remainder = tot_seconds % SECS_PER_DAY hours = remainder // SECS_PER_HOUR remainder = remainder % SECS_PER_HOUR minutes = remainder // SECS_PER_MINUTE remainder = remainder % SECS_PER_MINUTE # Output. print(tot_seconds, \"seconds =\", days, \"days,\", hours, \"hours,\",end=' ') print(minutes, \"minutes and\", remainder, \"seconds\") Notes: Note the effect of including end = ' ' in the second last line. Try removing it and the comma and see how the output changes. How would you describe what it does? Note the empty print() statements, i.e. print() statements with no items in the brackets. These are used to output blank lines.","title":"Symbolic Constants"},{"location":"02_SIPO/14_Symbolic_constants/#summary","text":"Symbolic constants can be used to avoid repeating calculations unnecessarily and to increase readability. They are identified by being given names in ALLCAPS.","title":"Summary"},{"location":"02_SIPO/15_Intermission_Summary_so_far/","text":"Intermission: Summary (so far) We write programs to solve problems by, Doing a sample problem by hand (so we're sure we know how to solve it). Reflecting on our manual solution to identify the algorithm we are using. Translating our algorithm into Python. Entering, running and testing our program. Variable names should be, Meaningful. Short. All lowercase. Understand the difference between print(\"rate\") and print(rate) . A complete program includes, Documentation (at least file name, author, project). Sufficient interface elements to make it usable by someone other the programmer. A program isn't finished when it runs without errors; it's finished when you've confirmed the results are correct.","title":"Intermission: Summary (so far)"},{"location":"02_SIPO/15_Intermission_Summary_so_far/#intermission-summary-so-far","text":"We write programs to solve problems by, Doing a sample problem by hand (so we're sure we know how to solve it). Reflecting on our manual solution to identify the algorithm we are using. Translating our algorithm into Python. Entering, running and testing our program. Variable names should be, Meaningful. Short. All lowercase. Understand the difference between print(\"rate\") and print(rate) . A complete program includes, Documentation (at least file name, author, project). Sufficient interface elements to make it usable by someone other the programmer. A program isn't finished when it runs without errors; it's finished when you've confirmed the results are correct.","title":"Intermission: Summary (so far)"},{"location":"02_SIPO/16_Object_types_1_ints_and_floats/","text":"Object Types 1: ints and floats In which we consider the types of objects for the first, but definitely not the last, time. 5 is not the same as 5.0 Python version 3 automatically converts ints to floats if needed. However, in some cases it is still important to know the difference. The Issue Recall our program to convert from Farenheit to Celsius: # f2c.py -- converts a temperature in Fahrenheit to its equivalent in Celsius. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 # print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10) and press Enter.\") temp_in_f = int(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\" In this example I assumed that the input would be an integer (or round number). If you enter the input 2.2, it will give an error because I told the computer to expect only an integer. # f2c.py -- converts a temperature in Fahrenheit to its equivalent in Celsius. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 # print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10.0) and press Enter.\") temp_in_f = float(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\") Try running this version of the program and see how the output changes. Is it what you wanted? If not stay tuned for an update coming soon to a module near you. The change let the computer know that you could enter any number. It should work if you enter 5, 5.0, or 2.5 as your starting number. Make sure that you pick the number type that is needed for each situation. The key thing to realize here is that 5 and 5.0 are not the same thing. Type conversions You can convert an object of any type to an integer using the class name of integers, int, as a function, e.g. int(4.3) . It didn't work in the program above because we were converting a string to a number. Similarly you can convert an object to a floating point number using the class name float as a function, e.g. float(4) . Using a class name in this way invokes the class' constructor, a function that tries to build an object of the specified type. One common occasion where the two types are combined is in finding the average of a set of real numbers. Here the sum will be a floating point value, but the count of the number of values is best represented by an integer. When we divide the sum by the count, we are combining a floating point value with an integer. int or float ? In many problems either int s or float s can be used depending on the type of output required. When it is not clear which choice is best the following insight and guidelines may be helpful. The insight is that most numbers arise as the result of either measurements (the length, duration, weight ... of something), or counts (the number of students, cars, bacteria, problems, ...). The resulting guidelines are to: Prefer floating point values for measurements. Use integers for counts. Note that the second guideline is stricter than the first.","title":"Object Types 1: ints and floats"},{"location":"02_SIPO/16_Object_types_1_ints_and_floats/#object-types-1-ints-and-floats","text":"In which we consider the types of objects for the first, but definitely not the last, time.","title":"Object Types 1: ints and floats"},{"location":"02_SIPO/16_Object_types_1_ints_and_floats/#5-is-not-the-same-as-50","text":"Python version 3 automatically converts ints to floats if needed. However, in some cases it is still important to know the difference.","title":"5 is not the same as 5.0"},{"location":"02_SIPO/16_Object_types_1_ints_and_floats/#the-issue","text":"Recall our program to convert from Farenheit to Celsius: # f2c.py -- converts a temperature in Fahrenheit to its equivalent in Celsius. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 # print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10) and press Enter.\") temp_in_f = int(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\" In this example I assumed that the input would be an integer (or round number). If you enter the input 2.2, it will give an error because I told the computer to expect only an integer. # f2c.py -- converts a temperature in Fahrenheit to its equivalent in Celsius. # CPSC 128 Example program # Kate Chatfield-Reed, Winter 2023 # print(\"This program converts temperatures from Fahrenheit to Celsius.\") print(\"Enter a temperature in Fahrenheit (e.g. 10.0) and press Enter.\") temp_in_f = float(input(\"Temperature in Fahrenheit: \")) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \"degrees Fahrenheit =\", temp_in_c, \"degrees Celsius.\") Try running this version of the program and see how the output changes. Is it what you wanted? If not stay tuned for an update coming soon to a module near you. The change let the computer know that you could enter any number. It should work if you enter 5, 5.0, or 2.5 as your starting number. Make sure that you pick the number type that is needed for each situation. The key thing to realize here is that 5 and 5.0 are not the same thing.","title":"The Issue"},{"location":"02_SIPO/16_Object_types_1_ints_and_floats/#type-conversions","text":"You can convert an object of any type to an integer using the class name of integers, int, as a function, e.g. int(4.3) . It didn't work in the program above because we were converting a string to a number. Similarly you can convert an object to a floating point number using the class name float as a function, e.g. float(4) . Using a class name in this way invokes the class' constructor, a function that tries to build an object of the specified type. One common occasion where the two types are combined is in finding the average of a set of real numbers. Here the sum will be a floating point value, but the count of the number of values is best represented by an integer. When we divide the sum by the count, we are combining a floating point value with an integer.","title":"Type conversions"},{"location":"02_SIPO/16_Object_types_1_ints_and_floats/#int-or-float","text":"In many problems either int s or float s can be used depending on the type of output required. When it is not clear which choice is best the following insight and guidelines may be helpful. The insight is that most numbers arise as the result of either measurements (the length, duration, weight ... of something), or counts (the number of students, cars, bacteria, problems, ...). The resulting guidelines are to: Prefer floating point values for measurements. Use integers for counts. Note that the second guideline is stricter than the first.","title":"int\u00a0or\u00a0float?"},{"location":"02_SIPO/17_Example_Calculating_tree_diameter/","text":"Example: Calculating Tree Diameter Problem: Scott used a tape measure to measure the circumferences of all the trees in a regeneration plot, but the database wants him to enter diameters instead of circumferences. Assuming the trees are roughly circular in cross-section we can calculate the diameter from the circumference, because the diameter is twice the radius and the radius is the circumference divided by 2\u03c0. Write a program that will let him enter the circumference and will print the corresponding diameter. A sample run might look like: Enter the circumference of the tree in centimetres: 238 The tree's diameter is approximately: 75.76 centimetres. Solution:","title":"Example: Calculating Tree Diameter"},{"location":"02_SIPO/17_Example_Calculating_tree_diameter/#example-calculating-tree-diameter","text":"","title":"Example: Calculating Tree Diameter"},{"location":"02_SIPO/17_Example_Calculating_tree_diameter/#problem","text":"Scott used a tape measure to measure the circumferences of all the trees in a regeneration plot, but the database wants him to enter diameters instead of circumferences. Assuming the trees are roughly circular in cross-section we can calculate the diameter from the circumference, because the diameter is twice the radius and the radius is the circumference divided by 2\u03c0. Write a program that will let him enter the circumference and will print the corresponding diameter. A sample run might look like: Enter the circumference of the tree in centimetres: 238 The tree's diameter is approximately: 75.76 centimetres.","title":"Problem:"},{"location":"02_SIPO/17_Example_Calculating_tree_diameter/#solution","text":"","title":"Solution:"},{"location":"02_SIPO/18_Example_Value_of_your_change/","text":"Example: Value of your change Problem: Write a program that will let the user enter the change they have in their pocket and will tell them its total value. A sample run might look like: Tell me about the change in your pocket and I'll add it up for you. How many of each type of coin do you have? Toonies: 1 Loonies: 0 Quarters: 3 Dimes: 2 Nickels: 0 The change in your pocket is worth $2.95. Don't blow it all in one place! Solution:","title":"Example: Value of your change"},{"location":"02_SIPO/18_Example_Value_of_your_change/#example-value-of-your-change","text":"","title":"Example: Value of your change"},{"location":"02_SIPO/18_Example_Value_of_your_change/#problem","text":"Write a program that will let the user enter the change they have in their pocket and will tell them its total value. A sample run might look like: Tell me about the change in your pocket and I'll add it up for you. How many of each type of coin do you have? Toonies: 1 Loonies: 0 Quarters: 3 Dimes: 2 Nickels: 0 The change in your pocket is worth $2.95. Don't blow it all in one place!","title":"Problem:"},{"location":"02_SIPO/18_Example_Value_of_your_change/#solution","text":"","title":"Solution:"},{"location":"02_SIPO/19_Example_Making_change/","text":"Example: Making change Problem: Write a program that makes change, i.e. given a number of cents of change to make it will say what coins to use (using as few coins as possible). This was the first lab I ever did as a computer science student (it was slightly less complicated because we could use pennies)! A sample run might look like: How much change do you have to make (in cents)? 197 195 cents can be made using: 0 toonies 1 loonies 3 quarters 2 dimes 0 nickels Solution:","title":"Example: Making change"},{"location":"02_SIPO/19_Example_Making_change/#example-making-change","text":"","title":"Example: Making change"},{"location":"02_SIPO/19_Example_Making_change/#problem","text":"Write a program that makes change, i.e. given a number of cents of change to make it will say what coins to use (using as few coins as possible). This was the first lab I ever did as a computer science student (it was slightly less complicated because we could use pennies)! A sample run might look like: How much change do you have to make (in cents)? 197 195 cents can be made using: 0 toonies 1 loonies 3 quarters 2 dimes 0 nickels","title":"Problem:"},{"location":"02_SIPO/19_Example_Making_change/#solution","text":"","title":"Solution:"},{"location":"02_SIPO/20_Pythonic_details/","text":"Pythonic Details The careful reader will notice some oddities in the example programs: syntactic details not mentioned in the notes so far. The next pages explain these in turn: triple quoted strings the continuation character \\ the line done = input('Press Enter to exit...') print formating using f-strings","title":"Pythonic Details"},{"location":"02_SIPO/20_Pythonic_details/#pythonic-details","text":"The careful reader will notice some oddities in the example programs: syntactic details not mentioned in the notes so far. The next pages explain these in turn: triple quoted strings the continuation character \\ the line done = input('Press Enter to exit...') print formating using f-strings","title":"Pythonic Details"},{"location":"02_SIPO/21_Triple_quoted_strings/","text":"Triple Quoted Strings Outputting long stretches of text using mulitple print statements is awkward. To make it easier Python allows you to specify multi-line output fragments using triple quotes, either single(') or double (\"). So instead of, print('This program converts a measurement of a tree's circumference into') print('an estimate of its diameter (assuming the tree to be circular in') print('cross-section).') print() we can write, print(\"\"\"This program converts a measurement of a tree's circumference into an estimate of its diameter (assuming the tree to be circular in cross-section). \"\"\") or print('''This program converts a measurement of a tree's circumference into an estimate of its diameter (assuming the tree to be circular in cross-section). ''') Later we will see that we can use string interpolation to use large swaths of triple quoted strings as templates into which we insert variable values to output e.g. entire web pages dynamically.","title":"Triple Quoted Strings"},{"location":"02_SIPO/21_Triple_quoted_strings/#triple-quoted-strings","text":"Outputting long stretches of text using mulitple print statements is awkward. To make it easier Python allows you to specify multi-line output fragments using triple quotes, either single(') or double (\"). So instead of, print('This program converts a measurement of a tree's circumference into') print('an estimate of its diameter (assuming the tree to be circular in') print('cross-section).') print() we can write, print(\"\"\"This program converts a measurement of a tree's circumference into an estimate of its diameter (assuming the tree to be circular in cross-section). \"\"\") or print('''This program converts a measurement of a tree's circumference into an estimate of its diameter (assuming the tree to be circular in cross-section). ''') Later we will see that we can use string interpolation to use large swaths of triple quoted strings as templates into which we insert variable values to output e.g. entire web pages dynamically.","title":"Triple Quoted Strings"},{"location":"02_SIPO/22_The_continuation_character/","text":"The Continuation Character The lines in your Python programs should normally be kept \"short\" where short means less than 80 characters long. This is usually straightforward, but sometimes long expressions can be difficult to format clearly and still fit on one line. In this case you can place a continuation character at the end of the line to indicate to the Python interpreter that it continues on the next line. Python uses the backslash as its continuation character, e.g. total = toonies * 2.0 + loonies*1.0 + quarters*0.25 + dimes*0.10 \\ + nickels*0.05 + pennies*0.01","title":"The Continuation Character"},{"location":"02_SIPO/22_The_continuation_character/#the-continuation-character","text":"The lines in your Python programs should normally be kept \"short\" where short means less than 80 characters long. This is usually straightforward, but sometimes long expressions can be difficult to format clearly and still fit on one line. In this case you can place a continuation character at the end of the line to indicate to the Python interpreter that it continues on the next line. Python uses the backslash as its continuation character, e.g. total = toonies * 2.0 + loonies*1.0 + quarters*0.25 + dimes*0.10 \\ + nickels*0.05 + pennies*0.01","title":"The Continuation Character"},{"location":"02_SIPO/23_The_done_trick/","text":"The done trick If you run your Python program by double-clicking its program icon then after it displays its output it immediately closes the terminal window, probably before you could actually see what the output was. One way to prevent this rapid closure is to add a statement like this one at the end of your program, done = input(\"Press Enter to exit.\") This works because it instructs the computer to await input from the user, so the program freezes (halts execution) while it waits.","title":"The\u00a0done\u00a0trick"},{"location":"02_SIPO/23_The_done_trick/#the-done-trick","text":"If you run your Python program by double-clicking its program icon then after it displays its output it immediately closes the terminal window, probably before you could actually see what the output was. One way to prevent this rapid closure is to add a statement like this one at the end of your program, done = input(\"Press Enter to exit.\") This works because it instructs the computer to await input from the user, so the program freezes (halts execution) while it waits.","title":"The\u00a0done\u00a0trick"},{"location":"02_SIPO/24_Output_formatting/","text":"Output Formatting To get output like this, instead of this, Build a print statement with the string, [Below is the output of each print statement.]{style=\"font-size: 0.9375rem;\"}\\ The formatting codes used in the second print statement are derived from those originally used by the language C and now also used by the languages C++, AWK, Perl, and PHP among others. Each format placeholder has the form, %[optional arguments]letter The % sign indicates the beginning of a placeholder. Although all of these options are valid in Python 3 we will be using option 4, the f-string, because that is currently considered best practice. I also think it the easist to read! The letter indicates the desired format: Letter Format d decimal integer o unsigned octal integer x unsigned hexadecimal integer f floating point s string All these take an optional argument specifying the width of the field in which the value should be displayed, e.g. The floating point code takes an additional argument specifying the number of digits to display to the right of the decimal point, e.g. Note that if a field width is narrower than the value to be displayed the field is enlarged to fit the value, e.g. this can be helpful when you want to insert numerical values into sentences (rather than some tabular format), e.g. If you need to display multiple values enclose the interpolating variables in parentheses, e.g. There is much more to string formatting than is shown here. For the details start with the Python Library Reference Section 7 . More details can be found in the Gnu AWK manual Section 5.2","title":"Output Formatting"},{"location":"02_SIPO/24_Output_formatting/#output-formatting","text":"To get output like this, instead of this, Build a print statement with the string, [Below is the output of each print statement.]{style=\"font-size: 0.9375rem;\"}\\ The formatting codes used in the second print statement are derived from those originally used by the language C and now also used by the languages C++, AWK, Perl, and PHP among others. Each format placeholder has the form, %[optional arguments]letter The % sign indicates the beginning of a placeholder. Although all of these options are valid in Python 3 we will be using option 4, the f-string, because that is currently considered best practice. I also think it the easist to read! The letter indicates the desired format: Letter Format d decimal integer o unsigned octal integer x unsigned hexadecimal integer f floating point s string All these take an optional argument specifying the width of the field in which the value should be displayed, e.g. The floating point code takes an additional argument specifying the number of digits to display to the right of the decimal point, e.g. Note that if a field width is narrower than the value to be displayed the field is enlarged to fit the value, e.g. this can be helpful when you want to insert numerical values into sentences (rather than some tabular format), e.g. If you need to display multiple values enclose the interpolating variables in parentheses, e.g. There is much more to string formatting than is shown here. For the details start with the Python Library Reference Section 7 . More details can be found in the Gnu AWK manual Section 5.2","title":"Output Formatting"},{"location":"02_SIPO/25_Pythonic_process/","text":"Algorithm Development in Python Step 1: Read the problem description Read the question in detail. If the question references something else (like an equation and another file or the Moodle), make sure you read that too. Step 2: Analyze the problem What data is available to us and how is it represented? What are the inputs, outputs, and important variables? When does the program end? What assumptions can I make? Ask for clarification if you aren't sure. What keywords are in the problem that suggest how we might solve it (if, decide, compare, repeat, remove, ...)? Think about how you would intuitively solve the problem without a formal step by step process. This might involve drawing or writing down thoughts and examples. Step 3: Write an algorithm in English Write out the steps of the program in plain language, like you were explaining something in a lot of detail to another person. Step 4: Write a detailed algorithm Write out the algorithm in pseudocode. That means writing it out in a mix of language and code. Here you should think about how you can translate the steps into the 6 basic programming operations (input, procession, output, sequence, selection, repetition, and the bonus 7 th one modularity). Step 5: Start writing the algorithm in Python We are finally writing our code into the computer. Start to translate the algorithm you wrote in step 4 into the syntax needed to get it working in Python. It is often useful to write some pieces of the code and test them on their own (instead of trying to write everything all at once). Choose variable names will make your program easy to read and make sure you add comments to clarify any complicated parts. Step 6: Test your code Test your code. The first thing to check is if it runs without an error. Error messages print a line number, the problem is usually on that line (although sometimes it is a problem from the line of code before that). Go back to step 5 and adjust your Python code until it run without a syntax or runtime error. If the code runs without errors, then it is time to see if the logic works. We do this by giving it a set of test variables for that program. Do you get the outputs you expect for each one? In some questions I will provide the tests, in others you will have to think of your own set of tests to see if your code works for all the expected values. You may have to revisit your high-level or detailed algorithm to find problems with the logic. Step 7: Document your code Make sure the filename matches the instructions. Make sure that you have a header at the top of the file with the filename, program description, your name, and the date. Make sure that the description is detailed. Double check that you have used reasonable variable names throughout the code and adjust them if they are not clear.","title":"Algorithm Development in Python"},{"location":"02_SIPO/25_Pythonic_process/#algorithm-development-in-python","text":"","title":"Algorithm Development in Python"},{"location":"02_SIPO/25_Pythonic_process/#step-1-read-the-problem-description","text":"Read the question in detail. If the question references something else (like an equation and another file or the Moodle), make sure you read that too.","title":"Step 1: Read the problem description"},{"location":"02_SIPO/25_Pythonic_process/#step-2-analyze-the-problem","text":"What data is available to us and how is it represented? What are the inputs, outputs, and important variables? When does the program end? What assumptions can I make? Ask for clarification if you aren't sure. What keywords are in the problem that suggest how we might solve it (if, decide, compare, repeat, remove, ...)? Think about how you would intuitively solve the problem without a formal step by step process. This might involve drawing or writing down thoughts and examples.","title":"Step 2: Analyze the problem"},{"location":"02_SIPO/25_Pythonic_process/#step-3-write-an-algorithm-in-english","text":"Write out the steps of the program in plain language, like you were explaining something in a lot of detail to another person.","title":"Step 3: Write an algorithm in English"},{"location":"02_SIPO/25_Pythonic_process/#step-4-write-a-detailed-algorithm","text":"Write out the algorithm in pseudocode. That means writing it out in a mix of language and code. Here you should think about how you can translate the steps into the 6 basic programming operations (input, procession, output, sequence, selection, repetition, and the bonus 7 th one modularity).","title":"Step 4: Write a detailed algorithm"},{"location":"02_SIPO/25_Pythonic_process/#step-5-start-writing-the-algorithm-in-python","text":"We are finally writing our code into the computer. Start to translate the algorithm you wrote in step 4 into the syntax needed to get it working in Python. It is often useful to write some pieces of the code and test them on their own (instead of trying to write everything all at once). Choose variable names will make your program easy to read and make sure you add comments to clarify any complicated parts.","title":"Step 5: Start writing the algorithm in Python"},{"location":"02_SIPO/25_Pythonic_process/#step-6-test-your-code","text":"Test your code. The first thing to check is if it runs without an error. Error messages print a line number, the problem is usually on that line (although sometimes it is a problem from the line of code before that). Go back to step 5 and adjust your Python code until it run without a syntax or runtime error. If the code runs without errors, then it is time to see if the logic works. We do this by giving it a set of test variables for that program. Do you get the outputs you expect for each one? In some questions I will provide the tests, in others you will have to think of your own set of tests to see if your code works for all the expected values. You may have to revisit your high-level or detailed algorithm to find problems with the logic.","title":"Step 6: Test your code"},{"location":"02_SIPO/25_Pythonic_process/#step-7-document-your-code","text":"Make sure the filename matches the instructions. Make sure that you have a header at the top of the file with the filename, program description, your name, and the date. Make sure that the description is detailed. Double check that you have used reasonable variable names throughout the code and adjust them if they are not clear.","title":"Step 7: Document your code"},{"location":"02_SIPO/70_Exercise_sheet_1/","text":"Exercise Sheet 1 Look at the following code fragments. Each one has one small problem that will cause an error or give the wrong output. Using what you know about python math operations and SIPO programming to identify an correct the problems. a) distance_km = int(input('Enter a distance in kilometers: ') distance_km * 1.6 = distance_miles print(distance_km,'kilometers is the same as', distance_miles, 'miles') b) distance = duration * speed speed = int(input('Enter the speed in km: ')) duration = int(input('Enter the duration of time in hours: ')) print(distance) c) name = input('Enter your name: ') print('Hello name') Write a program that calculates the annual compound interest on an investment in a bank account. The program will get as input the starting account balance, the interest rate on the account, and the number of years for the money to grow. It will calculate the compound interest assuming that the rate is compounded annually. The equation for compound interest is: A = P(1 + r/n)^nt A = final balance P = starting balance r = interest rate (remember this needs to be a percentage) n = number of times interest applied per time period (use n = 1) t = the time in years Write a program that calculates the total surface area of your skin. This program will take in the users height and weight in inches and pounds. You will need to know that 1 in = 2.54 cm and that 1 kg = 2.2 lbs. It will then convert those value to cm and kg before applying the following equation: where, BSA = body surface area W= weight in kg H= height in cm *Note that even though is uses the height in cm the result is in meters squared. To solve this equation, you will need to use the square root operator. You do this by importing the library math and then using the sqrt function. I\u2019ve included a short piece of code here to demonstrate. import math num = int(input('Enter a number: ') root = math.sqrt(num) print('The square root of', num, 'is', root) Look at the following and think about how well the code is written. The program works correctly, so I want you to focus on the clarity of the variable names and the comments included. Look at the marking guide and think about what grade you would give to this code. Make some notes on the feedback you would give to this student to help them improve their grade. # annual_income.py # This program calculates how mush someone maeks w = float(input('Enter how much you make: ')) h = float(input('Enter your hours: ')) total = w * h * 52 print('You make',total, 'dollars.')","title":"Exercise Sheet 1"},{"location":"02_SIPO/70_Exercise_sheet_1/#exercise-sheet-1","text":"Look at the following code fragments. Each one has one small problem that will cause an error or give the wrong output. Using what you know about python math operations and SIPO programming to identify an correct the problems. a) distance_km = int(input('Enter a distance in kilometers: ') distance_km * 1.6 = distance_miles print(distance_km,'kilometers is the same as', distance_miles, 'miles') b) distance = duration * speed speed = int(input('Enter the speed in km: ')) duration = int(input('Enter the duration of time in hours: ')) print(distance) c) name = input('Enter your name: ') print('Hello name') Write a program that calculates the annual compound interest on an investment in a bank account. The program will get as input the starting account balance, the interest rate on the account, and the number of years for the money to grow. It will calculate the compound interest assuming that the rate is compounded annually. The equation for compound interest is: A = P(1 + r/n)^nt A = final balance P = starting balance r = interest rate (remember this needs to be a percentage) n = number of times interest applied per time period (use n = 1) t = the time in years Write a program that calculates the total surface area of your skin. This program will take in the users height and weight in inches and pounds. You will need to know that 1 in = 2.54 cm and that 1 kg = 2.2 lbs. It will then convert those value to cm and kg before applying the following equation: where, BSA = body surface area W= weight in kg H= height in cm *Note that even though is uses the height in cm the result is in meters squared. To solve this equation, you will need to use the square root operator. You do this by importing the library math and then using the sqrt function. I\u2019ve included a short piece of code here to demonstrate. import math num = int(input('Enter a number: ') root = math.sqrt(num) print('The square root of', num, 'is', root) Look at the following and think about how well the code is written. The program works correctly, so I want you to focus on the clarity of the variable names and the comments included. Look at the marking guide and think about what grade you would give to this code. Make some notes on the feedback you would give to this student to help them improve their grade. # annual_income.py # This program calculates how mush someone maeks w = float(input('Enter how much you make: ')) h = float(input('Enter your hours: ')) total = w * h * 52 print('You make',total, 'dollars.')","title":"Exercise Sheet 1"},{"location":"02_SIPO/90_Assignment_2/","text":"Assignment 2 Problems Trivialities We only know enough Python commands to write simple programs so far, but we do need to practice using what we've got so ... write a program that produces sessions like this one: Useless Trivia Generator v0.01 ============================== How old are you? 28 And how many pounds do you weigh? 165 Did you know that you're 196 in dog years! But you're also over 883008000 seconds old. Did you know that on the moon you would weigh only 27.5 pounds? But on the sun, you'd weigh 4471.5 pounds (but not for long!). Some facts that might be helpful to you in writing your program: There are seven dog years in each calendar year. There are 60 seconds in a minute, 60 minutes in an hour, 24 hours in a day, and (at least) 365 days in a year. Things weigh 1/6th as much on the moon as they do on the surface of the earth. Things weigh 27.1 times as much on the surface of the sun as they do on the surface of the earth. Calculating Wind Chill While the temperature tells us how cold the air outside is, we are often more interested in how quickly we will cool down. The rate at which we lose heat depends on the temperature outside, and also on the speed of the wind: the combined effect of temperature and wind speed is often called the wind chill. The effective temperature, T e , can be calculated using the expression, where V is the wind speed in kilometres per hour, and T is the temperature in Celsius. Write a program that calculates the effective temperature. It should request the temperature and wind speed from the user and output the effective temperature. Converting from furlongs et al to feet A historian has come across a large body of material using outdated units of measurement. Specifically, distance measurements are given in terms of feet, yards (1 yard = 3 feet), chains (1 chain = 22 yards), and furlongs (1 furlong = 10 chains). Write a program that will let her enter one of the historical measurements in furlongs, chains, yards and feet (e.g. 2 furlongs, 3 chains, 13 yards and 2 feet) and output the equivalent measurement in feet (i.e. 1559 feet). Converting from feet to furlongs et al The historian above now wishes to convert some measurements she has made in feet into these archaic units. Write a program that will convert from feet to furlongs, chains, yards and feet, so if she inputs 1559 the output should be something like: 1559 feet is equal to: 2 furlongs, 3 chains, 13 yards, and 2 feet. Logistics Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a2p1bob.py .","title":"Assignment 2"},{"location":"02_SIPO/90_Assignment_2/#assignment-2","text":"","title":"Assignment 2"},{"location":"02_SIPO/90_Assignment_2/#problems","text":"","title":"Problems"},{"location":"02_SIPO/90_Assignment_2/#trivialities","text":"We only know enough Python commands to write simple programs so far, but we do need to practice using what we've got so ... write a program that produces sessions like this one: Useless Trivia Generator v0.01 ============================== How old are you? 28 And how many pounds do you weigh? 165 Did you know that you're 196 in dog years! But you're also over 883008000 seconds old. Did you know that on the moon you would weigh only 27.5 pounds? But on the sun, you'd weigh 4471.5 pounds (but not for long!). Some facts that might be helpful to you in writing your program: There are seven dog years in each calendar year. There are 60 seconds in a minute, 60 minutes in an hour, 24 hours in a day, and (at least) 365 days in a year. Things weigh 1/6th as much on the moon as they do on the surface of the earth. Things weigh 27.1 times as much on the surface of the sun as they do on the surface of the earth.","title":"Trivialities"},{"location":"02_SIPO/90_Assignment_2/#calculating-wind-chill","text":"While the temperature tells us how cold the air outside is, we are often more interested in how quickly we will cool down. The rate at which we lose heat depends on the temperature outside, and also on the speed of the wind: the combined effect of temperature and wind speed is often called the wind chill. The effective temperature, T e , can be calculated using the expression, where V is the wind speed in kilometres per hour, and T is the temperature in Celsius. Write a program that calculates the effective temperature. It should request the temperature and wind speed from the user and output the effective temperature.","title":"Calculating Wind Chill"},{"location":"02_SIPO/90_Assignment_2/#converting-from-furlongs-et-al-to-feet","text":"A historian has come across a large body of material using outdated units of measurement. Specifically, distance measurements are given in terms of feet, yards (1 yard = 3 feet), chains (1 chain = 22 yards), and furlongs (1 furlong = 10 chains). Write a program that will let her enter one of the historical measurements in furlongs, chains, yards and feet (e.g. 2 furlongs, 3 chains, 13 yards and 2 feet) and output the equivalent measurement in feet (i.e. 1559 feet).","title":"Converting from furlongs et al to feet"},{"location":"02_SIPO/90_Assignment_2/#converting-from-feet-to-furlongs-et-al","text":"The historian above now wishes to convert some measurements she has made in feet into these archaic units. Write a program that will convert from feet to furlongs, chains, yards and feet, so if she inputs 1559 the output should be something like: 1559 feet is equal to: 2 furlongs, 3 chains, 13 yards, and 2 feet.","title":"Converting from feet to furlongs et al"},{"location":"02_SIPO/90_Assignment_2/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a2p1bob.py .","title":"Logistics"},{"location":"03_Selection/","text":"Introduction: Being selective \ud83e\uddd0 Module 3 focuses on \"selection structures\". Jargon I know, but the key to focus on is \"select\". Most computation procedures are not an unvarying sequence of steps to carry out like the SIPO programs in Module 2, instead they have to select which operations to carry out depending on circumstances. They might have to alter their output messages depending on the result of a calculation, e.g. if your % mark is high you get an A, but if it is too low a D! Or they might alter the calculations they carry out depending on an intermediate result, e.g. they might charge regular price for small orders, but give a discount if an order is large enough. Or they might even alter what task they undertake in the first place depending on the user's actions, e.g. in desktop software what action to take depends on which menu item the user selects. In all these cases what we need is a way to do one thing or another (but not both). This week's resources will show you how to achieve that in Python. One thing to watch for is how we code our selection structures efficiently, so they don't perform more tests than necessary. Efficiency wasn't much of an issue in SIPO programs, but it starts to become one here. if: A Simple (artificial) Example Correcting an Oversight if Syntax, in Detail Relational Expressions Compound Statements and Indentation Example: One program to convert F to C_or_C to F The Problem Version 1 Version 2 Testing Selection Performance Analysis* A Final (Very Small) Example: Absolute value Summary: Selection using if Gazinta (as in \"2 Gazinta 8, but 3 doesn't\") Ode to Pythagoras Utility bills Beaufort Scale Exercise sheet 2 Assignment 3","title":"Introduction: Being selective \ud83e\uddd0"},{"location":"03_Selection/#introduction-being-selective","text":"Module 3 focuses on \"selection structures\". Jargon I know, but the key to focus on is \"select\". Most computation procedures are not an unvarying sequence of steps to carry out like the SIPO programs in Module 2, instead they have to select which operations to carry out depending on circumstances. They might have to alter their output messages depending on the result of a calculation, e.g. if your % mark is high you get an A, but if it is too low a D! Or they might alter the calculations they carry out depending on an intermediate result, e.g. they might charge regular price for small orders, but give a discount if an order is large enough. Or they might even alter what task they undertake in the first place depending on the user's actions, e.g. in desktop software what action to take depends on which menu item the user selects. In all these cases what we need is a way to do one thing or another (but not both). This week's resources will show you how to achieve that in Python. One thing to watch for is how we code our selection structures efficiently, so they don't perform more tests than necessary. Efficiency wasn't much of an issue in SIPO programs, but it starts to become one here. if: A Simple (artificial) Example Correcting an Oversight if Syntax, in Detail Relational Expressions Compound Statements and Indentation Example: One program to convert F to C_or_C to F The Problem Version 1 Version 2 Testing Selection Performance Analysis* A Final (Very Small) Example: Absolute value Summary: Selection using if Gazinta (as in \"2 Gazinta 8, but 3 doesn't\") Ode to Pythagoras Utility bills Beaufort Scale Exercise sheet 2 Assignment 3","title":"Introduction: Being selective \ud83e\uddd0"},{"location":"03_Selection/01_If_A_simple_artificial_example/","text":"if: A Simple (artificial) Example Consider the problem of checking a number to see if it is positive or negative, and outputting an appropriate message. The SIPO statements we have used so far are not up to the task. The problem is that the message we output depends on the sign of the variable, and that may change from one run of the program to the next. That means that both the possible output statements \"is negative\" and \"is positive\" must be present in the program, and that the program must select which one to execute based on the sign of the variable. Python has a selection statement called if that allows us to do that, like this: value = int(input(\"Enter an integer (e.g, 23 or -118): \")) if value < 0: print(value, \"is negative\") else: print(value, \" is positive\") (Note that the statements after the if and else statements are indented four spaces.) The first statement should look familiar, but here's what happens next. The if statement says that if value is less than 0 then the first print statement should be executed, otherwise (\"else\") the second print statement should be executed. Here's how the execution of the statements takes place. When the program reaches the if statement, it evaluates the expression value < 0 . If the expression is True (the number stored in value is less than zero) it executes the first print statement, and then skips over the else and the second print statement. On the other hand, if the expression is False , it skips the first print statement and executes the statement after the else . The key is that in either case only one of the print statements is executed, i.e. the if statement selects which one to execute based on the test value < 0 . The flow of control of this if statement can be represented using a flowchart as shown below. Following the arrows (the flow so to speak) from top to bottom makes it clear that on any run of the program only one of the two output statements will be executed.","title":"if:\u00a0A Simple (artificial) Example"},{"location":"03_Selection/01_If_A_simple_artificial_example/#if-a-simple-artificial-example","text":"Consider the problem of checking a number to see if it is positive or negative, and outputting an appropriate message. The SIPO statements we have used so far are not up to the task. The problem is that the message we output depends on the sign of the variable, and that may change from one run of the program to the next. That means that both the possible output statements \"is negative\" and \"is positive\" must be present in the program, and that the program must select which one to execute based on the sign of the variable. Python has a selection statement called if that allows us to do that, like this: value = int(input(\"Enter an integer (e.g, 23 or -118): \")) if value < 0: print(value, \"is negative\") else: print(value, \" is positive\") (Note that the statements after the if and else statements are indented four spaces.) The first statement should look familiar, but here's what happens next. The if statement says that if value is less than 0 then the first print statement should be executed, otherwise (\"else\") the second print statement should be executed. Here's how the execution of the statements takes place. When the program reaches the if statement, it evaluates the expression value < 0 . If the expression is True (the number stored in value is less than zero) it executes the first print statement, and then skips over the else and the second print statement. On the other hand, if the expression is False , it skips the first print statement and executes the statement after the else . The key is that in either case only one of the print statements is executed, i.e. the if statement selects which one to execute based on the test value < 0 . The flow of control of this if statement can be represented using a flowchart as shown below. Following the arrows (the flow so to speak) from top to bottom makes it clear that on any run of the program only one of the two output statements will be executed.","title":"if:\u00a0A Simple (artificial) Example"},{"location":"03_Selection/02_Correcting_an_oversight/","text":"Correcting an Oversight The mathematically inclined will examine the previous program and note that it mishandles the value 0. Which output statement will be executed if zero is entered? Well, the test value < 0 will be False because 0 is not less than 0, so the first output statement will be skipped, and the second one will be executed displaying the message 0 is positive on-screen. Unfortunately this is not true: 0 is neither positive nor negative. This means our program must actually deal with three possibilities: The value entered is negative. The value entered is 0. The value entered is positive. We can accomodate this third possibility by modifying our flowchart as follows. As the flowchart shows we will require a second selection statement. As before the first statement will determine if the number is negative. If it is, the appropriate print statement will be executed. If the number is not negative however, execution will pass to a second if statement that will determine if the value is zero, and then select which of two further output statements to execute. The corresponding Python code looks like this: value = int(input( \"Enter an integer (e.g. 23 or -118): \" )) if value < 0: print(value, \"is negative\") else: if value == 0: print(value, \"is neither positive nor negative\") else: print(value, \"is positive\") (Note the double equal signs, ==. More on this below. ) This is a correct Python program, but the situation of a multiway (as opposed to two-way) decision is so common that Python provides a special syntax to express it: value = int(input( \"Enter an integer (e.g, 23 or -118): \" )) if value < 0: print(value, \"is negative\") elif value == 0: print(value, \"is neither positive nor negative\") else: print(value, \"is positive\") Note the use of elif which combines else and if into a single command.","title":"Correcting an Oversight"},{"location":"03_Selection/02_Correcting_an_oversight/#correcting-an-oversight","text":"The mathematically inclined will examine the previous program and note that it mishandles the value 0. Which output statement will be executed if zero is entered? Well, the test value < 0 will be False because 0 is not less than 0, so the first output statement will be skipped, and the second one will be executed displaying the message 0 is positive on-screen. Unfortunately this is not true: 0 is neither positive nor negative. This means our program must actually deal with three possibilities: The value entered is negative. The value entered is 0. The value entered is positive. We can accomodate this third possibility by modifying our flowchart as follows. As the flowchart shows we will require a second selection statement. As before the first statement will determine if the number is negative. If it is, the appropriate print statement will be executed. If the number is not negative however, execution will pass to a second if statement that will determine if the value is zero, and then select which of two further output statements to execute. The corresponding Python code looks like this: value = int(input( \"Enter an integer (e.g. 23 or -118): \" )) if value < 0: print(value, \"is negative\") else: if value == 0: print(value, \"is neither positive nor negative\") else: print(value, \"is positive\") (Note the double equal signs, ==. More on this below. ) This is a correct Python program, but the situation of a multiway (as opposed to two-way) decision is so common that Python provides a special syntax to express it: value = int(input( \"Enter an integer (e.g, 23 or -118): \" )) if value < 0: print(value, \"is negative\") elif value == 0: print(value, \"is neither positive nor negative\") else: print(value, \"is positive\") Note the use of elif which combines else and if into a single command.","title":"Correcting an Oversight"},{"location":"03_Selection/03_If_syntax_in_detail/","text":"if Syntax, in Detail The syntax of the if statement is, if statement syntax if test-expression1 : true-statement1 [ elif test-expression2 : true-statement2 ] ... [ else: false-statement ] Or in words, the if statement consists of the keyword if followed by a test expression , followed by a statement that will be executed if the test expression is True , optionally followed by the keyword elif followed by a second test expression and a second statement which will be executed if the second text expression is True , and so on until an optional else is reached the statements following which will be executed only if_all_the test-expressions above it were False . Note that the statements following if , elif and else statements must be indented.","title":"if\u00a0Syntax, in Detail"},{"location":"03_Selection/03_If_syntax_in_detail/#if-syntax-in-detail","text":"The syntax of the if statement is, if statement syntax if test-expression1 : true-statement1 [ elif test-expression2 : true-statement2 ] ... [ else: false-statement ] Or in words, the if statement consists of the keyword if followed by a test expression , followed by a statement that will be executed if the test expression is True , optionally followed by the keyword elif followed by a second test expression and a second statement which will be executed if the second text expression is True , and so on until an optional else is reached the statements following which will be executed only if_all_the test-expressions above it were False . Note that the statements following if , elif and else statements must be indented.","title":"if\u00a0Syntax, in Detail"},{"location":"03_Selection/04_Relational_expressions/","text":"Relational Expressions The test expressions used in Python are relational expressions, and more specifically Boolean expressions. Relational expressions test the relation between quantities and produce a Boolean value, either True or False *. Python provides the relational operators < <= == != >= > The two on either end should be easy to interpret. They are, respectively, less than ( < ), less than or equal to ( <= ), greater than or equal to ( >= ) and greater than ( > ). The two in the center are not as easily recognized. The first, == , tests for equality. Why not just use a single equals sign? Because the equals sign, = , is already taken: remember that = is the assignment operator. The second expression, != , is used to test for inequality (or \"not equals\"). Here are some examples of simple relational expressions. x < 27.8 age >= 65 temp != max_temp Try them out in the Python shell. Python also provides logical operators that can be used to build compound relational expressions, usually referred to as Boolean expressions. The logical operators are, and or not An and relation is only True if_both_its arguments are True . An or relation is True as long as at least one of its arguments is True . The not operator negates its argument. Consider the following example: age >= 20 and age < 30 This expression will only be True if the value of the variable age is greater than or equal to 20 and it is also less than 30. Thus the entire expression is True when, for example, age is 24, but False when it is 12 (because this makes the first relation False ), and also when it is 62 (because this makes the second relation False ). age >= 20 or income < 18.45 This expression is True when either the value of age is greater than or equal to 20, or the value of income is less than 18.45, or both. not tested This expression is True when the value stored in tested is False , and False when the value stored in tested is True . The values True and False are Boolean constants in Python in the same way that 1 and \u20135 are numerical constants. Note however that while there are an infinite number of numerical constants there are_exactly_two Boolean constants: True and False .","title":"Relational Expressions"},{"location":"03_Selection/04_Relational_expressions/#relational-expressions","text":"The test expressions used in Python are relational expressions, and more specifically Boolean expressions. Relational expressions test the relation between quantities and produce a Boolean value, either True or False *. Python provides the relational operators < <= == != >= > The two on either end should be easy to interpret. They are, respectively, less than ( < ), less than or equal to ( <= ), greater than or equal to ( >= ) and greater than ( > ). The two in the center are not as easily recognized. The first, == , tests for equality. Why not just use a single equals sign? Because the equals sign, = , is already taken: remember that = is the assignment operator. The second expression, != , is used to test for inequality (or \"not equals\"). Here are some examples of simple relational expressions. x < 27.8 age >= 65 temp != max_temp Try them out in the Python shell. Python also provides logical operators that can be used to build compound relational expressions, usually referred to as Boolean expressions. The logical operators are, and or not An and relation is only True if_both_its arguments are True . An or relation is True as long as at least one of its arguments is True . The not operator negates its argument. Consider the following example: age >= 20 and age < 30 This expression will only be True if the value of the variable age is greater than or equal to 20 and it is also less than 30. Thus the entire expression is True when, for example, age is 24, but False when it is 12 (because this makes the first relation False ), and also when it is 62 (because this makes the second relation False ). age >= 20 or income < 18.45 This expression is True when either the value of age is greater than or equal to 20, or the value of income is less than 18.45, or both. not tested This expression is True when the value stored in tested is False , and False when the value stored in tested is True . The values True and False are Boolean constants in Python in the same way that 1 and \u20135 are numerical constants. Note however that while there are an infinite number of numerical constants there are_exactly_two Boolean constants: True and False .","title":"Relational Expressions"},{"location":"03_Selection/05_Compound_statements_and_indentation/","text":"Compound Statements and Indentation The syntax for if offered previously says that the if , elif and else statements can be followed by a single statement. But what if a single statement isn't enough to get the job done? What if several statements will be required? Python's solution to this is simple: just indent all the statements the same amount beneath the if / elif / else statement. The result is a single compound statement . The word compound simply indicates that the statement contains several individual sub-statements. As long as the group of statements are all indented the same amount they will be treated as a single block or chunk and all be executed. Indentation is encouraged in almost all modern programming languages to enhance readability, but Python goes a step further and_requires_it. The next program we consider illustrates compound statements.","title":"Compound Statements and Indentation"},{"location":"03_Selection/05_Compound_statements_and_indentation/#compound-statements-and-indentation","text":"The syntax for if offered previously says that the if , elif and else statements can be followed by a single statement. But what if a single statement isn't enough to get the job done? What if several statements will be required? Python's solution to this is simple: just indent all the statements the same amount beneath the if / elif / else statement. The result is a single compound statement . The word compound simply indicates that the statement contains several individual sub-statements. As long as the group of statements are all indented the same amount they will be treated as a single block or chunk and all be executed. Indentation is encouraged in almost all modern programming languages to enhance readability, but Python goes a step further and_requires_it. The next program we consider illustrates compound statements.","title":"Compound Statements and Indentation"},{"location":"03_Selection/06_Example_One_program_to_convert_f_to_c_or_c_to_f/","text":"Example: One program to convert F to C or C to F Consider this program to convert temperatures in Fahrenheit to Celsius. print(\"This program converts temperatures from Fahrenheit to Celsius.\") temp_in_f = int(input( \"Enter a temperature in Fahrenheit (e.g. 10) and press Enter: \" )) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \" degrees Fahrenheit = \", temp_in_c, \" degrees Celsius.\") (For simplicity I have removed the opening comments). If instead we wanted to convert temperatures in Celsius to Fahrenheit we could write a second very similar program to do so: print(\"This program converts temperatures from Celsius to Fahrenheit .\") temp_in_c= int(input( \"Enter a temperature in Celsius (e.g. 10) and press Enter: \" )) temp_in_f = temp_in_c * 9 / 5 + 32; print(temp_in_c, \" degrees Celsius = \", temp_in_f, \" degrees Fahrenheit.\") But what if we want a single program that can do either conversion? We will need to place both sets of conversion code in one program and then choose which one to execute. How will we choose? Based on user input, i.e. we will present the choices and let the user choose. The resulting program might look like this. ########################################################### ## tmpcnvrt.py -- allows the user to convert a temperature ## in Fahrenheit to Celsius or vice versa. ## ## CPSC 128 Demonstration Program ## ## Kate Chatfield-Reed, Winter 2023 ########################################################### print(\"This program converts temperatures from Fahrenheit to Celsius,\") print(\"or from Celsius to Fahrenheit.\") print(\"Choose\") print(\"1 to convert Fahrenheit to Celsius\") print(\"2 to convert Celsius to Fahrenheit\") choice = int(input( \"Your choice? \" )) if choice == 1: print(\"This program converts temperatures from Fahrenheit to Celsius.\") temp_in_f = int(input( \"Enter a temperature in Fahrenheit (e.g. 10) and press Enter: \" )) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \" degrees Fahrenheit = \", temp_in_c, \" degrees Celsius.\") elif choice == 2: print(\"This program converts temperatures from Celsius to Fahrenheit .\") temp_in_c= int(input( \"Enter a temperature in Celsius (e.g. 10) and press Enter: \" )) temp_in_f = temp_in_c * 9 / 5 + 32 print(temp_in_c, \" degrees Celsius = \", temp_in_f, \" degrees Fahrenheit.\") else: print(\"Error: Your choice not recognized!\") The program begins by displaying a text menu offering the user numbered choices. The user types a number and the program tests the number. If it is a 1, the block of indented code after the if statement is executed, and the blocks of code after the elif and else below it are skipped. If it is not a 1, the block of indented code after the if is skipped, and the elif is executed. If this test is True (i.e. choice contains 2) the block of code after the elif is executed, and the else is skipped. If the value of choice is not 2, then the code after the else is executed and the message Error: Your choice not recognized is displayed. Note that the block of code after the if and after the elif contain several statements, so they must be consistently indented to turn them into single compound statements. Also, take careful note of the program formatting. The statements after an if , elif or else are all indented 4 spaces. In summary, this program selects one of three actions to carry out based on user input. If the initial value entered is 1, it performs a conversion from Fahrenheit to Celsius. If the initial value entered is 2, it performs a conversion from Celsius to Fahrenheit. If any other value is entered it displays an error message. When more than one test is used to choose between multiple possibilities, as above, the if , elif s and else are arranged in a cascade. Our next program will illustrate how to create compound tests, i.e. multiple comparisons combined with logical operators ( and , or , and not ), and how to structure multiple if s efficiently in a cascade.","title":"Example: One program to convert F to C or C to F"},{"location":"03_Selection/06_Example_One_program_to_convert_f_to_c_or_c_to_f/#example-one-program-to-convert-f-to-c-or-c-to-f","text":"Consider this program to convert temperatures in Fahrenheit to Celsius. print(\"This program converts temperatures from Fahrenheit to Celsius.\") temp_in_f = int(input( \"Enter a temperature in Fahrenheit (e.g. 10) and press Enter: \" )) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \" degrees Fahrenheit = \", temp_in_c, \" degrees Celsius.\") (For simplicity I have removed the opening comments). If instead we wanted to convert temperatures in Celsius to Fahrenheit we could write a second very similar program to do so: print(\"This program converts temperatures from Celsius to Fahrenheit .\") temp_in_c= int(input( \"Enter a temperature in Celsius (e.g. 10) and press Enter: \" )) temp_in_f = temp_in_c * 9 / 5 + 32; print(temp_in_c, \" degrees Celsius = \", temp_in_f, \" degrees Fahrenheit.\") But what if we want a single program that can do either conversion? We will need to place both sets of conversion code in one program and then choose which one to execute. How will we choose? Based on user input, i.e. we will present the choices and let the user choose. The resulting program might look like this. ########################################################### ## tmpcnvrt.py -- allows the user to convert a temperature ## in Fahrenheit to Celsius or vice versa. ## ## CPSC 128 Demonstration Program ## ## Kate Chatfield-Reed, Winter 2023 ########################################################### print(\"This program converts temperatures from Fahrenheit to Celsius,\") print(\"or from Celsius to Fahrenheit.\") print(\"Choose\") print(\"1 to convert Fahrenheit to Celsius\") print(\"2 to convert Celsius to Fahrenheit\") choice = int(input( \"Your choice? \" )) if choice == 1: print(\"This program converts temperatures from Fahrenheit to Celsius.\") temp_in_f = int(input( \"Enter a temperature in Fahrenheit (e.g. 10) and press Enter: \" )) temp_in_c = (temp_in_f - 32) * 5 / 9 print(temp_in_f, \" degrees Fahrenheit = \", temp_in_c, \" degrees Celsius.\") elif choice == 2: print(\"This program converts temperatures from Celsius to Fahrenheit .\") temp_in_c= int(input( \"Enter a temperature in Celsius (e.g. 10) and press Enter: \" )) temp_in_f = temp_in_c * 9 / 5 + 32 print(temp_in_c, \" degrees Celsius = \", temp_in_f, \" degrees Fahrenheit.\") else: print(\"Error: Your choice not recognized!\") The program begins by displaying a text menu offering the user numbered choices. The user types a number and the program tests the number. If it is a 1, the block of indented code after the if statement is executed, and the blocks of code after the elif and else below it are skipped. If it is not a 1, the block of indented code after the if is skipped, and the elif is executed. If this test is True (i.e. choice contains 2) the block of code after the elif is executed, and the else is skipped. If the value of choice is not 2, then the code after the else is executed and the message Error: Your choice not recognized is displayed. Note that the block of code after the if and after the elif contain several statements, so they must be consistently indented to turn them into single compound statements. Also, take careful note of the program formatting. The statements after an if , elif or else are all indented 4 spaces. In summary, this program selects one of three actions to carry out based on user input. If the initial value entered is 1, it performs a conversion from Fahrenheit to Celsius. If the initial value entered is 2, it performs a conversion from Celsius to Fahrenheit. If any other value is entered it displays an error message. When more than one test is used to choose between multiple possibilities, as above, the if , elif s and else are arranged in a cascade. Our next program will illustrate how to create compound tests, i.e. multiple comparisons combined with logical operators ( and , or , and not ), and how to structure multiple if s efficiently in a cascade.","title":"Example: One program to convert F to C or C to F"},{"location":"03_Selection/07_The_problem/","text":"The Problem At Yukon University numerical grades are converted to letter grades using a conversion chart. The values are as follows: Numerical Grade Letter Grade 95-100 A+ 86-94 A 80-85 A- 75-79 B+ 70-74 B 65-69 B- 62-64 C+ 58-61 C 55-57 C- 50-54 D 0-50 F We would like to write a program that accepts a numerical grade and outputs a letter grade.","title":"The Problem"},{"location":"03_Selection/07_The_problem/#the-problem","text":"At Yukon University numerical grades are converted to letter grades using a conversion chart. The values are as follows: Numerical Grade Letter Grade 95-100 A+ 86-94 A 80-85 A- 75-79 B+ 70-74 B 65-69 B- 62-64 C+ 58-61 C 55-57 C- 50-54 D 0-50 F We would like to write a program that accepts a numerical grade and outputs a letter grade.","title":"The Problem"},{"location":"03_Selection/08_Version_1/","text":"Version 1 We would like to write a program that accepts a numerical grade and outputs a letter grade. Clearly the program will use one or more print statements to display instructions to the user, and an input statement to get the numerical grade to be converted. Then it will need to output one of the 11 possible letter grades depending on the numerical grade. That is obviously a selection step, because we are selecting one of 11 possible output statements. The question is how to structure if statements to implement that step. If someone asked us what the table says we might reply, \"It says if the numerical grade is between 95 and 100, then the letter grade is an A+. If the numerical grade is between 86 and 94, then the letter grade is an A.\" and so on. A literal translation of this into Python would result in the following code. # Version 1. print(\" ... \") # Instructions to user grade = float(input(\"...\")) if grade >= 95 and grade <= 100: print(\"A+\") if grade >= 86 and grade <= 94: print(\"A\") if grade >= 80 and grade <= 85: print(\"A-\") # ... # and so on down to # ... if grade >= 50 and grade <= 54: print(\"D\") if grade >= 0 and grade <= 50: print(\"F\") if grade < 0 or grade > 100: print \"Error: The grade must be between 0 and 100.\" This code would work. Play computer and try it yourself starting with numerical grades of, say, 65 and 96. But although it works, it performs unnecessary tests and so is slower than it could be.","title":"Version 1"},{"location":"03_Selection/08_Version_1/#version-1","text":"We would like to write a program that accepts a numerical grade and outputs a letter grade. Clearly the program will use one or more print statements to display instructions to the user, and an input statement to get the numerical grade to be converted. Then it will need to output one of the 11 possible letter grades depending on the numerical grade. That is obviously a selection step, because we are selecting one of 11 possible output statements. The question is how to structure if statements to implement that step. If someone asked us what the table says we might reply, \"It says if the numerical grade is between 95 and 100, then the letter grade is an A+. If the numerical grade is between 86 and 94, then the letter grade is an A.\" and so on. A literal translation of this into Python would result in the following code. # Version 1. print(\" ... \") # Instructions to user grade = float(input(\"...\")) if grade >= 95 and grade <= 100: print(\"A+\") if grade >= 86 and grade <= 94: print(\"A\") if grade >= 80 and grade <= 85: print(\"A-\") # ... # and so on down to # ... if grade >= 50 and grade <= 54: print(\"D\") if grade >= 0 and grade <= 50: print(\"F\") if grade < 0 or grade > 100: print \"Error: The grade must be between 0 and 100.\" This code would work. Play computer and try it yourself starting with numerical grades of, say, 65 and 96. But although it works, it performs unnecessary tests and so is slower than it could be.","title":"Version 1"},{"location":"03_Selection/09_Version_2/","text":"Version 2 If you emulated Version 1 precisely you will have noticed that you did a lot of unnecessary work when the mark was 96. Your simulation should have revealed that the grade passed the test in the first if statement and output \"A+\". So far so good. Next though it went on to evaluate the second if test, and the third, and the fourth and so on, all the way down the list. But, once we determined that the grade was an A+ we didn't have to do any of the other tests, because if the grade is between 95 and 100, it can't be in any of the other ranges. The way to avoid the unnecessary tests is to perform the tests following the first one with elif statements. The structure of the code is: # Version 2. print(\" ... \") # Instructions to user grade = float(input( \" ... \" )) if grade >= 95 and grade <= 100: print(\"A+\") elif grade >= 86 and grade <= 94: print(\"A\") elif grade >= 80 and grade <= 85: print(\"A-\") # ... # and so on down to # ... elif grade >= 50 and grade <= 54: print(\"D\") elif grade >= 0 and grade <= 50: print(\"F\") else: print(\"Error: The grade must be between 0 and 100.\") Before we analyze this code, again verify that it works by simulating its execution for a couple of sample numerical grades, e.g. 65 and 93. This is an improvement over the original code. For one thing we have eliminated the final error condition test completely: if the mark doesn't fall in any of the specified ranges then it must be out of range. But it also, on average does fewer tests. Consider, if the grade is an A+, e.g. 96, it does only the first if and skips the rest. Of course if the grade is an F it still does all the tests as it bumps its way down the list. So it never does more tests and often does fewer. On average (if the average grade is in the middle of the list) it will do half as many if tests as the first version, making it twice as fast. However, careful examination reveals that we still have more tests than are required, and those unnecessary tests waste processor time and slow down the program. What are the unnecessary tests? This time it's not unnecessary tests being evaluated, it's unnecessary comparisons being performed inside the tests. print(\" ... \") # Instructions to user grade = float(input(\"...\")) if grade > 100 or grade < 0: print(\"Error: The grade must be between 0 and 100.\") elif grade >= 95: print(\"A+\") elif grade >= 86: print(\"A\") elif grade >= 80: print(\"A-\") # ... # and so on down to # ... elif grade >= 50: print(\"D\") elif grade >= 0: print(\"F\") (Again verify that the code works by \"running it' in your mind with a couple of typical values.) This code represents a significant improvement over the second version on two counts: it is more efficient, and it is easier to read. It is easier to read because the relational expressions are shorter. It is more efficient because where the previous version had 33 relational operators (3 for each of 11 letter grades) this one has 3 + 10 = 13 (2 for the initial range check followed by one for each possible letter grade except the last). This is less than half as many, a significant improvement in any field (imagine a runner completing a race in half the previous time, or a car whose mileage suddenly doubled!).","title":"Version 2"},{"location":"03_Selection/09_Version_2/#version-2","text":"If you emulated Version 1 precisely you will have noticed that you did a lot of unnecessary work when the mark was 96. Your simulation should have revealed that the grade passed the test in the first if statement and output \"A+\". So far so good. Next though it went on to evaluate the second if test, and the third, and the fourth and so on, all the way down the list. But, once we determined that the grade was an A+ we didn't have to do any of the other tests, because if the grade is between 95 and 100, it can't be in any of the other ranges. The way to avoid the unnecessary tests is to perform the tests following the first one with elif statements. The structure of the code is: # Version 2. print(\" ... \") # Instructions to user grade = float(input( \" ... \" )) if grade >= 95 and grade <= 100: print(\"A+\") elif grade >= 86 and grade <= 94: print(\"A\") elif grade >= 80 and grade <= 85: print(\"A-\") # ... # and so on down to # ... elif grade >= 50 and grade <= 54: print(\"D\") elif grade >= 0 and grade <= 50: print(\"F\") else: print(\"Error: The grade must be between 0 and 100.\") Before we analyze this code, again verify that it works by simulating its execution for a couple of sample numerical grades, e.g. 65 and 93. This is an improvement over the original code. For one thing we have eliminated the final error condition test completely: if the mark doesn't fall in any of the specified ranges then it must be out of range. But it also, on average does fewer tests. Consider, if the grade is an A+, e.g. 96, it does only the first if and skips the rest. Of course if the grade is an F it still does all the tests as it bumps its way down the list. So it never does more tests and often does fewer. On average (if the average grade is in the middle of the list) it will do half as many if tests as the first version, making it twice as fast. However, careful examination reveals that we still have more tests than are required, and those unnecessary tests waste processor time and slow down the program. What are the unnecessary tests? This time it's not unnecessary tests being evaluated, it's unnecessary comparisons being performed inside the tests. print(\" ... \") # Instructions to user grade = float(input(\"...\")) if grade > 100 or grade < 0: print(\"Error: The grade must be between 0 and 100.\") elif grade >= 95: print(\"A+\") elif grade >= 86: print(\"A\") elif grade >= 80: print(\"A-\") # ... # and so on down to # ... elif grade >= 50: print(\"D\") elif grade >= 0: print(\"F\") (Again verify that the code works by \"running it' in your mind with a couple of typical values.) This code represents a significant improvement over the second version on two counts: it is more efficient, and it is easier to read. It is easier to read because the relational expressions are shorter. It is more efficient because where the previous version had 33 relational operators (3 for each of 11 letter grades) this one has 3 + 10 = 13 (2 for the initial range check followed by one for each possible letter grade except the last). This is less than half as many, a significant improvement in any field (imagine a runner completing a race in half the previous time, or a car whose mileage suddenly doubled!).","title":"Version 2"},{"location":"03_Selection/10_Testing_selection/","text":"Testing Selection We did some rough testing of our grade conversion program logic using a couple of typical values , 65 and 93. While it is_necessary_to test with common values like these, it is not sufficient . When programs break it is usually on uncommon values , i.e. values at the edge of the range of allowable values, or even outside the range. What uncommon values should we use to test this program?* Will this program work if the grades entered are real values, e.g. 75.3. If not, what happens? What changes are necessary to make it work with real values? We should try 0, 100 as they are at the edges of the range, and values off each edge of the range, e.g. -1 and 101, since they are outside the allowable range.","title":"Testing Selection"},{"location":"03_Selection/10_Testing_selection/#testing-selection","text":"We did some rough testing of our grade conversion program logic using a couple of typical values , 65 and 93. While it is_necessary_to test with common values like these, it is not sufficient . When programs break it is usually on uncommon values , i.e. values at the edge of the range of allowable values, or even outside the range. What uncommon values should we use to test this program?* Will this program work if the grades entered are real values, e.g. 75.3. If not, what happens? What changes are necessary to make it work with real values? We should try 0, 100 as they are at the edges of the range, and values off each edge of the range, e.g. -1 and 101, since they are outside the allowable range.","title":"Testing Selection"},{"location":"03_Selection/11_Performance_analysis/","text":"Performance Analysis* Note that while all three versions of our program work, Version 3 is the best because it is more efficient, and more readable. (Increased efficiency does not always go hand in hand with increased readability). The table below summarizes the relative numbers of comparison made by each of the versions. ----------------- ----------------- ----------------- ----------------- Number of comparison & logical operations Minimum Average Maximum Version 1 12 if/elifs @ 3 = 12 if/elifs @ 3 = 12 if/elifs @ 3 = 36 36 36 Version 2 3 (12 if/elifs @ 3 12 if/elifs @ 3 = )/2 = 18 36 Version 3 3 ((1 if @ 3) +\\ ((1 if @ 3) + (11 (11 if/elifs @ 1 if/ellifs @ 1 )) ))/2 = 7 = 14 ----------------- ----------------- ----------------- ----------------- Notes: We might be able to make the program even faster by by checking for the most likely grades first (e.g. C's first, then B's, then A's, then F's). This would minimize the number of tests that need to be done, but the resulting loss of readability might not be worth the performance gain. The table overstates the numbers of comparisons that will actually be made in some cases. The reason is that Python \"short circuits\" test expressions when it can. More on this later. This is a theoretical performance analysis in which we are estimating the expected performance. We will soon also be doing empirical or experimental performance analyses in which we measure actual performance rather than trusting to fallible predictions.","title":"Performance Analysis*"},{"location":"03_Selection/11_Performance_analysis/#performance-analysis","text":"Note that while all three versions of our program work, Version 3 is the best because it is more efficient, and more readable. (Increased efficiency does not always go hand in hand with increased readability). The table below summarizes the relative numbers of comparison made by each of the versions. ----------------- ----------------- ----------------- ----------------- Number of comparison & logical operations Minimum Average Maximum Version 1 12 if/elifs @ 3 = 12 if/elifs @ 3 = 12 if/elifs @ 3 = 36 36 36 Version 2 3 (12 if/elifs @ 3 12 if/elifs @ 3 = )/2 = 18 36 Version 3 3 ((1 if @ 3) +\\ ((1 if @ 3) + (11 (11 if/elifs @ 1 if/ellifs @ 1 )) ))/2 = 7 = 14 ----------------- ----------------- ----------------- ----------------- Notes: We might be able to make the program even faster by by checking for the most likely grades first (e.g. C's first, then B's, then A's, then F's). This would minimize the number of tests that need to be done, but the resulting loss of readability might not be worth the performance gain. The table overstates the numbers of comparisons that will actually be made in some cases. The reason is that Python \"short circuits\" test expressions when it can. More on this later. This is a theoretical performance analysis in which we are estimating the expected performance. We will soon also be doing empirical or experimental performance analyses in which we measure actual performance rather than trusting to fallible predictions.","title":"Performance Analysis*"},{"location":"03_Selection/12_A_final_very_small_example_Absolute_value/","text":"A Final (Very Small) Example: Absolute value For completeness we should consider the case where there is only one action to be performed, but it only needs to be performed some of the time. This arises, for example, when we need to make sure a value is positive. Suppose, for example, that we have a value in a program that should not be negative. If it is negative we want to make it positive. There are two possibilities, but only one of them requires any action: If the number is already positive, we don't have to do anything. But if the number is negative we have to negate it to remove the negative sign. The code to do this might look like: if value < 0: value = -value This code simply demonstrates that the else statement is optional and not a required element of selection.","title":"A Final (Very Small) Example: Absolute value"},{"location":"03_Selection/12_A_final_very_small_example_Absolute_value/#a-final-very-small-example-absolute-value","text":"For completeness we should consider the case where there is only one action to be performed, but it only needs to be performed some of the time. This arises, for example, when we need to make sure a value is positive. Suppose, for example, that we have a value in a program that should not be negative. If it is negative we want to make it positive. There are two possibilities, but only one of them requires any action: If the number is already positive, we don't have to do anything. But if the number is negative we have to negate it to remove the negative sign. The code to do this might look like: if value < 0: value = -value This code simply demonstrates that the else statement is optional and not a required element of selection.","title":"A Final (Very Small) Example: Absolute value"},{"location":"03_Selection/13_Summary_Selection_using_if/","text":"Summary: Selection using if We have seen three ways of using the if statement to_select_statements to execute. One possibility is that we have a statement (simple or compound) to execute conditionally. The construct to use is: if test-expression: true-statement A second possibility is that we want to select one of two statements to execute. In this case the construct is: if test-expression: true-statement else: false-statement The third possibility is that we want to select one of a number of mutually exclusive statements to execute. In this case the construct is: if test-expression: true-statement elif test-expression: true-statement ... else: false-statement with as many elif statements as required to cover all the possibilities, and the else statement usually reserved for catching errors (specifically invalid values).","title":"Summary: Selection using\u00a0if"},{"location":"03_Selection/13_Summary_Selection_using_if/#summary-selection-using-if","text":"We have seen three ways of using the if statement to_select_statements to execute. One possibility is that we have a statement (simple or compound) to execute conditionally. The construct to use is: if test-expression: true-statement A second possibility is that we want to select one of two statements to execute. In this case the construct is: if test-expression: true-statement else: false-statement The third possibility is that we want to select one of a number of mutually exclusive statements to execute. In this case the construct is: if test-expression: true-statement elif test-expression: true-statement ... else: false-statement with as many elif statements as required to cover all the possibilities, and the else statement usually reserved for catching errors (specifically invalid values).","title":"Summary: Selection using\u00a0if"},{"location":"03_Selection/14_Gazinta_As_in_2_gazinta_8_but_3_doesnt/","text":"Gazinta (as in \"2 Gazinta 8, but 3 doesn't\") Problem Write a program that accepts two numbers, and outputs a message telling the user whether the second number divides exactly into the first or not. What happens when you enter 0 for the second number? This is our first example of a runtime error. Add a test to this program to avoid the error condition. Sample runs: Wondering if one number \"goes into\" another? Give me the numbers (big one first) and I'll tell you. First number = 8 Second number = 2 2 does go into 8 exactly. Wondering if one number \"goes into\" another? Give me the numbers (big one first) and I'll tell you. First number = 8 Second number = 3 3 does NOT go into 8 exactly. Wondering if one number \"goes into\" another? Give me the numbers (big one first) and I'll tell you. First number = 8 Second number = 0 Sorry division by 0 is undefined! Solution","title":"Gazinta (as in \"2 Gazinta 8, but 3 doesn't\")"},{"location":"03_Selection/14_Gazinta_As_in_2_gazinta_8_but_3_doesnt/#gazinta-as-in-2-gazinta-8-but-3-doesnt","text":"Problem Write a program that accepts two numbers, and outputs a message telling the user whether the second number divides exactly into the first or not. What happens when you enter 0 for the second number? This is our first example of a runtime error. Add a test to this program to avoid the error condition. Sample runs: Wondering if one number \"goes into\" another? Give me the numbers (big one first) and I'll tell you. First number = 8 Second number = 2 2 does go into 8 exactly. Wondering if one number \"goes into\" another? Give me the numbers (big one first) and I'll tell you. First number = 8 Second number = 3 3 does NOT go into 8 exactly. Wondering if one number \"goes into\" another? Give me the numbers (big one first) and I'll tell you. First number = 8 Second number = 0 Sorry division by 0 is undefined!","title":"Gazinta (as in \"2 Gazinta 8, but 3 doesn't\")"},{"location":"03_Selection/14_Gazinta_As_in_2_gazinta_8_but_3_doesnt/#solution","text":"","title":"Solution"},{"location":"03_Selection/15_Ode_to_pythagoras/","text":"Ode to Pythagoras Problem: Write a program that accepts three integer values, and outputs a message stating whether they could be the sides of a right-angled triangle or not. (The relevant math is Pythagoras' theorem, and since it has come up: you cannot specify the order in which the values are to be entered). Sample runs: Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 3 Length of second side = 4 Length of third side = 5 That is a right-angled triangle. Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 3 Length of second side = 5 Length of third side = 4 That is a right-angled triangle. Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 3 Length of second side = 4 Length of third side = 6 That is NOT a right-angled triangle. Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 4 Length of second side = 4 Length of third side = 4 That is NOT a right-angled triangle. Solutions:","title":"Ode to Pythagoras"},{"location":"03_Selection/15_Ode_to_pythagoras/#ode-to-pythagoras","text":"","title":"Ode to Pythagoras"},{"location":"03_Selection/15_Ode_to_pythagoras/#problem","text":"Write a program that accepts three integer values, and outputs a message stating whether they could be the sides of a right-angled triangle or not. (The relevant math is Pythagoras' theorem, and since it has come up: you cannot specify the order in which the values are to be entered). Sample runs: Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 3 Length of second side = 4 Length of third side = 5 That is a right-angled triangle. Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 3 Length of second side = 5 Length of third side = 4 That is a right-angled triangle. Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 3 Length of second side = 4 Length of third side = 6 That is NOT a right-angled triangle. Enter the lengths of the sides of your triangle and I will tell you if it has a right angle or not. Length of first side = 4 Length of second side = 4 Length of third side = 4 That is NOT a right-angled triangle.","title":"Problem:"},{"location":"03_Selection/15_Ode_to_pythagoras/#solutions","text":"","title":"Solutions:"},{"location":"03_Selection/16_Utility_bills/","text":"Utility bills Problem: A utility company takes readings each month and charges its customers on the following basis. kWh Rate Under 500 $20.00 500 to 1000 $20.00 + $0.03 per kWh over 500 Over 1000 $35.00 + 0.02 per kWh above 1000 Write a program to calculate a customer's bill amount given the number of kilowatt-hours used. Sample runs: =============================== Bill calculator ------------------------------- Enter kilowatt-hours used: 300 Bill amount = $20.00 =============================== Bill calculator ------------------------------- Enter kilowatt-hours used: 600 Bill amount = $23.00 =============================== Bill calculator ------------------------------- Enter kilowatt-hours used: 1200 Bill amount = $39.00 Solution:","title":"Utility bills"},{"location":"03_Selection/16_Utility_bills/#utility-bills","text":"","title":"Utility bills"},{"location":"03_Selection/16_Utility_bills/#problem","text":"A utility company takes readings each month and charges its customers on the following basis. kWh Rate Under 500 $20.00 500 to 1000 $20.00 + $0.03 per kWh over 500 Over 1000 $35.00 + 0.02 per kWh above 1000 Write a program to calculate a customer's bill amount given the number of kilowatt-hours used. Sample runs: =============================== Bill calculator ------------------------------- Enter kilowatt-hours used: 300 Bill amount = $20.00 =============================== Bill calculator ------------------------------- Enter kilowatt-hours used: 600 Bill amount = $23.00 =============================== Bill calculator ------------------------------- Enter kilowatt-hours used: 1200 Bill amount = $39.00","title":"Problem:"},{"location":"03_Selection/16_Utility_bills/#solution","text":"","title":"Solution:"},{"location":"03_Selection/17_Beaufort_scale/","text":"Beaufort Scale Problem: Write a program that inputs the speed of the wind in miles/hour and outputs the corresponding Beaufort description, e.g. \"Gentle Breeze\", or \"Violent Storm\". You can find a table giving the Beaufort Scale Specifications at http://www.zetnet.co.uk/sigs/weather/Met_Codes/beaufort.htm Enter the wind speed in miles per hour (ideally measured 10 m off the ground): 52.8 A wind speed of 52.8 mph corresponds to Force 9 or \"Severe Gale\". Solution:","title":"Beaufort Scale"},{"location":"03_Selection/17_Beaufort_scale/#beaufort-scale","text":"","title":"Beaufort Scale"},{"location":"03_Selection/17_Beaufort_scale/#problem","text":"Write a program that inputs the speed of the wind in miles/hour and outputs the corresponding Beaufort description, e.g. \"Gentle Breeze\", or \"Violent Storm\". You can find a table giving the Beaufort Scale Specifications at http://www.zetnet.co.uk/sigs/weather/Met_Codes/beaufort.htm Enter the wind speed in miles per hour (ideally measured 10 m off the ground): 52.8 A wind speed of 52.8 mph corresponds to Force 9 or \"Severe Gale\".","title":"Problem:"},{"location":"03_Selection/17_Beaufort_scale/#solution","text":"","title":"Solution:"},{"location":"03_Selection/70_Exercise_sheet_2/","text":"Exercise Sheet 2 Figure out what each program will print if the input is the number -5 . a) num = int(input('Enter a number: ')) if num > 0: print(num) b) num = int(input('Enter a number: ')) if num % 2 == 0: print(num*2) else: print(num**2) c) num = int(input('Enter a number: ')) if num > 0 and num % 2 == 0: print(\"I'm positive it's even!\") elif num > 0: print(\"I'm positive it's odd!\") elif num == 0: print(\"Zip zero nada!\") elif num < 0 and num % 2 == 0: print(\"Even if it's negative?\") else: print(\"Even if it's odd?\") Fill in the rest of the truth table for the following logical expression ((A or B) and not C) . I\u2019ve made some extra columns so that you can work through it step by step. A B C not C A or B ((A or B) and not C) T T T F T F T T F T T T F T F T F F F T T F T F F F T F F F Write a program that takes a number from the user and prints the absolute value of that number (so if it is a negative number, it will switch it to a positive number before it prints). Write a program that gets an integer from the user. It should then print the number with the appropriate suffix (i.e. 552 would be 552nd . For example if the user entered the number 1, you would print 1st. You can use the modulo operator to figure out the appropriate suffix for each number. num % 10 == 1 will return True if the last digit is 1. For your first try ignore numbers that end in 11th, 12th, and 13th which are weird cases because they don\u2019t use 1st, 2nd, and 3rd. Below is the pseudocode. Get the number as input from the user Check to see if the number ends in a 1 print the number with 'st' at the end Otherwise check to see if the number ends in a 2 print the number with 'nd' at the end Otherwise check to see if the number ends in a 3 print the number with 'rd' at the end Otherwise print the number with 'th' at the end","title":"Exercise Sheet 2"},{"location":"03_Selection/70_Exercise_sheet_2/#exercise-sheet-2","text":"Figure out what each program will print if the input is the number -5 . a) num = int(input('Enter a number: ')) if num > 0: print(num) b) num = int(input('Enter a number: ')) if num % 2 == 0: print(num*2) else: print(num**2) c) num = int(input('Enter a number: ')) if num > 0 and num % 2 == 0: print(\"I'm positive it's even!\") elif num > 0: print(\"I'm positive it's odd!\") elif num == 0: print(\"Zip zero nada!\") elif num < 0 and num % 2 == 0: print(\"Even if it's negative?\") else: print(\"Even if it's odd?\") Fill in the rest of the truth table for the following logical expression ((A or B) and not C) . I\u2019ve made some extra columns so that you can work through it step by step. A B C not C A or B ((A or B) and not C) T T T F T F T T F T T T F T F T F F F T T F T F F F T F F F Write a program that takes a number from the user and prints the absolute value of that number (so if it is a negative number, it will switch it to a positive number before it prints). Write a program that gets an integer from the user. It should then print the number with the appropriate suffix (i.e. 552 would be 552nd . For example if the user entered the number 1, you would print 1st. You can use the modulo operator to figure out the appropriate suffix for each number. num % 10 == 1 will return True if the last digit is 1. For your first try ignore numbers that end in 11th, 12th, and 13th which are weird cases because they don\u2019t use 1st, 2nd, and 3rd. Below is the pseudocode. Get the number as input from the user Check to see if the number ends in a 1 print the number with 'st' at the end Otherwise check to see if the number ends in a 2 print the number with 'nd' at the end Otherwise check to see if the number ends in a 3 print the number with 'rd' at the end Otherwise print the number with 'th' at the end","title":"Exercise Sheet 2"},{"location":"03_Selection/90_Assignment_3/","text":"Assignment 3 Problems Is it a triangle? Write a program that accepts three numerical values and outputs a message indicating whether they could represent the lengths of the sides of a triangle or not. (Note: Not necessarily a right-angled triangle, just any triangle at all.) A sample run might look like this, ================= Is it a triangle? ----------------- Enter your first value: 4 Enter the second value: 9 Enter the third value: 3 I'm afraid those three numbers could NOT represent the lengths of the sides of a triangle. Is it an Armstrong number? An Armstrong number is an n digit number that is equal to the sum of its digits each raised to the n th power. For example 153 equals 1^3^+5^3^+3^3^, so it is an Armstrong number. Write a program that inputs a three-digit number, and outputs a message saying whether it is an Armstrong number or not. A sample run might look like this, ========================== Is it an Armstrong number? -------------------------- Enter your number: 284 I'm afraid 284 is NOT an Armstrong number. Hint You can pull apart a number to get its individual digits by dividing and modulo-ing by appropriate multiples of 10, e.g. num %10 will give you the 1s digit, i.e. the rightmost digit, and num/100 will give you the 100s digit, i.e. the leftmost digit. Richter Scale Write a program that inputs the Richter magnitude of an earthquake and outputs the corresponding description and typical effects according to the table* below. ----------------------- ----------------------- ----------------------- Richter\\ Description Earthquake Effects Magnitudes Less than 2.0 Micro Microearthquakes, not felt. 2.0-2.9 Minor Generally not felt, but recorded. 3.0-3.9 Often felt, but rarely causes damage. 4.0-4.9 Light Noticeable shaking of indoor items, rattling noises. Significant damage unlikely. 5.0-5.9 Moderate Can cause major damage to poorly constructed buildings over small regions. At most slight damage to well-designed buildings. 6.0-6.9 Strong Can be destructive in areas up to about 160 kilometres (100 mi) across in populated areas. 7.0-7.9 Major Can cause serious damage over larger areas. 8.0-8.9 Great Can cause serious damage in areas several hundred miles across. 9.0-9.9 Devastating in areas several thousand miles across. 10.0+ Epic Never recorded; see below for equivalent seismic energy yield. ----------------------- ----------------------- ----------------------- A sample run might look like this, ====================== Earthquake Interpreter ---------------------- Enter the Richter magnitude of the earthquake: 4.4 Magnitude: 4.4 Description: Light. Effects: Noticeable shaking of indoor items, rattling noises. Significant damage unlikely. Should I do Laundry? Write a program that gets the users age, whether they have clean clothes, and whether they know how to do laundry. From that data the program should tell the user if they need to do laundry based on the flow chart below. I\u2019d also like you to add one more question to the flow chart and think about how it might change the decision (something like smell or maybe accessibility issues). I\u2019ve also included a sample run (with just the base criteria). ``` Should you do Laundry? How old are you? 21 Do you have clean clothes (y or n)? n Do you know how to do laundry (y or n)? y Based on your answers it is time to do laundry! ``` Logistics Use the following naming scheme for your program files: a assignment# p problem# name.py . So your solution for problem 1 on this assignment will be named a3p1bob.py . based on one on the Wikipedia page on the Richter Scale . ** original source .","title":"Assignment 3"},{"location":"03_Selection/90_Assignment_3/#assignment-3","text":"","title":"Assignment 3"},{"location":"03_Selection/90_Assignment_3/#problems","text":"","title":"Problems"},{"location":"03_Selection/90_Assignment_3/#is-it-a-triangle","text":"Write a program that accepts three numerical values and outputs a message indicating whether they could represent the lengths of the sides of a triangle or not. (Note: Not necessarily a right-angled triangle, just any triangle at all.) A sample run might look like this, ================= Is it a triangle? ----------------- Enter your first value: 4 Enter the second value: 9 Enter the third value: 3 I'm afraid those three numbers could NOT represent the lengths of the sides of a triangle.","title":"Is it a triangle?"},{"location":"03_Selection/90_Assignment_3/#is-it-an-armstrong-number","text":"An Armstrong number is an n digit number that is equal to the sum of its digits each raised to the n th power. For example 153 equals 1^3^+5^3^+3^3^, so it is an Armstrong number. Write a program that inputs a three-digit number, and outputs a message saying whether it is an Armstrong number or not. A sample run might look like this, ========================== Is it an Armstrong number? -------------------------- Enter your number: 284 I'm afraid 284 is NOT an Armstrong number. Hint You can pull apart a number to get its individual digits by dividing and modulo-ing by appropriate multiples of 10, e.g. num %10 will give you the 1s digit, i.e. the rightmost digit, and num/100 will give you the 100s digit, i.e. the leftmost digit.","title":"Is it an Armstrong number?"},{"location":"03_Selection/90_Assignment_3/#richter-scale","text":"Write a program that inputs the Richter magnitude of an earthquake and outputs the corresponding description and typical effects according to the table* below. ----------------------- ----------------------- ----------------------- Richter\\ Description Earthquake Effects Magnitudes Less than 2.0 Micro Microearthquakes, not felt. 2.0-2.9 Minor Generally not felt, but recorded. 3.0-3.9 Often felt, but rarely causes damage. 4.0-4.9 Light Noticeable shaking of indoor items, rattling noises. Significant damage unlikely. 5.0-5.9 Moderate Can cause major damage to poorly constructed buildings over small regions. At most slight damage to well-designed buildings. 6.0-6.9 Strong Can be destructive in areas up to about 160 kilometres (100 mi) across in populated areas. 7.0-7.9 Major Can cause serious damage over larger areas. 8.0-8.9 Great Can cause serious damage in areas several hundred miles across. 9.0-9.9 Devastating in areas several thousand miles across. 10.0+ Epic Never recorded; see below for equivalent seismic energy yield. ----------------------- ----------------------- ----------------------- A sample run might look like this, ====================== Earthquake Interpreter ---------------------- Enter the Richter magnitude of the earthquake: 4.4 Magnitude: 4.4 Description: Light. Effects: Noticeable shaking of indoor items, rattling noises. Significant damage unlikely.","title":"Richter Scale"},{"location":"03_Selection/90_Assignment_3/#should-i-do-laundry","text":"Write a program that gets the users age, whether they have clean clothes, and whether they know how to do laundry. From that data the program should tell the user if they need to do laundry based on the flow chart below. I\u2019d also like you to add one more question to the flow chart and think about how it might change the decision (something like smell or maybe accessibility issues). I\u2019ve also included a sample run (with just the base criteria).","title":"Should I do Laundry?"},{"location":"03_Selection/90_Assignment_3/#_1","text":"","title":"```"},{"location":"03_Selection/90_Assignment_3/#should-you-do-laundry","text":"How old are you? 21 Do you have clean clothes (y or n)? n Do you know how to do laundry (y or n)? y Based on your answers it is time to do laundry! ```","title":"Should you do Laundry?"},{"location":"03_Selection/90_Assignment_3/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem# name.py . So your solution for problem 1 on this assignment will be named a3p1bob.py . based on one on the Wikipedia page on the Richter Scale . ** original source .","title":"Logistics"},{"location":"04_Repetition/","text":"Introduction: Repetition, repetition, repetition \ud83d\udd01 So far we've covered 5 of the 6 essential constructs: input , processing , output , sequence , and selection . This module will cover the final construct, repetition . With repetition added to your toolbox you will be able to express any computational algorithm. Repetition is just the ability to say \u201cDo this a bunch of times\u201d without having to write the actual code out several times. This is merely a convenience when the number of times is 2 or 3, but an absolute necessity when the number of times is, say, a few million. Repetition constructs are needed because many algorithms involve performing an action not just once, but repeatedly while some condition holds. Repetition comes in a couple of flavours. First, there are those cases where we want to keep repeating an action while some condition is true. For example keeping the water flowing while the humidity is less than 60%. Second are those cases where we can calculate exactly how many times we will need to repeat the action. For example: there are 8 customers in the line so I will need to \"sell ticket\" eight times. Python provides the while statement for the first type of repetition, and the for statement to handle the second type. The core skill to develop in this module is to be able to use the while and for statements in your programs. A secondary topic will be the process of writing a program by moving from an English description, to a pseudocode description, and on to a Python program. The idea: Go back up and repeat some code The flowchart The syntax Hihihi! Infinite Loops Validating Input Repeating a program (without restarting it) Problem: Repeating calculations Example: Find the average Sentinel controlled input Problem: The guessing game Aside: Getting \"random\" numbers Solution: The Guessing Game A puzzle: What output does this produce? Nesting loops Python's other repetition structure: for loops Completely artificial example revisited: using for for vs while f2c revisited: Fahrenheit to Celsius conversion table using for Nesting for loops Example: Draw a square Module 4 Summary Brute Force Simulation Problem: What are the chances: four children, all girls? Duelling Incompetents Factors Cryptarithms Python Formatting Guidelines A list-creating function: range() Timing programs Exercise sheet 3 Assignment 4","title":"Introduction: Repetition, repetition, repetition \ud83d\udd01"},{"location":"04_Repetition/#introduction-repetition-repetition-repetition","text":"So far we've covered 5 of the 6 essential constructs: input , processing , output , sequence , and selection . This module will cover the final construct, repetition . With repetition added to your toolbox you will be able to express any computational algorithm. Repetition is just the ability to say \u201cDo this a bunch of times\u201d without having to write the actual code out several times. This is merely a convenience when the number of times is 2 or 3, but an absolute necessity when the number of times is, say, a few million. Repetition constructs are needed because many algorithms involve performing an action not just once, but repeatedly while some condition holds. Repetition comes in a couple of flavours. First, there are those cases where we want to keep repeating an action while some condition is true. For example keeping the water flowing while the humidity is less than 60%. Second are those cases where we can calculate exactly how many times we will need to repeat the action. For example: there are 8 customers in the line so I will need to \"sell ticket\" eight times. Python provides the while statement for the first type of repetition, and the for statement to handle the second type. The core skill to develop in this module is to be able to use the while and for statements in your programs. A secondary topic will be the process of writing a program by moving from an English description, to a pseudocode description, and on to a Python program. The idea: Go back up and repeat some code The flowchart The syntax Hihihi! Infinite Loops Validating Input Repeating a program (without restarting it) Problem: Repeating calculations Example: Find the average Sentinel controlled input Problem: The guessing game Aside: Getting \"random\" numbers Solution: The Guessing Game A puzzle: What output does this produce? Nesting loops Python's other repetition structure: for loops Completely artificial example revisited: using for for vs while f2c revisited: Fahrenheit to Celsius conversion table using for Nesting for loops Example: Draw a square Module 4 Summary Brute Force Simulation Problem: What are the chances: four children, all girls? Duelling Incompetents Factors Cryptarithms Python Formatting Guidelines A list-creating function: range() Timing programs Exercise sheet 3 Assignment 4","title":"Introduction: Repetition, repetition, repetition \ud83d\udd01"},{"location":"04_Repetition/01_The_idea_go_back_up_and_repeat_some_code/","text":"The idea: Go back up and repeat some code Until now our programs have been strictly sequential executing from top to bottom. With the if statement we were able to select some statements to execute and others to skip, but execution still flowed from top to bottom. However some processing requires us to go back up in a program to repeat sections of code a second time (or a third and and a fourth and so on). Think back to this bit of code from the previous module: It instructs the user to enter a grade to convert and then had a long section testing the entered value to calculate the corresponding letter grade. We discovered that between the input and selection we needed to test the grade to ensure it was valid. If it was invalid we were able to avoid processing it and producing mistaken output, and even to explain their error to the user, but we were not able to give them the chance to reenter the value. What we need is some way to go back up and give them a second chance as shown by the red arrow below. So far though we don't have a statement or construct that lets us \"go back up\" if the grade is invalid and repeat the execution of some code. This is what repetition constructs enable us to do: to repeat code as many times as necessary.","title":"The idea: Go back up and repeat some code"},{"location":"04_Repetition/01_The_idea_go_back_up_and_repeat_some_code/#the-idea-go-back-up-and-repeat-some-code","text":"Until now our programs have been strictly sequential executing from top to bottom. With the if statement we were able to select some statements to execute and others to skip, but execution still flowed from top to bottom. However some processing requires us to go back up in a program to repeat sections of code a second time (or a third and and a fourth and so on). Think back to this bit of code from the previous module: It instructs the user to enter a grade to convert and then had a long section testing the entered value to calculate the corresponding letter grade. We discovered that between the input and selection we needed to test the grade to ensure it was valid. If it was invalid we were able to avoid processing it and producing mistaken output, and even to explain their error to the user, but we were not able to give them the chance to reenter the value. What we need is some way to go back up and give them a second chance as shown by the red arrow below. So far though we don't have a statement or construct that lets us \"go back up\" if the grade is invalid and repeat the execution of some code. This is what repetition constructs enable us to do: to repeat code as many times as necessary.","title":"The idea: Go back up and repeat some code"},{"location":"04_Repetition/02_The_flowchart/","text":"The flowchart Here's what the flowchart for a repetitive construct looks like, Remember that in a flowchart you move along the lines in the direction of the arrows. So in this flowchart we enter and begin at the test expression which we evaluate. The test expression will be the same kind of relational expression we used in if statements earlier. If the expression evaluates to True we execute the statement, and then return to the text expression and reevaluate it. If it is still True we execute the statement again and return yet again to the test expression. This looping continues as long as the text expression remains True . But as soon as the test expression is False the statement is skipped and execution continues below it in the program. N.B. the statement need not be a simple statement, it may be a compound statement consisting of many simple statements including other repetition constructs.","title":"The flowchart"},{"location":"04_Repetition/02_The_flowchart/#the-flowchart","text":"Here's what the flowchart for a repetitive construct looks like, Remember that in a flowchart you move along the lines in the direction of the arrows. So in this flowchart we enter and begin at the test expression which we evaluate. The test expression will be the same kind of relational expression we used in if statements earlier. If the expression evaluates to True we execute the statement, and then return to the text expression and reevaluate it. If it is still True we execute the statement again and return yet again to the test expression. This looping continues as long as the text expression remains True . But as soon as the test expression is False the statement is skipped and execution continues below it in the program. N.B. the statement need not be a simple statement, it may be a compound statement consisting of many simple statements including other repetition constructs.","title":"The flowchart"},{"location":"04_Repetition/03_The_syntax/","text":"The syntax Python provides two repetition statements, while and for . We will consider while first. The syntax for the while statement is, while test-expression : statement Or, in words, the while statement consists of the keyword while followed by a test expression, terminated by a colon, followed by a statement (simple or compound) that will be executed as long as the text expression is True . Note that the statement(s) following while must be indented.","title":"The syntax"},{"location":"04_Repetition/03_The_syntax/#the-syntax","text":"Python provides two repetition statements, while and for . We will consider while first. The syntax for the while statement is, while test-expression : statement Or, in words, the while statement consists of the keyword while followed by a test expression, terminated by a colon, followed by a statement (simple or compound) that will be executed as long as the text expression is True . Note that the statement(s) following while must be indented.","title":"The syntax"},{"location":"04_Repetition/04_Hihihi/","text":"Hihihi! This code will go through the loop 3 times. Each time it will print Hi! and add 1 to the value stored in i . When i becomes 4 it will not enter the loop body and the program will end.","title":"Hihihi!"},{"location":"04_Repetition/04_Hihihi/#hihihi","text":"This code will go through the loop 3 times. Each time it will print Hi! and add 1 to the value stored in i . When i becomes 4 it will not enter the loop body and the program will end.","title":"Hihihi!"},{"location":"04_Repetition/05_Infinite_loops/","text":"Infinite Loops This code looks very similar, but instead of printing Hi! 3 times it will go on printing it forever. That is because the value in i is never updated so the i <= 3 condition will always evaluate to True .","title":"Infinite Loops"},{"location":"04_Repetition/05_Infinite_loops/#infinite-loops","text":"This code looks very similar, but instead of printing Hi! 3 times it will go on printing it forever. That is because the value in i is never updated so the i <= 3 condition will always evaluate to True .","title":"Infinite Loops"},{"location":"04_Repetition/06_Validating_input/","text":"Validating Input However clear we make our program's instructions users will always find ways to make mistakes. To avoid using inappropriate data that might crash our program we should validate the data that is input. The while statement is perfect for this job: Extension challenge: How would you modify this code to give the user at most 3 chances to enter acceptable data?","title":"Validating Input"},{"location":"04_Repetition/06_Validating_input/#validating-input","text":"However clear we make our program's instructions users will always find ways to make mistakes. To avoid using inappropriate data that might crash our program we should validate the data that is input. The while statement is perfect for this job: Extension challenge: How would you modify this code to give the user at most 3 chances to enter acceptable data?","title":"Validating Input"},{"location":"04_Repetition/07_Repeating_a_program_without_restarting_it/","text":"Repeating a program (without restarting it) One practical thing the while statement enables you to do is to allow your users to rerun a program without having to restart it, so they can for example perform a series of conversions without having to restart the program. The template to do this is, The trick is that we use a variable called again which we initialize to be the letter y . We then test the value of again to see if it is either y or Y . Obviously this test succeeds the first time because we have just initialized the value of again in the line above. But, at the bottom of the while loop we have an input statement where we read in a response from the user to a query about whether they would like to repeat the program. Once they enter their value, control goes back up to the while statement where their input is tested. If they entered a y or a Y the body of the loop is repeated, but if they entered anything else the body is skipped, the message Bye now. is displayed, and the program terminates. An example Here is an example of this template being put to work to allow the user to carry out multiple f2c conversions during one run of a program,","title":"Repeating a program (without restarting it)"},{"location":"04_Repetition/07_Repeating_a_program_without_restarting_it/#repeating-a-program-without-restarting-it","text":"One practical thing the while statement enables you to do is to allow your users to rerun a program without having to restart it, so they can for example perform a series of conversions without having to restart the program. The template to do this is, The trick is that we use a variable called again which we initialize to be the letter y . We then test the value of again to see if it is either y or Y . Obviously this test succeeds the first time because we have just initialized the value of again in the line above. But, at the bottom of the while loop we have an input statement where we read in a response from the user to a query about whether they would like to repeat the program. Once they enter their value, control goes back up to the while statement where their input is tested. If they entered a y or a Y the body of the loop is repeated, but if they entered anything else the body is skipped, the message Bye now. is displayed, and the program terminates.","title":"Repeating a program (without restarting it)"},{"location":"04_Repetition/07_Repeating_a_program_without_restarting_it/#an-example","text":"Here is an example of this template being put to work to allow the user to carry out multiple f2c conversions during one run of a program,","title":"An example"},{"location":"04_Repetition/08_Problem_repeating_calculations/","text":"Problem: Repeating calculations What if instead of converting one temperature from Fahrenheit to Celsius we wish to calculate a number of conversions and display a conversion table? For example: Fahrenheit Celsius 0 -18 10 -13 20 -7 30 -2 40 4 50 10 60 15 70 21 80 26 90 32 100 37 Solution: Note the string formatting I used to make the table display cleanly.","title":"Problem: Repeating calculations"},{"location":"04_Repetition/08_Problem_repeating_calculations/#problem-repeating-calculations","text":"What if instead of converting one temperature from Fahrenheit to Celsius we wish to calculate a number of conversions and display a conversion table? For example: Fahrenheit Celsius 0 -18 10 -13 20 -7 30 -2 40 4 50 10 60 15 70 21 80 26 90 32 100 37","title":"Problem: Repeating calculations"},{"location":"04_Repetition/08_Problem_repeating_calculations/#solution","text":"Note the string formatting I used to make the table display cleanly.","title":"Solution:"},{"location":"04_Repetition/09_Example_Find_the_average/","text":"Example: Find the average Write a program that can be used to find the average of a set of numbers. Solution","title":"Example: Find the average"},{"location":"04_Repetition/09_Example_Find_the_average/#example-find-the-average","text":"Write a program that can be used to find the average of a set of numbers.","title":"Example: Find the average"},{"location":"04_Repetition/09_Example_Find_the_average/#solution","text":"","title":"Solution"},{"location":"04_Repetition/10_Sentinel_controlled_input/","text":"Sentinel controlled input The previous program asked the user after each data value they input if they wanted to input another. This gets tiresome for the user who may have a long list of numbers they want to type in as quickly as possible. Instead of asking after each value is input we could have them enter a special value, called a sentinel, to indicate the end of their data. Here's a program that uses -999 as a sentinel to indicate the end of the user input. Extension challenge: But what if the number -999 occurs in the user's data set? Then our program will end prematurely. How could the program be modified to let the user enter the sentinel value before they begin entering their data?","title":"Sentinel controlled input"},{"location":"04_Repetition/10_Sentinel_controlled_input/#sentinel-controlled-input","text":"The previous program asked the user after each data value they input if they wanted to input another. This gets tiresome for the user who may have a long list of numbers they want to type in as quickly as possible. Instead of asking after each value is input we could have them enter a special value, called a sentinel, to indicate the end of their data. Here's a program that uses -999 as a sentinel to indicate the end of the user input. Extension challenge: But what if the number -999 occurs in the user's data set? Then our program will end prematurely. How could the program be modified to let the user enter the sentinel value before they begin entering their data?","title":"Sentinel controlled input"},{"location":"04_Repetition/11_Problem_The_guessing_game/","text":"Problem: The guessing game There is a guessing game children are fond of in which one player chooses a number between 1 and 100 and the other player must guess it. The only feedback given the guesser is whether their most recent guess was too high or too low. The game ends when the number has been guessed. If a long car ride is involved then the players might keep track of how many guesses they have taken over a number of games. Write a program that 'plays' this game by picking a number and then accepting guesses about the number's value. After each guess it should inform the user if the guess was too high or too low. The game should end when the number is guessed, at which point the computer should display the number of guesses taken.","title":"Problem: The guessing game"},{"location":"04_Repetition/11_Problem_The_guessing_game/#problem-the-guessing-game","text":"There is a guessing game children are fond of in which one player chooses a number between 1 and 100 and the other player must guess it. The only feedback given the guesser is whether their most recent guess was too high or too low. The game ends when the number has been guessed. If a long car ride is involved then the players might keep track of how many guesses they have taken over a number of games. Write a program that 'plays' this game by picking a number and then accepting guesses about the number's value. After each guess it should inform the user if the guess was too high or too low. The game should end when the number is guessed, at which point the computer should display the number of guesses taken.","title":"Problem: The guessing game"},{"location":"04_Repetition/12_Aside_Getting_random_numbers/","text":"Aside: Getting \"random\" numbers If you thought for a moment after reading the game description you might have wondered how the computer was going to pick the number to be guessed. The answer is that the computer needs some random or pseudorandom method for choosing that number. I say pseudorandom because computers are not random machines, they are deterministic machines so they can't generate something truly random unless they get access to the output of some random physical process. They can however generate numbers that seem unpredictable and so appear random even though they are being generated programmatically. Python makes this easy by providing a module we can import that hides the messy details, e.g. import random print(random.randint(1,100)) The module is named random and one of its members is randint which returns a random number in the specified range. Exercise : Try entering the lines above into a program file and running it several times. Most times you will get new numbers. ('Most' because since it is random you may get the same number twice in a row, but since there are 100 possibilities that is unlikely.) Exercise : Does randint generate numbers between 1 and 100 or from 1 to 100 including 1 and 100? You can find out either by looking it up, or by writing a very small program and watching its output. Jargon : If the range includes the endpoints, e.g. 1 and 100 above, we say it is an inclusive range. If it doesn't, we say it is an exclusive range.","title":"Aside: Getting \"random\" numbers"},{"location":"04_Repetition/12_Aside_Getting_random_numbers/#aside-getting-random-numbers","text":"If you thought for a moment after reading the game description you might have wondered how the computer was going to pick the number to be guessed. The answer is that the computer needs some random or pseudorandom method for choosing that number. I say pseudorandom because computers are not random machines, they are deterministic machines so they can't generate something truly random unless they get access to the output of some random physical process. They can however generate numbers that seem unpredictable and so appear random even though they are being generated programmatically. Python makes this easy by providing a module we can import that hides the messy details, e.g. import random print(random.randint(1,100)) The module is named random and one of its members is randint which returns a random number in the specified range. Exercise : Try entering the lines above into a program file and running it several times. Most times you will get new numbers. ('Most' because since it is random you may get the same number twice in a row, but since there are 100 possibilities that is unlikely.) Exercise : Does randint generate numbers between 1 and 100 or from 1 to 100 including 1 and 100? You can find out either by looking it up, or by writing a very small program and watching its output. Jargon : If the range includes the endpoints, e.g. 1 and 100 above, we say it is an inclusive range. If it doesn't, we say it is an exclusive range.","title":"Aside: Getting \"random\" numbers"},{"location":"04_Repetition/13_Solution_The_guessing_game/","text":"Solution: The Guessing Game Here's a bare-bones solution to the Guessing Game problem.","title":"Solution: The Guessing Game"},{"location":"04_Repetition/13_Solution_The_guessing_game/#solution-the-guessing-game","text":"Here's a bare-bones solution to the Guessing Game problem.","title":"Solution: The Guessing Game"},{"location":"04_Repetition/14_A_puzzle_What_output_does_this_produce/","text":"A puzzle: What output does this produce? You can \"play computer\" to find out, or you can type it in and run it. While running it is the sure way to find out, it will deprive you of the practice of \"playing computer\" which is the essential skill for debugging.","title":"A puzzle: What output does this produce?"},{"location":"04_Repetition/14_A_puzzle_What_output_does_this_produce/#a-puzzle-what-output-does-this-produce","text":"You can \"play computer\" to find out, or you can type it in and run it. While running it is the sure way to find out, it will deprive you of the practice of \"playing computer\" which is the essential skill for debugging.","title":"A puzzle: What output does this produce?"},{"location":"04_Repetition/15_Nesting_loops/","text":"Nesting loops This code is an example of nested loops: The general pattern here is, while test1 : while test2 : statement The key thing to be aware of is that the inner while loop (the one with test2 does all of its iterations for each of the iterations of the outer while loop (the one with test1 ). Note that there is no limitation that stops us at two while loops. For example it is quite common in image processing operations to have four nested loops. An outer pair that is responsible for considering each pixel in the image, and an inner pair that processes that pixel in the context of its neighbouring pixels.","title":"Nesting loops"},{"location":"04_Repetition/15_Nesting_loops/#nesting-loops","text":"This code is an example of nested loops: The general pattern here is, while test1 : while test2 : statement The key thing to be aware of is that the inner while loop (the one with test2 does all of its iterations for each of the iterations of the outer while loop (the one with test1 ). Note that there is no limitation that stops us at two while loops. For example it is quite common in image processing operations to have four nested loops. An outer pair that is responsible for considering each pixel in the image, and an inner pair that processes that pixel in the context of its neighbouring pixels.","title":"Nesting loops"},{"location":"04_Repetition/16_Pythons_other_repetition_structure_for_loops/","text":"Python's other repetition structure: for loops As an early page in this module mentioned, Python provides a pair of repetition constructs. In addition to while Python provides the for statement. Its syntax is brief, for item in sequence : statement We read the statement above as saying \u201cfor each item in this sequence execute the following statement\u201d. As with the while loop statement may a single simple statement or a multipart compound statement.","title":"Python's other repetition structure:\u00a0for\u00a0loops"},{"location":"04_Repetition/16_Pythons_other_repetition_structure_for_loops/#pythons-other-repetition-structure-for-loops","text":"As an early page in this module mentioned, Python provides a pair of repetition constructs. In addition to while Python provides the for statement. Its syntax is brief, for item in sequence : statement We read the statement above as saying \u201cfor each item in this sequence execute the following statement\u201d. As with the while loop statement may a single simple statement or a multipart compound statement.","title":"Python's other repetition structure:\u00a0for\u00a0loops"},{"location":"04_Repetition/17_Completely_artificial_example_revisited_using_for/","text":"Completely artificial example revisited: using for Just for comparison, here's how we could use for to display Hi! three times:","title":"Completely artificial example revisited: using for"},{"location":"04_Repetition/17_Completely_artificial_example_revisited_using_for/#completely-artificial-example-revisited-using-for","text":"Just for comparison, here's how we could use for to display Hi! three times:","title":"Completely artificial example revisited: using for"},{"location":"04_Repetition/18_For_vs_while/","text":"for vs while Just for reference here are the two implementations of our artificial Hi! Hi! Hi! example. Using a for statement, And using a while statement, Since the for statement version is more compact and reads more naturally you might wonder why while loops are ever used. The answer is that not all repetitions can be naturally represented using a for loop. Remember that the essential nature of a for loop is \u201cfor every item in this sequence do this\u201d. If that is the pattern of your computation then it is the logical and elegant choice, but many other repetitive forms of processing do not fit this pattern and for those we turn to the more general and flexible while statement.","title":"for\u00a0vs\u00a0while"},{"location":"04_Repetition/18_For_vs_while/#for-vs-while","text":"Just for reference here are the two implementations of our artificial Hi! Hi! Hi! example. Using a for statement, And using a while statement, Since the for statement version is more compact and reads more naturally you might wonder why while loops are ever used. The answer is that not all repetitions can be naturally represented using a for loop. Remember that the essential nature of a for loop is \u201cfor every item in this sequence do this\u201d. If that is the pattern of your computation then it is the logical and elegant choice, but many other repetitive forms of processing do not fit this pattern and for those we turn to the more general and flexible while statement.","title":"for\u00a0vs\u00a0while"},{"location":"04_Repetition/19_F2c_revisited_Fahrenheit_to_celsius_conversion_table_using_for/","text":"f2c revisited: Fahrenheit to Celsius conversion table using for And as another comparison here's how we could implement a table of temperature conversions using for .","title":"f2c revisited: Fahrenheit to Celsius conversion table using\u00a0for"},{"location":"04_Repetition/19_F2c_revisited_Fahrenheit_to_celsius_conversion_table_using_for/#f2c-revisited-fahrenheit-to-celsius-conversion-table-using-for","text":"And as another comparison here's how we could implement a table of temperature conversions using for .","title":"f2c revisited: Fahrenheit to Celsius conversion table using\u00a0for"},{"location":"04_Repetition/20_Nesting_for_loops/","text":"Nesting for loops One advantage of for loops over while loops is that their notation is more compact. This is especially helpful when we are nesting loops since there are fewer pieces of code to keep track of. Let's rewrite our rectangle drawing code using for loops.","title":"Nesting\u00a0for\u00a0loops"},{"location":"04_Repetition/20_Nesting_for_loops/#nesting-for-loops","text":"One advantage of for loops over while loops is that their notation is more compact. This is especially helpful when we are nesting loops since there are fewer pieces of code to keep track of. Let's rewrite our rectangle drawing code using for loops.","title":"Nesting\u00a0for\u00a0loops"},{"location":"04_Repetition/21_Example_Draw_a_square/","text":"Example: Draw a square Write a program that reads in the size of a square and a character and then prints out a hollow square of that size using the specified character and blanks. Your program should work for squares of all sizes from 1 to 20 inclusive. Here is a sample run of the program, What size square? 5 What character? * ***** * * * * * * ***** Solutions: This next one takes quite a different approach. If you can't tell what it is from the code, ask for an explanation. And here's one to wet your appetite. It does the job in one line(!) by making use of some string operations.","title":"Example: Draw a square"},{"location":"04_Repetition/21_Example_Draw_a_square/#example-draw-a-square","text":"Write a program that reads in the size of a square and a character and then prints out a hollow square of that size using the specified character and blanks. Your program should work for squares of all sizes from 1 to 20 inclusive. Here is a sample run of the program, What size square? 5 What character? * ***** * * * * * * *****","title":"Example: Draw a square"},{"location":"04_Repetition/21_Example_Draw_a_square/#solutions","text":"This next one takes quite a different approach. If you can't tell what it is from the code, ask for an explanation. And here's one to wet your appetite. It does the job in one line(!) by making use of some string operations.","title":"Solutions:"},{"location":"04_Repetition/22_Module_4_summary/","text":"Module 4 Summary Repetition structures: while : while test-expression : statement for : for item in sequence : statement","title":"Module 4 Summary"},{"location":"04_Repetition/22_Module_4_summary/#module-4-summary","text":"Repetition structures: while : while test-expression : statement for : for item in sequence : statement","title":"Module 4 Summary"},{"location":"04_Repetition/23_Brute_force/","text":"Brute Force When in doubt, use brute force. \u2014 Ken Thompson, Bell Labs Thompson's advice has two aspects. The first is that some problems that are difficult for humans to solve because we are not quick at processing and are unreliable when doing repetitive operations, are easy for computers to solve because those weaknesses of ours are their strengths. In this sense he is advising us to play to the computer's strengths. The second sense is that often we try to be too clever when solving problems and to overthink our solutions when simple brute force could get the job done. We'll look at a few types of problems in this module that lend themselves to brute force solutions. The first are simulations where we have the computer painstakingly model some process step-by-step, and do so not just once but many times so that we can estimate the likelihood of various outcomes. The second are in some sense purely computational problems that arise in numerical processing, e.g. in cryptography. We will begin just by searching for certain kinds of numbers. Since there may be a lot of numbers to consider and each one requires some computation, this is well suited to repetitive computer processing. Long before sudoku, newspapers featured various mental puzzles, one type of which were known as cryptarithms. These can be solved by brute force, but there can be so many possible solutions to consider that refining our brute force approach is necessary.","title":"Brute Force"},{"location":"04_Repetition/23_Brute_force/#brute-force","text":"When in doubt, use brute force. \u2014 Ken Thompson, Bell Labs Thompson's advice has two aspects. The first is that some problems that are difficult for humans to solve because we are not quick at processing and are unreliable when doing repetitive operations, are easy for computers to solve because those weaknesses of ours are their strengths. In this sense he is advising us to play to the computer's strengths. The second sense is that often we try to be too clever when solving problems and to overthink our solutions when simple brute force could get the job done. We'll look at a few types of problems in this module that lend themselves to brute force solutions. The first are simulations where we have the computer painstakingly model some process step-by-step, and do so not just once but many times so that we can estimate the likelihood of various outcomes. The second are in some sense purely computational problems that arise in numerical processing, e.g. in cryptography. We will begin just by searching for certain kinds of numbers. Since there may be a lot of numbers to consider and each one requires some computation, this is well suited to repetitive computer processing. Long before sudoku, newspapers featured various mental puzzles, one type of which were known as cryptarithms. These can be solved by brute force, but there can be so many possible solutions to consider that refining our brute force approach is necessary.","title":"Brute Force"},{"location":"04_Repetition/24_Simulation/","text":"Simulation In a simulation problem we write a program that simulates a real-world process, relying on our ability to generate random numbers to take account of the uncertainty of real-world processes like whether newborns are girls or boys, how long it will take to unload an airplane, the chances a vehicle will turn left or right or go straight. If we do this enough times we can make a reliable estimate of the probability of some event occurring. Because we are usually simulating to find out what will happen only because we don't already know what will actually happen they are notoriously difficult to test. Unlike a conversion program where we know some correct values we can use to test our program, in a simulation correct values can be hard to find. Consider for example models of climate change. They make quite different predictions so they can't all be right, and the only sure test is to wait 5, 10 or 50 years to find out which one is right. As with so many topics you can read more at Wikipedia if you're interested.","title":"Simulation"},{"location":"04_Repetition/24_Simulation/#simulation","text":"In a simulation problem we write a program that simulates a real-world process, relying on our ability to generate random numbers to take account of the uncertainty of real-world processes like whether newborns are girls or boys, how long it will take to unload an airplane, the chances a vehicle will turn left or right or go straight. If we do this enough times we can make a reliable estimate of the probability of some event occurring. Because we are usually simulating to find out what will happen only because we don't already know what will actually happen they are notoriously difficult to test. Unlike a conversion program where we know some correct values we can use to test our program, in a simulation correct values can be hard to find. Consider for example models of climate change. They make quite different predictions so they can't all be right, and the only sure test is to wait 5, 10 or 50 years to find out which one is right. As with so many topics you can read more at Wikipedia if you're interested.","title":"Simulation"},{"location":"04_Repetition/25_Problem_What_are_the_chances_four_children_all_girls/","text":"Problem: What are the chances: four children, all girls? Write a simulation program that estimates the percentage of 4-child families in which all the children are girls by simulating the formation of 1000 four-child families. Assume that the chances of a newborn being a girl or a boy are equal. A sample run of the program might look like this: In 1,000 simulated four-child families approximately 7% were made up of four daughters. Solution","title":"Problem: What are the chances: four children, all girls?"},{"location":"04_Repetition/25_Problem_What_are_the_chances_four_children_all_girls/#problem-what-are-the-chances-four-children-all-girls","text":"Write a simulation program that estimates the percentage of 4-child families in which all the children are girls by simulating the formation of 1000 four-child families. Assume that the chances of a newborn being a girl or a boy are equal. A sample run of the program might look like this: In 1,000 simulated four-child families approximately 7% were made up of four daughters.","title":"Problem: What are the chances: four children, all girls?"},{"location":"04_Repetition/25_Problem_What_are_the_chances_four_children_all_girls/#solution","text":"","title":"Solution"},{"location":"04_Repetition/26_Duelling_incompetents/","text":"Duelling Incompetents The problem Write a program to model the following peculiar duel (the names have been changed to protect the parties involved). A and B have quarelled and are going to settle their differences by duelling with pistols. Not only are A and B touchy, neither is a very good shot. A hits what he shoots at on average once every two tries. B is even worse, hitting what he shoots at once every three tries. Being a gentleman A allows B to fire first. The duel continues until one of them is hit. Your program should determine who is most likely to win the duel, by simulating many duels between A and B. It should output the percentage of duels won by A and the percentage won by B. Getting to the Solution Approach: We'll write this program from the inside out. Starting from the most specific event and working outward to a full program. B Shoots The duel begins with B taking a shot at A. He can either hit or miss A. The chances that he hits A are 1 in 3. The chances that he misses are 2 in 3. import random # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") else: print(\"B misses A. The duel continues.\") A Shoots If B hits A then the duel ends, but if he misses the duel will continue. The duel continues by A taking a shot at B. This code is similar to B taking a shot at A, but the odds are different because A is a better shot. We put the code for A's shot into the else branch of the if above, since A only gets to shoot if B misses. import random # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") else: print(\"B misses A. The duel continues.\") if random.randint(0, 1) == 1: print(\"A hits B. The duel's over.\") else: print(\"A misses B. The duel continues.\") One Complete Duel Now if A hits B the duel is over, but if A misses the duel continues with B taking a shot. We could copy our B shooting code and add it in the second else branch above, but we could have to do that a lot, since the duel could, in principle, take an infinite number of rounds to complete. A simpler approach is to place the code above inside a while loop: import random while ?: # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") else: print(\"B misses A. The duel continues.\") if random.randint(0, 1) == 1: print(\"A hits B. The duel's over.\") else: print(\"A misses B. The duel continues.\") The question is what the while condition should be. We want to say, \u201cwhile the duel is not over, they keep shooting at each other\u201d and Python lets us come very close to writing this: import random over = False while not over: # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") over = True else: print(\"B misses A. The duel continues.\") if random.randint(0, 1) == 1: print(\"A hits B. The duel's over.\") over = True else: print(\"A misses B. The duel continues.\") We declare a variable called over to hold the state of the duel. It's value is False when the duel is not over, and True when the duel is over. We initialize it to be False (since before they have shot at each other the duel can't be over). We update its value to True when one antagonist hits the other. The loop lets them keep taking turns shooting at each other until one finally hits the other. This code successfully models a duel: run it and see. Many Duels We are making progress but we are not done because the original problem wanted us to simulate many duels and display the percentage of duels won by each antagonist. To simulate many duels we pack all the code above (except for the import ) into a for loop, and record, using counters, the number of duels each antagonist wins. import random awins = 0 bwins = 0 for duel in range(0, 100): # See Pythonic Details for an explanation of range. over = False while not over: # B shoots at A if random.randint( 0, 2 ) == 2: print(\"B hit A. The duel's over.\") bwins = bwins + 1 over = True else: print(\"B missed A. The duel continues.\") if random.randint( 0, 1 ) == 1: print(\"A hit B. The duel's over.\") awins = awins + 1 over = True else: print(\"A missed B. The duel continues.\") print(6*'-') print(\"A won\", awins, \"duels.\") print(\"B won\", bwins, \"duels.\") Note that we are careful to initialize our counters above the for loop, but to reset over to False inside the for loop. Remaining Work We haven't quite met the question's requirements: We need to display the percentage of wins by A and B (not just the absolute numbers of wins). We shouldn't really hardwire the number of duels to be simulated (100 in the code above) into the program. It would be better to make it be a constant, and better yet to allow the user to specify the value. And of course the appearance of the program onscreen could be improved.","title":"Duelling Incompetents"},{"location":"04_Repetition/26_Duelling_incompetents/#duelling-incompetents","text":"","title":"Duelling Incompetents"},{"location":"04_Repetition/26_Duelling_incompetents/#the-problem","text":"Write a program to model the following peculiar duel (the names have been changed to protect the parties involved). A and B have quarelled and are going to settle their differences by duelling with pistols. Not only are A and B touchy, neither is a very good shot. A hits what he shoots at on average once every two tries. B is even worse, hitting what he shoots at once every three tries. Being a gentleman A allows B to fire first. The duel continues until one of them is hit. Your program should determine who is most likely to win the duel, by simulating many duels between A and B. It should output the percentage of duels won by A and the percentage won by B.","title":"The problem"},{"location":"04_Repetition/26_Duelling_incompetents/#getting-to-the-solution","text":"Approach: We'll write this program from the inside out. Starting from the most specific event and working outward to a full program.","title":"Getting to the Solution"},{"location":"04_Repetition/26_Duelling_incompetents/#b-shoots","text":"The duel begins with B taking a shot at A. He can either hit or miss A. The chances that he hits A are 1 in 3. The chances that he misses are 2 in 3. import random # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") else: print(\"B misses A. The duel continues.\")","title":"B Shoots"},{"location":"04_Repetition/26_Duelling_incompetents/#a-shoots","text":"If B hits A then the duel ends, but if he misses the duel will continue. The duel continues by A taking a shot at B. This code is similar to B taking a shot at A, but the odds are different because A is a better shot. We put the code for A's shot into the else branch of the if above, since A only gets to shoot if B misses. import random # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") else: print(\"B misses A. The duel continues.\") if random.randint(0, 1) == 1: print(\"A hits B. The duel's over.\") else: print(\"A misses B. The duel continues.\")","title":"A Shoots"},{"location":"04_Repetition/26_Duelling_incompetents/#one-complete-duel","text":"Now if A hits B the duel is over, but if A misses the duel continues with B taking a shot. We could copy our B shooting code and add it in the second else branch above, but we could have to do that a lot, since the duel could, in principle, take an infinite number of rounds to complete. A simpler approach is to place the code above inside a while loop: import random while ?: # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") else: print(\"B misses A. The duel continues.\") if random.randint(0, 1) == 1: print(\"A hits B. The duel's over.\") else: print(\"A misses B. The duel continues.\") The question is what the while condition should be. We want to say, \u201cwhile the duel is not over, they keep shooting at each other\u201d and Python lets us come very close to writing this: import random over = False while not over: # B shoots at A if random.randint(0, 2) == 2: print(\"B hits A. The duel's over.\") over = True else: print(\"B misses A. The duel continues.\") if random.randint(0, 1) == 1: print(\"A hits B. The duel's over.\") over = True else: print(\"A misses B. The duel continues.\") We declare a variable called over to hold the state of the duel. It's value is False when the duel is not over, and True when the duel is over. We initialize it to be False (since before they have shot at each other the duel can't be over). We update its value to True when one antagonist hits the other. The loop lets them keep taking turns shooting at each other until one finally hits the other. This code successfully models a duel: run it and see.","title":"One Complete Duel"},{"location":"04_Repetition/26_Duelling_incompetents/#many-duels","text":"We are making progress but we are not done because the original problem wanted us to simulate many duels and display the percentage of duels won by each antagonist. To simulate many duels we pack all the code above (except for the import ) into a for loop, and record, using counters, the number of duels each antagonist wins. import random awins = 0 bwins = 0 for duel in range(0, 100): # See Pythonic Details for an explanation of range. over = False while not over: # B shoots at A if random.randint( 0, 2 ) == 2: print(\"B hit A. The duel's over.\") bwins = bwins + 1 over = True else: print(\"B missed A. The duel continues.\") if random.randint( 0, 1 ) == 1: print(\"A hit B. The duel's over.\") awins = awins + 1 over = True else: print(\"A missed B. The duel continues.\") print(6*'-') print(\"A won\", awins, \"duels.\") print(\"B won\", bwins, \"duels.\") Note that we are careful to initialize our counters above the for loop, but to reset over to False inside the for loop.","title":"Many Duels"},{"location":"04_Repetition/26_Duelling_incompetents/#remaining-work","text":"We haven't quite met the question's requirements: We need to display the percentage of wins by A and B (not just the absolute numbers of wins). We shouldn't really hardwire the number of duels to be simulated (100 in the code above) into the program. It would be better to make it be a constant, and better yet to allow the user to specify the value. And of course the appearance of the program onscreen could be improved.","title":"Remaining Work"},{"location":"04_Repetition/26_Factors/","text":"Factors Write a program that inputs a positive whole number, and displays all the number's factors, i.e. all the numbers that divide into it exactly. For instance if the number 12 is input, the values 1, 2, 3, 4, 6, and 12 should be output. Solutions:","title":"Factors"},{"location":"04_Repetition/26_Factors/#factors","text":"Write a program that inputs a positive whole number, and displays all the number's factors, i.e. all the numbers that divide into it exactly. For instance if the number 12 is input, the values 1, 2, 3, 4, 6, and 12 should be output.","title":"Factors"},{"location":"04_Repetition/26_Factors/#solutions","text":"","title":"Solutions:"},{"location":"04_Repetition/27_Cryptarithms/","text":"Cryptarithms Long before sudoku, newspapers featured various mental puzzles, one type of which were known as cryptarithms. Cryptarithms are arithmetic puzzles in which some 'words' are added together to get a sum, send + more ------- money Each letter stands for a distinct digit, i.e. no two letters stand for the same digit, and the numbers are well-formed, e.g. they do not begin with zero. How can we use the computer to help us in solving cryptarithms? So far our approach to programming has been to do the problem by hand, and to watch ourselves carefully as we do so. Our goal in doing the problem by hand has been to identify the algorithm we are using, so we can translate it into Python and have the computer do it for us. The assumption has been that the computer will do it in the same way we have. Cryptarithms are an exception to that approach, because solving a cryptarithm by hand relies on the unique features of the particular cryptarithm we are given. For example in the cryptarithm above we know that m must represent the digit 1. (Why? Because s and m no matter how large cannot add to more than 17, 18 with a carry from the previous addition, and since m cannot be 0, it must be 1.) But there is no easy way to translate the procedures we carry out in doing cryptarithms by hand into general computational procedures. Instead, we will rely on the particular strengths of computers to have the computer solve the problem in a way we would not do it ourselves. Unlike humans, computers have the ability to do monotonous calculations rapidly and accurately. This suggests using the computer to solve the cryptarithm by trial and error. We will have the computer find the solution by checking all possible solutions until it finds one that works. The only trick is to come up with a procedure that guarantees we will not miss any possible solutions. The key is to use nested loops to iterate through all possible values of the letters, i.e. s, e, n, d, m, o , r, and y. The loops to do so look like this: Note that the loops for s and m begin at 1 because these letters cannot take the value 0 (due to the well-formedness criterion above). Inside all these loops we place statements to 'build' the values of send, more and money, and test to see if send+more=money, (Note the use of == here where in paragraph form we have written send+more=money, and always remember, \"Assignment is not equality\".) If the test-expression is true we are still not quite done. We must check that no two letters represent the same digit. That requires a second, even longer, if , (Note the triangular shape of the comparisons. It results because having compared s to e in the first line of comparisons, we do not have to compare e to s in the second line, and so on. If this if also succeeds, then we know we have a solution and should display it, Putting it all together we get: Assuming I have not made any typos this code works, but it is slooooow! How slow? Try it and see. How many solutions to this cryptarithm are there? Some cryptarithms have no solutions, some have 1, but many have several. Now about that slowness issue. The core problem is that the statements inside the innermost loop are each executed \\~200,000,000 times each (that's two hundred million!). We calculate that amount by multiplying the numbers of times the loops outside it go around: 10 times for s by 11 times for e by 11 times for n and so on, or 10x11x11x11x10x11x11x11 = 177,156,100. To speed up the program we need to move statements outward from the center of the program where possible so they will be executed fewer times. For example we don't need to wait until we are in the centre of the loops to check that s and e have different values. We could place an if test to do that right after the for loop generating values of e. Each time we detect a duplicate and skip the interior loops we save 1.6 million iterations. In fact most of the if tests can be distributed outwards. Similarly we don't have to wait until we are in the center to check the sum of send and more. We could check partial sums before we get to the middle, e.g. we could check that y = d + e early on if we rearranged the order of the loops and avoid many more iterations. For the ultimate speedup we could be less brutish and instead of trying ALL possible combinations we could generate some values and then calculate others. For example if you know that d = 5 and e = 2 then you know that y has to be 7. Note that this gets a little tricky when d+e is greater than 10 because you have a carry digit to worry about. Combining all these tricks can make a large cryptarithm program run millions of times faster.","title":"Cryptarithms"},{"location":"04_Repetition/27_Cryptarithms/#cryptarithms","text":"Long before sudoku, newspapers featured various mental puzzles, one type of which were known as cryptarithms. Cryptarithms are arithmetic puzzles in which some 'words' are added together to get a sum, send + more ------- money Each letter stands for a distinct digit, i.e. no two letters stand for the same digit, and the numbers are well-formed, e.g. they do not begin with zero. How can we use the computer to help us in solving cryptarithms? So far our approach to programming has been to do the problem by hand, and to watch ourselves carefully as we do so. Our goal in doing the problem by hand has been to identify the algorithm we are using, so we can translate it into Python and have the computer do it for us. The assumption has been that the computer will do it in the same way we have. Cryptarithms are an exception to that approach, because solving a cryptarithm by hand relies on the unique features of the particular cryptarithm we are given. For example in the cryptarithm above we know that m must represent the digit 1. (Why? Because s and m no matter how large cannot add to more than 17, 18 with a carry from the previous addition, and since m cannot be 0, it must be 1.) But there is no easy way to translate the procedures we carry out in doing cryptarithms by hand into general computational procedures. Instead, we will rely on the particular strengths of computers to have the computer solve the problem in a way we would not do it ourselves. Unlike humans, computers have the ability to do monotonous calculations rapidly and accurately. This suggests using the computer to solve the cryptarithm by trial and error. We will have the computer find the solution by checking all possible solutions until it finds one that works. The only trick is to come up with a procedure that guarantees we will not miss any possible solutions. The key is to use nested loops to iterate through all possible values of the letters, i.e. s, e, n, d, m, o , r, and y. The loops to do so look like this: Note that the loops for s and m begin at 1 because these letters cannot take the value 0 (due to the well-formedness criterion above). Inside all these loops we place statements to 'build' the values of send, more and money, and test to see if send+more=money, (Note the use of == here where in paragraph form we have written send+more=money, and always remember, \"Assignment is not equality\".) If the test-expression is true we are still not quite done. We must check that no two letters represent the same digit. That requires a second, even longer, if , (Note the triangular shape of the comparisons. It results because having compared s to e in the first line of comparisons, we do not have to compare e to s in the second line, and so on. If this if also succeeds, then we know we have a solution and should display it, Putting it all together we get: Assuming I have not made any typos this code works, but it is slooooow! How slow? Try it and see. How many solutions to this cryptarithm are there? Some cryptarithms have no solutions, some have 1, but many have several. Now about that slowness issue. The core problem is that the statements inside the innermost loop are each executed \\~200,000,000 times each (that's two hundred million!). We calculate that amount by multiplying the numbers of times the loops outside it go around: 10 times for s by 11 times for e by 11 times for n and so on, or 10x11x11x11x10x11x11x11 = 177,156,100. To speed up the program we need to move statements outward from the center of the program where possible so they will be executed fewer times. For example we don't need to wait until we are in the centre of the loops to check that s and e have different values. We could place an if test to do that right after the for loop generating values of e. Each time we detect a duplicate and skip the interior loops we save 1.6 million iterations. In fact most of the if tests can be distributed outwards. Similarly we don't have to wait until we are in the center to check the sum of send and more. We could check partial sums before we get to the middle, e.g. we could check that y = d + e early on if we rearranged the order of the loops and avoid many more iterations. For the ultimate speedup we could be less brutish and instead of trying ALL possible combinations we could generate some values and then calculate others. For example if you know that d = 5 and e = 2 then you know that y has to be 7. Note that this gets a little tricky when d+e is greater than 10 because you have a carry digit to worry about. Combining all these tricks can make a large cryptarithm program run millions of times faster.","title":"Cryptarithms"},{"location":"04_Repetition/28_Python_formatting_guidelines/","text":"Python Formatting Guidelines Why have guidelines? A style guide provides provides a map so that the code generated by a group of programmers will be consistent and, therefore, easier to read and maintain. \u2020 It is also an essential part of joining a community, and as with most communities the rules vary. In the case of programming they vary across languages, and even across major projects or companies using a language, e.g. C++: GeoSoft's , Google's , Java , PHP , C# , Perl , Ruby , and of course, Python . CPSC 128 Python Guidelines These are extracted from the Python guidelines above, so you will not have to wade through too many language features you won't recognize. Use four spaces for indentation. (IDLE does this for you. If you're using another editor, set it to use four space characters, not a tab character). Limit lines to 80 characters. Separate logical sections of a program with single blank lines. Begin every program with an opening comment block containing at least: # filename # Author # Date Place import statements right after the opening comment block. Initialize variables as near their first use as possible. Do not leave a space between input and its opening ( . Do not leave a space after ( or before ). Place a single space on each side of the binary operators = , == , < , <= , != , <> , >= , > , and , or , not , and in . Use spaces around arithmetic operators too, though in long expressions using grouping for readability takes precedence. Comments should be complete sentences. Comments should add to the code not repeat it, and should never state the obvious. Variable names should be lower_case. Constant names should be UPPER_CASE.","title":"Python Formatting Guidelines"},{"location":"04_Repetition/28_Python_formatting_guidelines/#python-formatting-guidelines","text":"","title":"Python Formatting Guidelines"},{"location":"04_Repetition/28_Python_formatting_guidelines/#why-have-guidelines","text":"A style guide provides provides a map so that the code generated by a group of programmers will be consistent and, therefore, easier to read and maintain. \u2020 It is also an essential part of joining a community, and as with most communities the rules vary. In the case of programming they vary across languages, and even across major projects or companies using a language, e.g. C++: GeoSoft's , Google's , Java , PHP , C# , Perl , Ruby , and of course, Python .","title":"Why have guidelines?"},{"location":"04_Repetition/28_Python_formatting_guidelines/#cpsc-128-python-guidelines","text":"These are extracted from the Python guidelines above, so you will not have to wade through too many language features you won't recognize. Use four spaces for indentation. (IDLE does this for you. If you're using another editor, set it to use four space characters, not a tab character). Limit lines to 80 characters. Separate logical sections of a program with single blank lines. Begin every program with an opening comment block containing at least: # filename # Author # Date Place import statements right after the opening comment block. Initialize variables as near their first use as possible. Do not leave a space between input and its opening ( . Do not leave a space after ( or before ). Place a single space on each side of the binary operators = , == , < , <= , != , <> , >= , > , and , or , not , and in . Use spaces around arithmetic operators too, though in long expressions using grouping for readability takes precedence. Comments should be complete sentences. Comments should add to the code not repeat it, and should never state the obvious. Variable names should be lower_case. Constant names should be UPPER_CASE.","title":"CPSC 128 Python Guidelines"},{"location":"04_Repetition/29_A_list_creating_function_range/","text":"A list-creating function: range() The built-in function range creates arithmetic lists, and is often used to produce the lists to drive for loops. range(start_value, stop_value, stepsize) Example: >>> range(1, 20, 5) range(1,20,5) To see the list created by range you need to tell python to display the range of numbers as a list. >>> list(range(1, 20, 5)) [1, 6, 11, 16] A list of things in python is easy to identify because of the square brackets and the commas. Notes: the_start_value_defaults to 0. the_stepsize_defaults to 1. the_stop_value_is NOT included in the list. This means that the range is asymmetric: because the starting value is included, but the stopping value is not included. Try entering the following expressions in the Python shell and see what results: >>> list(range(20)) >>> list(range(10,20)) >>> list(range(10,20,2)) >>> list(range(20,2)) (Do you understand why the last one returns the value it does?) Here's a little code snippet showing how range can be used to display the squares of the numbers from 1 to 10., print(\"Table of squares for 1-10\") print(\" x x**2\") for x in range(1,11): print(f\"{x:5d}{x**2:8d}\") Note that since the stop value is NOT included in the list we have to specify a stop value of 11 to include the value 10.","title":"A list-creating function:\u00a0range()"},{"location":"04_Repetition/29_A_list_creating_function_range/#a-list-creating-function-range","text":"The built-in function range creates arithmetic lists, and is often used to produce the lists to drive for loops. range(start_value, stop_value, stepsize) Example: >>> range(1, 20, 5) range(1,20,5) To see the list created by range you need to tell python to display the range of numbers as a list. >>> list(range(1, 20, 5)) [1, 6, 11, 16] A list of things in python is easy to identify because of the square brackets and the commas. Notes: the_start_value_defaults to 0. the_stepsize_defaults to 1. the_stop_value_is NOT included in the list. This means that the range is asymmetric: because the starting value is included, but the stopping value is not included. Try entering the following expressions in the Python shell and see what results: >>> list(range(20)) >>> list(range(10,20)) >>> list(range(10,20,2)) >>> list(range(20,2)) (Do you understand why the last one returns the value it does?) Here's a little code snippet showing how range can be used to display the squares of the numbers from 1 to 10., print(\"Table of squares for 1-10\") print(\" x x**2\") for x in range(1,11): print(f\"{x:5d}{x**2:8d}\") Note that since the stop value is NOT included in the list we have to specify a stop value of 11 to include the value 10.","title":"A list-creating function:\u00a0range()"},{"location":"04_Repetition/30_Timing_programs/","text":"Timing programs Once your code is working, and you have tested it to ensure it works correctly, you may need to try and make it faster. Making it faster implies being able to measure its speed. Just as you measure the speed of an athlete by timing them when they run a race we measure the speed of a program by timing how long it takes to execute. The simplest way to do this in Python is to use a program structured like this, The function time.time() returns the current time in seconds since the epoch*. By grabbing the time before the computations begin in start and the time when they are completed in end . and then finding their difference we can calculate how long the computations took. Here is an example in which we see how long it takes to find the sum of the square roots of the numbers from 1 to 1,000,000. Truly accurate timing of program execution is much trickier than this technique suggests. Unless you get the help of the operating system, the timing shown above will depend on what else happens to be running on your computer at the same time. More sophisticated timing is possible using programs called profilers that measure the time more accurately than our approach above. For more see the Python documentation on time .","title":"Timing programs"},{"location":"04_Repetition/30_Timing_programs/#timing-programs","text":"Once your code is working, and you have tested it to ensure it works correctly, you may need to try and make it faster. Making it faster implies being able to measure its speed. Just as you measure the speed of an athlete by timing them when they run a race we measure the speed of a program by timing how long it takes to execute. The simplest way to do this in Python is to use a program structured like this, The function time.time() returns the current time in seconds since the epoch*. By grabbing the time before the computations begin in start and the time when they are completed in end . and then finding their difference we can calculate how long the computations took. Here is an example in which we see how long it takes to find the sum of the square roots of the numbers from 1 to 1,000,000. Truly accurate timing of program execution is much trickier than this technique suggests. Unless you get the help of the operating system, the timing shown above will depend on what else happens to be running on your computer at the same time. More sophisticated timing is possible using programs called profilers that measure the time more accurately than our approach above. For more see the Python documentation on time .","title":"Timing programs"},{"location":"04_Repetition/70_Exercise_Sheet_3/","text":"Exercise Sheet 3 For the following problem descriptions decide whether it would be best to use an if statement (with or without elifs and else), a while loop, or a for loop. You don't actually have to write the code for any of these! Write a program that gets two numbers from the user. The user calculates that number to the power of 1, 2, 3, 4, ... while the result is less than the second number. Below is an example run of the program. Give me a number to \u201cpower\u201d up: 2 Give me a place to stop: 50 2**1 = 2 2**2 = 4 2**3 = 8 2**4 = 16 2**5 = 32 Write a guessing game program where the user has to guess a number between 1 and 100. The computer will let the user know if they are too high or too low after each guess and stop when the user the guesses correctly. Then it will tell the user about their glorious victory! Get the length and width of a rectangle and tell the user if it is a square or not. Use nested a loop to write a program that outputs a multiplication table for each number from 1 to a number input by the user. The final output should look something like the example below. Enter the biggest number in the table: 5 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20 5 10 15 20 25 Write a program that gets the users salary and tells them how much income tax they will pay based on the table below. 2022 FEDERAL INCOME TAX BRACKET 2022 FEDERAL INCOME TAX RATE $50,197 or less 15% $50,198 to $100,392 20.5% $100,393 to $155,625 26% $155,626 to $221,708 29% $221,709 and above 33% Write a program that gives the computer a simulated (and untimed) Paced Auditory Serial Addition Test (PASAT). The computer will keep getting positive integer numbers from the user and add the last two values entered before getting the next value. This is actually quite complicated for a person to keep track of but will be easy for the computer. The program will stop when the user enters a negative number. Below is an example run of the program (5+3=8, 3+4=7, 4+6=10,done). Give me a PASAT by giving me positive integers to add. When you are ready to stop enter -1. Start giving me numbers: >5 >3 8 >4 7 >6 10 >-1 Done my PASAT! How did I do? Write a program that converts a number from a decimal number to a number in Kaktovik (base 20) using the following pseudocode. 1. Divide the decimal number by the value of the new base (i.e. 2 for binary) 2. Get the remainder and make it the right most digit of the new number. 3. Divide the quotient of the last step by the new base. 4. Get the remainder and make it the 2nd right most digit. 5. Repeat steps 3 and 4 until the quotient is zero. Write a program that draws different sized triangles depending on the user\u2019s input. You will need to think about how the spaces are related to the total number of rows (0 spaces in the last row, 1 in the second last row...) and how the number of stars is related to the position of the row relative to the top (1 star first row, 3, stars second row...). I\u2019ve included two example runs below to give an idea of what I mean. Enter the size of the triangle: 3 * *** ***** Enter the size of the triangle: 6 * *** ***** ******* ********* ***********","title":"Exercise Sheet 3"},{"location":"04_Repetition/70_Exercise_Sheet_3/#exercise-sheet-3","text":"For the following problem descriptions decide whether it would be best to use an if statement (with or without elifs and else), a while loop, or a for loop. You don't actually have to write the code for any of these! Write a program that gets two numbers from the user. The user calculates that number to the power of 1, 2, 3, 4, ... while the result is less than the second number. Below is an example run of the program. Give me a number to \u201cpower\u201d up: 2 Give me a place to stop: 50 2**1 = 2 2**2 = 4 2**3 = 8 2**4 = 16 2**5 = 32 Write a guessing game program where the user has to guess a number between 1 and 100. The computer will let the user know if they are too high or too low after each guess and stop when the user the guesses correctly. Then it will tell the user about their glorious victory! Get the length and width of a rectangle and tell the user if it is a square or not. Use nested a loop to write a program that outputs a multiplication table for each number from 1 to a number input by the user. The final output should look something like the example below. Enter the biggest number in the table: 5 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20 5 10 15 20 25 Write a program that gets the users salary and tells them how much income tax they will pay based on the table below. 2022 FEDERAL INCOME TAX BRACKET 2022 FEDERAL INCOME TAX RATE $50,197 or less 15% $50,198 to $100,392 20.5% $100,393 to $155,625 26% $155,626 to $221,708 29% $221,709 and above 33% Write a program that gives the computer a simulated (and untimed) Paced Auditory Serial Addition Test (PASAT). The computer will keep getting positive integer numbers from the user and add the last two values entered before getting the next value. This is actually quite complicated for a person to keep track of but will be easy for the computer. The program will stop when the user enters a negative number. Below is an example run of the program (5+3=8, 3+4=7, 4+6=10,done). Give me a PASAT by giving me positive integers to add. When you are ready to stop enter -1. Start giving me numbers: >5 >3 8 >4 7 >6 10 >-1 Done my PASAT! How did I do? Write a program that converts a number from a decimal number to a number in Kaktovik (base 20) using the following pseudocode. 1. Divide the decimal number by the value of the new base (i.e. 2 for binary) 2. Get the remainder and make it the right most digit of the new number. 3. Divide the quotient of the last step by the new base. 4. Get the remainder and make it the 2nd right most digit. 5. Repeat steps 3 and 4 until the quotient is zero. Write a program that draws different sized triangles depending on the user\u2019s input. You will need to think about how the spaces are related to the total number of rows (0 spaces in the last row, 1 in the second last row...) and how the number of stars is related to the position of the row relative to the top (1 star first row, 3, stars second row...). I\u2019ve included two example runs below to give an idea of what I mean. Enter the size of the triangle: 3 * *** ***** Enter the size of the triangle: 6 * *** ***** ******* ********* ***********","title":"Exercise Sheet 3"},{"location":"04_Repetition/90_Assignment_4/","text":"Assignment 4 Problems More weird numbers \"Take a four-digit number. Add the number formed by the first two digits to the number formed by the last two digits, and square the resulting sum. Surprise! You've got the original number back.\" Write a program to find all the four-digit numbers that have this property. For example, here's a number that fails the test: 1430. Add 14 to 30 to get 44, square 44 to get 1936, but this is not what we started with (i.e. 1430) so this number fails the test. Drawing Diamonds Write a program that displays a diamond on the screen, e.g. * *** ***** *** * Your program should ask the user how large a diamond to draw and what character to use to draw it. (The size of a diamond is specified by the lengths of its sides, i.e. 3 in the case above). DONALD + GERALD = ROBERT Write a program that displays the solution(s) to the cryptarithm: DONALD + GERALD -------- ROBERT Each letter represents one digit. No two letters represent the same digit. The numbers represented by DONALD, GERALD and ROBERT are well-formed, e.g. do not begin with 0. How fast can you make your program? The faster the better (but since someone once tried it let me say that presolving it and just the printing the solution is definitely a cheat!). Include timing code in your program so I can compare its speed to others on my computer. Craps Write a program that outputs the probability of winning at the game of craps. The rules for the game of craps are: A player rolls two dice. Each die has six faces. These faces contain 1, 2, 3, 4, 5 and 6 spots. After the dice have come to rest, the sum of the spots on the two upward faces is calculated. If the sum is 7 or 11 on the first throw, the player wins. If the sum is 2, 3 or 12 on the first throw (called \u201ccraps\u201d), the player loses (i.e. the \u201chouse\u201d wins). If the sum is 4, 5, 6, 8, 9 or 10 on the first throw, then that sum becomes the player's \u201cpoint\u201d. To win, you must continue rolling the dice until you \u201cmake your point\u201d. The player loses if they roll a 7 before making their point. Logistics Use the following naming scheme for your program files: a assignment# p problem# name .py . So your solution for problem 1 on this assignment will be named a4p1bob.py . Submit your assignment through the Moodle page. There will be a Dropbox for the assignment for you to upload your .py files.","title":"Assignment 4"},{"location":"04_Repetition/90_Assignment_4/#assignment-4","text":"","title":"Assignment 4"},{"location":"04_Repetition/90_Assignment_4/#problems","text":"","title":"Problems"},{"location":"04_Repetition/90_Assignment_4/#more-weird-numbers","text":"\"Take a four-digit number. Add the number formed by the first two digits to the number formed by the last two digits, and square the resulting sum. Surprise! You've got the original number back.\" Write a program to find all the four-digit numbers that have this property. For example, here's a number that fails the test: 1430. Add 14 to 30 to get 44, square 44 to get 1936, but this is not what we started with (i.e. 1430) so this number fails the test.","title":"More weird numbers"},{"location":"04_Repetition/90_Assignment_4/#drawing-diamonds","text":"Write a program that displays a diamond on the screen, e.g. * *** ***** *** * Your program should ask the user how large a diamond to draw and what character to use to draw it. (The size of a diamond is specified by the lengths of its sides, i.e. 3 in the case above).","title":"Drawing Diamonds"},{"location":"04_Repetition/90_Assignment_4/#donald-gerald-robert","text":"Write a program that displays the solution(s) to the cryptarithm: DONALD + GERALD -------- ROBERT Each letter represents one digit. No two letters represent the same digit. The numbers represented by DONALD, GERALD and ROBERT are well-formed, e.g. do not begin with 0. How fast can you make your program? The faster the better (but since someone once tried it let me say that presolving it and just the printing the solution is definitely a cheat!). Include timing code in your program so I can compare its speed to others on my computer.","title":"DONALD + GERALD = ROBERT"},{"location":"04_Repetition/90_Assignment_4/#craps","text":"Write a program that outputs the probability of winning at the game of craps. The rules for the game of craps are: A player rolls two dice. Each die has six faces. These faces contain 1, 2, 3, 4, 5 and 6 spots. After the dice have come to rest, the sum of the spots on the two upward faces is calculated. If the sum is 7 or 11 on the first throw, the player wins. If the sum is 2, 3 or 12 on the first throw (called \u201ccraps\u201d), the player loses (i.e. the \u201chouse\u201d wins). If the sum is 4, 5, 6, 8, 9 or 10 on the first throw, then that sum becomes the player's \u201cpoint\u201d. To win, you must continue rolling the dice until you \u201cmake your point\u201d. The player loses if they roll a 7 before making their point.","title":"Craps"},{"location":"04_Repetition/90_Assignment_4/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem# name .py . So your solution for problem 1 on this assignment will be named a4p1bob.py . Submit your assignment through the Moodle page. There will be a Dropbox for the assignment for you to upload your .py files.","title":"Logistics"},{"location":"05_Lists_and_Strings/","text":"Introduction: Lists and strings \ud83e\uddf5 Finally something other than numbers! So far all of your programs have had a mathematical, or at least arithmetic, feel to them. That's because the main data type we've had to work with has been numbers, and single numbers at that. This week we will look at compound datatypes that let us represent words and lists of things. Together they vastly expand the types of things we can represent, and thus work with, in our programs. We will work with code like, grades = [78, 91, 84] # a list containing three numbers name = 'Tim Topper' # a string, which is a sequence of characters names = ['Tim', 'Anne', 'Mary', 'Geoff'] # a list containing 4 strings We cover lists and strings in the same week because they are both sequence types that share a lot of common operations. Lists and strings are also both object types and to work with them you will have to get comfortable with some new-ish notation, and a bit of jargon that goes with it. The notation isn't that hard to follow, for example, >>> s = 'Topper' >>> s.count('p') 2 >>> s.endswith('er') True >>> s.upper() 'TOPPER' >>> This notation features the name of an object s , a period . , the method to perform count , and then any information the method requires in parentheses ('p') : s.count('p') . (This notation is not entirely new, e,g, we have seen and used random.randint(1,6) .) The list and string object types support a lot of methods. Some are shown in the resources and the complete lists of them in the official Python documentation are linked to. To prepare for the assignment problems you will want to familiarize yourself with the operations available to you (so you don't reinvent the wheel!), and get a little practice using them in the Python shell, like the excerpt above. I hope you find lists and strings interesting! Object-based programming Sequence Types What can you do with a list? What can you do with a string? Example: CD Shuffle Dice Odds Bar Graphs Representing Playing Cards Poker hands Playing Cards: An alternative representation What is this [ [ 'X', 'O', '' ], [ 'O', 'X', 'O' ], [ '', '', 'X'] ] ? Palindrome Built-in Type Conversions The map() function Tuples Assignment 5","title":"Introduction: Lists and strings \ud83e\uddf5"},{"location":"05_Lists_and_Strings/#introduction-lists-and-strings","text":"Finally something other than numbers! So far all of your programs have had a mathematical, or at least arithmetic, feel to them. That's because the main data type we've had to work with has been numbers, and single numbers at that. This week we will look at compound datatypes that let us represent words and lists of things. Together they vastly expand the types of things we can represent, and thus work with, in our programs. We will work with code like, grades = [78, 91, 84] # a list containing three numbers name = 'Tim Topper' # a string, which is a sequence of characters names = ['Tim', 'Anne', 'Mary', 'Geoff'] # a list containing 4 strings We cover lists and strings in the same week because they are both sequence types that share a lot of common operations. Lists and strings are also both object types and to work with them you will have to get comfortable with some new-ish notation, and a bit of jargon that goes with it. The notation isn't that hard to follow, for example, >>> s = 'Topper' >>> s.count('p') 2 >>> s.endswith('er') True >>> s.upper() 'TOPPER' >>> This notation features the name of an object s , a period . , the method to perform count , and then any information the method requires in parentheses ('p') : s.count('p') . (This notation is not entirely new, e,g, we have seen and used random.randint(1,6) .) The list and string object types support a lot of methods. Some are shown in the resources and the complete lists of them in the official Python documentation are linked to. To prepare for the assignment problems you will want to familiarize yourself with the operations available to you (so you don't reinvent the wheel!), and get a little practice using them in the Python shell, like the excerpt above. I hope you find lists and strings interesting! Object-based programming Sequence Types What can you do with a list? What can you do with a string? Example: CD Shuffle Dice Odds Bar Graphs Representing Playing Cards Poker hands Playing Cards: An alternative representation What is this [ [ 'X', 'O', '' ], [ 'O', 'X', 'O' ], [ '', '', 'X'] ] ? Palindrome Built-in Type Conversions The map() function Tuples Assignment 5","title":"Introduction: Lists and strings \ud83e\uddf5"},{"location":"05_Lists_and_Strings/01_Object_based_programming/","text":"Object-based programming All the values we have worked with in Python have been objects, but we haven't really been aware of that because we've been able to work with them using built-in operators. For example we have been able to write x = a + 10 and it has looked enough like regular arithmetic that we haven't had to address the fact that those things, x and a , are objects. Aside 1: Already though we have seen that the meaning of the operator depends on the types of the objects to which it is applied. The + in 3 + 2 means arithmetic addition, but the + in \"Tim\" + \"Topper\" means string concatenation. Similarly the % in 9%5 means modulo, but the second % in \"%1.2f\" % temp means string interpolation. (Jargon alert: In object-oriented programming this is referred to as polymorphism or more specifically operator overloading ). Aside 2: Remember that you can query the type of a literal value, or of the value associated with a name, by using the built-in function type , e.g. >>> type(4) <class 'int'> >>> type(\"Tim\") <class 'str'> >>> x = 4.5 >>> type(x) <class 'float'> >>> last_name = \"Topper\" >>> type(last_name) <class 'str'> >>> where int is short for integer, float is short for floating point and str is short for string. However, most object types provide more operations than there are built-in operators. In these cases we use a different notation to specify the operation to be performed. But to describe that notation it will help to have a little more jargon. An object consists of a set of attributes and a set of methods it knows how to apply to itself. For example we can see that the string last_name above has as its attribute the sequence of characters T o p p e r , but what about its methods? One way to find an object's methods is to use the dir() command, e.g. >>> dir(last_name) ['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__str__', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'replace', 'rfind', 'rindex', 'rjust', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> The names beginning with double underscores __ correspond to the methods invoked by operators, e.g. the __add__ method is invoked when + appears between two string values. The names after the double underscore names are invoked by giving the name of the object followed by a period and then the name of the method followed by parentheses, e.g. >>> last_name.upper() 'TOPPER' >>> last_name.center(20) ' Topper ' >>> Note that when the method requires parameters they are listed in the parentheses, like 20 in the second command above. In Python everything is an object. For instance we have seen this dot notation before, when importing the modules random and math . That's because an imported module is an object and we access the methods the module provides using this same dot notation. The dot notation for accessing object attributes and methods is common to most object-oriented languages including C++, Java, and Javascript. The general syntax to invoke one of an object's methods is, object_name.method_name(parameters) where the parameters depend on the method, and may be optional as in last_name.upper() above, or provided as in last_name.center(20) . Jargon summary","title":"Object-based programming"},{"location":"05_Lists_and_Strings/01_Object_based_programming/#object-based-programming","text":"All the values we have worked with in Python have been objects, but we haven't really been aware of that because we've been able to work with them using built-in operators. For example we have been able to write x = a + 10 and it has looked enough like regular arithmetic that we haven't had to address the fact that those things, x and a , are objects. Aside 1: Already though we have seen that the meaning of the operator depends on the types of the objects to which it is applied. The + in 3 + 2 means arithmetic addition, but the + in \"Tim\" + \"Topper\" means string concatenation. Similarly the % in 9%5 means modulo, but the second % in \"%1.2f\" % temp means string interpolation. (Jargon alert: In object-oriented programming this is referred to as polymorphism or more specifically operator overloading ). Aside 2: Remember that you can query the type of a literal value, or of the value associated with a name, by using the built-in function type , e.g. >>> type(4) <class 'int'> >>> type(\"Tim\") <class 'str'> >>> x = 4.5 >>> type(x) <class 'float'> >>> last_name = \"Topper\" >>> type(last_name) <class 'str'> >>> where int is short for integer, float is short for floating point and str is short for string. However, most object types provide more operations than there are built-in operators. In these cases we use a different notation to specify the operation to be performed. But to describe that notation it will help to have a little more jargon. An object consists of a set of attributes and a set of methods it knows how to apply to itself. For example we can see that the string last_name above has as its attribute the sequence of characters T o p p e r , but what about its methods? One way to find an object's methods is to use the dir() command, e.g. >>> dir(last_name) ['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__str__', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'replace', 'rfind', 'rindex', 'rjust', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> The names beginning with double underscores __ correspond to the methods invoked by operators, e.g. the __add__ method is invoked when + appears between two string values. The names after the double underscore names are invoked by giving the name of the object followed by a period and then the name of the method followed by parentheses, e.g. >>> last_name.upper() 'TOPPER' >>> last_name.center(20) ' Topper ' >>> Note that when the method requires parameters they are listed in the parentheses, like 20 in the second command above. In Python everything is an object. For instance we have seen this dot notation before, when importing the modules random and math . That's because an imported module is an object and we access the methods the module provides using this same dot notation. The dot notation for accessing object attributes and methods is common to most object-oriented languages including C++, Java, and Javascript. The general syntax to invoke one of an object's methods is, object_name.method_name(parameters) where the parameters depend on the method, and may be optional as in last_name.upper() above, or provided as in last_name.center(20) .","title":"Object-based programming"},{"location":"05_Lists_and_Strings/01_Object_based_programming/#jargon-summary","text":"","title":"Jargon summary"},{"location":"05_Lists_and_Strings/02_Sequence_types/","text":"Sequence Types The built-in types we have worked with so far have each stored a single value (formally they are scalar types). But there are many real-world objects whose representation requires more than one value, e.g. a street address, someone's full name, a map coordinate. Python provides several compound data types, but we will begin by looking at strings and lists. These are both sequence types because they store an ordered list of values, that is a sequence of values (as opposed to unordered collections of values, which are formally called a set of values). In strings all the values are characters, but a list may contain values of any type (including other lists!). The official list of string operations can be found in the Python Library Reference . Exercises To find out how they work, try typing the following commands into the Python shell and carefully observing the output that each one produces. First strings: >>> name = \"Kate\" >>> \"t\" in name >>> \"o\" not in name >>> min(name) >>> max(name) >>> name = name + \" \" + \"Chatfield-Reed\" >>> print(name) >>> name[0] >>> name[2] >>> name[-1] >>> name[-2] >>> name[2:7] >>> len(name) >>> name*3 Now a list: >>> nums = [1, 2, 3, 4, 5] >>> 3 in nums >>> 9 in nums >>> min(nums) >>> max(nums) >>> nums = nums + [9, 10] >>> print(nums) >>> nums[0] >>> nums[2] >>> nums[-1] >>> nums[-2] >>> nums[2:5] >>> len(nums) >>> nums[2] = 11 >>> print(nums) >>> nums[2:6] = [20,30] Note that the third to last statement can ONLY be used with a list and NOT with a string (try it and see). That is because in Python lists are mutable (i.e. changeable), but strings are immutable (i.e. cannot be changed) so you cannot assign to individual elements of a string.","title":"Sequence Types"},{"location":"05_Lists_and_Strings/02_Sequence_types/#sequence-types","text":"The built-in types we have worked with so far have each stored a single value (formally they are scalar types). But there are many real-world objects whose representation requires more than one value, e.g. a street address, someone's full name, a map coordinate. Python provides several compound data types, but we will begin by looking at strings and lists. These are both sequence types because they store an ordered list of values, that is a sequence of values (as opposed to unordered collections of values, which are formally called a set of values). In strings all the values are characters, but a list may contain values of any type (including other lists!). The official list of string operations can be found in the Python Library Reference .","title":"Sequence Types"},{"location":"05_Lists_and_Strings/02_Sequence_types/#exercises","text":"To find out how they work, try typing the following commands into the Python shell and carefully observing the output that each one produces. First strings: >>> name = \"Kate\" >>> \"t\" in name >>> \"o\" not in name >>> min(name) >>> max(name) >>> name = name + \" \" + \"Chatfield-Reed\" >>> print(name) >>> name[0] >>> name[2] >>> name[-1] >>> name[-2] >>> name[2:7] >>> len(name) >>> name*3 Now a list: >>> nums = [1, 2, 3, 4, 5] >>> 3 in nums >>> 9 in nums >>> min(nums) >>> max(nums) >>> nums = nums + [9, 10] >>> print(nums) >>> nums[0] >>> nums[2] >>> nums[-1] >>> nums[-2] >>> nums[2:5] >>> len(nums) >>> nums[2] = 11 >>> print(nums) >>> nums[2:6] = [20,30] Note that the third to last statement can ONLY be used with a list and NOT with a string (try it and see). That is because in Python lists are mutable (i.e. changeable), but strings are immutable (i.e. cannot be changed) so you cannot assign to individual elements of a string.","title":"Exercises"},{"location":"05_Lists_and_Strings/03_What_can_you_do_with_a_list/","text":"What can you do with a list? The full list of list methods is in Python Library Reference . Here's an idea of how you might use and combine these methods to carry out common operations. Create a list: Using range , e.g. nums = list(range(10)) . By listing the items in the list: mishmash = [14, 'a', 4.19, 'Kate', True] Notice that values of several types can be stored in the same list. Access an item from a list: mishmash[0] is the first item in the list, i.e. 14 mishmash[1] is the second item in the list, i.e. 'a' mishmash[2] is the third item in the list, i.e. 4.19 Access a sublist of a list (called a slice in Python): mishmash[1:4] is the sublist of items in mishmash from position 1 up to but not including position 4, i.e. ['a', 4.19, 'Kate'] Note: that the range is [ inclusive : exclusive ] thus mishmash[1:1] is [] Note: a slice always returns a list, so mishmash[1:2] is ['a'] not just 'a' . Adding items to a list: mishmash.append(2) appends 2 to the list, i.e. it adds it to the end of the list so mishmash becomes [14, 'a', 4.19, 'Kate', True, 2] mishmash.insert(1, 'hi') inserts the string 'hi' into the list in position 1 , i.e. after 14 but before 'a' . mishmash = mishmash + ['bye'] appends 'bye' to the list. (Note the [] s around 'bye' ). Removing items: by position: del( mishmash[2] ) deletes the item at position 2 from the list. by value: mishmash.remove( 'a' ) removes the first (and only the first) occurrence of 'a' from the list. from the end of the list: mishmash.pop() removes the last item in the list. Getting information about a list and its contents: in can be used to test and see if an item is in a list, e.g. if 'a' in mishmash: . Note that in has to loop through the list checking to see if each item is 'a' to do that so it is a relatively slow operation. len( mishmash ) returns the length of the list, i.e. the number of items in the list. mishmash.index( 'Kate' ) returns the position in which the first occurrence of 'Kate' can be found. mishmash.count( 'Kate' ) counts the number of 'Kate' s in the list. Miscellaneous commands you should try out (because they will probably be useful on assignments!): mishmash.sort() mishmash.reverse() mishmash.extend() 2*mishmash","title":"What can you do with a list?"},{"location":"05_Lists_and_Strings/03_What_can_you_do_with_a_list/#what-can-you-do-with-a-list","text":"The full list of list methods is in Python Library Reference . Here's an idea of how you might use and combine these methods to carry out common operations. Create a list: Using range , e.g. nums = list(range(10)) . By listing the items in the list: mishmash = [14, 'a', 4.19, 'Kate', True] Notice that values of several types can be stored in the same list. Access an item from a list: mishmash[0] is the first item in the list, i.e. 14 mishmash[1] is the second item in the list, i.e. 'a' mishmash[2] is the third item in the list, i.e. 4.19 Access a sublist of a list (called a slice in Python): mishmash[1:4] is the sublist of items in mishmash from position 1 up to but not including position 4, i.e. ['a', 4.19, 'Kate'] Note: that the range is [ inclusive : exclusive ] thus mishmash[1:1] is [] Note: a slice always returns a list, so mishmash[1:2] is ['a'] not just 'a' . Adding items to a list: mishmash.append(2) appends 2 to the list, i.e. it adds it to the end of the list so mishmash becomes [14, 'a', 4.19, 'Kate', True, 2] mishmash.insert(1, 'hi') inserts the string 'hi' into the list in position 1 , i.e. after 14 but before 'a' . mishmash = mishmash + ['bye'] appends 'bye' to the list. (Note the [] s around 'bye' ). Removing items: by position: del( mishmash[2] ) deletes the item at position 2 from the list. by value: mishmash.remove( 'a' ) removes the first (and only the first) occurrence of 'a' from the list. from the end of the list: mishmash.pop() removes the last item in the list. Getting information about a list and its contents: in can be used to test and see if an item is in a list, e.g. if 'a' in mishmash: . Note that in has to loop through the list checking to see if each item is 'a' to do that so it is a relatively slow operation. len( mishmash ) returns the length of the list, i.e. the number of items in the list. mishmash.index( 'Kate' ) returns the position in which the first occurrence of 'Kate' can be found. mishmash.count( 'Kate' ) counts the number of 'Kate' s in the list. Miscellaneous commands you should try out (because they will probably be useful on assignments!): mishmash.sort() mishmash.reverse() mishmash.extend() 2*mishmash","title":"What can you do with a list?"},{"location":"05_Lists_and_Strings/04_What_can_you_do_with_a_string/","text":"What can you do with a string? The full list of string methods is in Python Library Reference . Here's an idea of how you might use and combine these methods to carry out common operations. Create a string: Read it in using input , e.g. name = input('Enter your name: ') . Assign it a literal string value, e.g. name = \"Tim Topper\" Access a character from a string: name[0] is the first character in the string, i.e. 'T' name[1] is the second character in the string, i.e. 'i' name[2] is the third character in the list, i.e. 'm' (Note that each individual character in a string is itself a string \u2014 albeit of length 1.) Access a substring of a string (called a slice in Python): name[1:5] is the substring of the string from position 1 up to, but not including, character 5, i.e. 'im T' Note: that the range is [ inclusive : exclusive ] thus name[1:1] is '' , the empty string. Adding to a string. Because strings are immutable you cannot change the contents of one, but you can create a new one and assign it to the same name (which has the effect of replacing the old string object with a new one). name = name + ' Smith' adds ' Smith' to the end of the string so 'Tim Topper' becomes 'Tim Topper Smith' You can insert into a string by careful use of slices, e.g. name = name[0:4] + 'Nicholas ' + name[4:] changes 'Tim Topper' to 'Tim Nicholas Topper' . Getting information about a string and its contents: in can be used to test and see if a substring is contained in a longer string, e.g. if 'a' in name: len( name ) returns the length of the string name , i.e. the number of characters in it. name.find( 'ola' ) returns the position in which the first occurrence of 'ola' begins, or -1 if it is not found (see also rfind which searches from the back of the string towards the front). Miscellaneous commands you should try out (because they will probably be useful on assignments!): name.count('p') name[2].isalpha() ':'.join(['abc','def','ghi']) \"867-395-0892\".split('-') \" Tim Topper \".strip() 40*\"+\"","title":"What can you do with a string?"},{"location":"05_Lists_and_Strings/04_What_can_you_do_with_a_string/#what-can-you-do-with-a-string","text":"The full list of string methods is in Python Library Reference . Here's an idea of how you might use and combine these methods to carry out common operations. Create a string: Read it in using input , e.g. name = input('Enter your name: ') . Assign it a literal string value, e.g. name = \"Tim Topper\" Access a character from a string: name[0] is the first character in the string, i.e. 'T' name[1] is the second character in the string, i.e. 'i' name[2] is the third character in the list, i.e. 'm' (Note that each individual character in a string is itself a string \u2014 albeit of length 1.) Access a substring of a string (called a slice in Python): name[1:5] is the substring of the string from position 1 up to, but not including, character 5, i.e. 'im T' Note: that the range is [ inclusive : exclusive ] thus name[1:1] is '' , the empty string. Adding to a string. Because strings are immutable you cannot change the contents of one, but you can create a new one and assign it to the same name (which has the effect of replacing the old string object with a new one). name = name + ' Smith' adds ' Smith' to the end of the string so 'Tim Topper' becomes 'Tim Topper Smith' You can insert into a string by careful use of slices, e.g. name = name[0:4] + 'Nicholas ' + name[4:] changes 'Tim Topper' to 'Tim Nicholas Topper' . Getting information about a string and its contents: in can be used to test and see if a substring is contained in a longer string, e.g. if 'a' in name: len( name ) returns the length of the string name , i.e. the number of characters in it. name.find( 'ola' ) returns the position in which the first occurrence of 'ola' begins, or -1 if it is not found (see also rfind which searches from the back of the string towards the front). Miscellaneous commands you should try out (because they will probably be useful on assignments!): name.count('p') name[2].isalpha() ':'.join(['abc','def','ghi']) \"867-395-0892\".split('-') \" Tim Topper \".strip() 40*\"+\"","title":"What can you do with a string?"},{"location":"05_Lists_and_Strings/05_Example_cd_shuffle/","text":"Example: CD Shuffle A slightly dated problem Most CD players have shuffle or random functionality in which they play the tracks on the CD in random order, but play each track exactly once. One way for them to do this is to scan the CD to see how many tracks there are on it, and then to generate a playlist of the order in which to play the tracks. For example if there are 6 tracks on the disc the playlist might be [3, 5, 2, 1, 6, 4]. We'd like to write a program to generate random playlists. Solution 1 A good starting point: Imagine we have to do this by hand. Our goal is to write down a playlist on a sheet of paper. But how to make the list random? If we use the CD above with 6 tracks on it we can roll a die to choose the tracks. For example let's say we roll it and get 4, we write 4 down as the first track on our playlist. We roll it again and get 1, so we write 1 down, then on the next roll we get 5 and write that down. On the next roll we roll 1 again, but since we already have 1 on our playlist we don't record it again, we just continue rolling. How long do we continue rolling? Until all 6 numbers have appeared on our playlist. Let's try writing this down in pseudocode form, Initialize playlist (like getting a blank sheet of paper) Until you have six numbers in the playlist Roll the die If the value of the die is not in the playlist Add it to the playlist This translates into the following Python, playlist = [] while len(playlist) < 6: tracknum = random.randint(1,6) if tracknum not in playlist: playlist.append(tracknum) print(playlist) To more easily see how the English translates into Python here they are side-by-side, Pseudocode: Initialize playlist Until you have six numbers in the playlist Roll the die If the value of the die is not in the playlist Add it to the playlist display the playlist Python code: playlist = [] while len(playlist) < 6: tracknum = random.randint(1,6) if tracknum not in playlist: playlist.append(tracknum) print(playlist) Wait! What about that 6? Not all CDs have exactly 6 tracks. We'll need to replace that by an appropriate variable name and get its value from the user. The result is, Exercise . Try the program out. Does it work for all values of tracks ? What would be good test values? 1 Solution 2 An alternative approach takes its inspiration from the button name, i.e. \"shuffle\". If it says to shuffle why not do just that? We can imagine having cards with the track numbers on them and shuffling those cards until they're mixed up. How would we do this in Python? We'll start with an ordered list of the track numbers, then we'll shuffle the list. We can shuffle it by choosing one item in the list at random and moving it to the end of the list. If we do that a bunch of times we'll end up with a shuffled list. The pseudocode is, Generate an ordered list of the track numbers Shuffle it to generate the playlist by selecting a random track from the list, and moving it to the end of the list. Translating into Python gives us, Be sure you understand each of the Python statements and how they are accurate translations of the pseudocode. Solution 3 Another approach combines features of both solutions. Like the first one it builds the playlist up from nothing and like the second one it selects tracks at random from an initially full playlist. The pseudocode is, Generate an ordered list of the track numbers. Initialize the playlist. Until the ordered list is empty, Select a random track from the ordered list, and move it to the playlist. This avoids the inefficiency of the first solution when it generates numbers that are already in the playlist 1 . This one will never do that because it only chooses from the remaining track numbers. It also avoids the inefficiency of the second one which has to shuffle many times to be sure it has sufficiently scrambled the original list. The Python translation is, The number of duplicate generations goes up with the length of the list. Here's an instrumented version of the program that displays the number of duplicates generated as a function of list length. We call it \u201cinstrumented\u201d because of the addition of the variable loops that is measuring its performance by counting iterations, and the addition of the initial for loop that is forcing tracks to take on the values we are interested in measuring. Run it and see how quickly the number of duplicates grows; even at 10 tracks we can get 26 duplicates. # CDShuffle_dupes.py import random print('tracks | dupes') print('-------+------') for tracks in [1,2,5,10,20,50,100]: loops = 0 playlist = [] while len(playlist) < tracks: tracknum = random.randint(1,tracks) loops = loops + 1 if tracknum not in playlist: playlist.append(tracknum) dupes = loops - tracks print(f\"{tracks:4d} |{dupes:5d}\") (For reliable output it should really run the program multiple times for each value of tracks, but this program is meant to be illustrative rather than a definitive measuring device.) Remember \"Test at the edges\" so after trying a couple of typical values like 6 and 10, it would be good to try 2, 1, and even 0. \u21a9 \u21a9","title":"Example: CD Shuffle"},{"location":"05_Lists_and_Strings/05_Example_cd_shuffle/#example-cd-shuffle","text":"","title":"Example: CD Shuffle"},{"location":"05_Lists_and_Strings/05_Example_cd_shuffle/#a-slightly-dated-problem","text":"Most CD players have shuffle or random functionality in which they play the tracks on the CD in random order, but play each track exactly once. One way for them to do this is to scan the CD to see how many tracks there are on it, and then to generate a playlist of the order in which to play the tracks. For example if there are 6 tracks on the disc the playlist might be [3, 5, 2, 1, 6, 4]. We'd like to write a program to generate random playlists.","title":"A slightly dated problem"},{"location":"05_Lists_and_Strings/05_Example_cd_shuffle/#solution-1","text":"A good starting point: Imagine we have to do this by hand. Our goal is to write down a playlist on a sheet of paper. But how to make the list random? If we use the CD above with 6 tracks on it we can roll a die to choose the tracks. For example let's say we roll it and get 4, we write 4 down as the first track on our playlist. We roll it again and get 1, so we write 1 down, then on the next roll we get 5 and write that down. On the next roll we roll 1 again, but since we already have 1 on our playlist we don't record it again, we just continue rolling. How long do we continue rolling? Until all 6 numbers have appeared on our playlist. Let's try writing this down in pseudocode form, Initialize playlist (like getting a blank sheet of paper) Until you have six numbers in the playlist Roll the die If the value of the die is not in the playlist Add it to the playlist This translates into the following Python, playlist = [] while len(playlist) < 6: tracknum = random.randint(1,6) if tracknum not in playlist: playlist.append(tracknum) print(playlist) To more easily see how the English translates into Python here they are side-by-side, Pseudocode: Initialize playlist Until you have six numbers in the playlist Roll the die If the value of the die is not in the playlist Add it to the playlist display the playlist Python code: playlist = [] while len(playlist) < 6: tracknum = random.randint(1,6) if tracknum not in playlist: playlist.append(tracknum) print(playlist) Wait! What about that 6? Not all CDs have exactly 6 tracks. We'll need to replace that by an appropriate variable name and get its value from the user. The result is, Exercise . Try the program out. Does it work for all values of tracks ? What would be good test values? 1","title":"Solution 1"},{"location":"05_Lists_and_Strings/05_Example_cd_shuffle/#solution-2","text":"An alternative approach takes its inspiration from the button name, i.e. \"shuffle\". If it says to shuffle why not do just that? We can imagine having cards with the track numbers on them and shuffling those cards until they're mixed up. How would we do this in Python? We'll start with an ordered list of the track numbers, then we'll shuffle the list. We can shuffle it by choosing one item in the list at random and moving it to the end of the list. If we do that a bunch of times we'll end up with a shuffled list. The pseudocode is, Generate an ordered list of the track numbers Shuffle it to generate the playlist by selecting a random track from the list, and moving it to the end of the list. Translating into Python gives us, Be sure you understand each of the Python statements and how they are accurate translations of the pseudocode.","title":"Solution 2"},{"location":"05_Lists_and_Strings/05_Example_cd_shuffle/#solution-3","text":"Another approach combines features of both solutions. Like the first one it builds the playlist up from nothing and like the second one it selects tracks at random from an initially full playlist. The pseudocode is, Generate an ordered list of the track numbers. Initialize the playlist. Until the ordered list is empty, Select a random track from the ordered list, and move it to the playlist. This avoids the inefficiency of the first solution when it generates numbers that are already in the playlist 1 . This one will never do that because it only chooses from the remaining track numbers. It also avoids the inefficiency of the second one which has to shuffle many times to be sure it has sufficiently scrambled the original list. The Python translation is, The number of duplicate generations goes up with the length of the list. Here's an instrumented version of the program that displays the number of duplicates generated as a function of list length. We call it \u201cinstrumented\u201d because of the addition of the variable loops that is measuring its performance by counting iterations, and the addition of the initial for loop that is forcing tracks to take on the values we are interested in measuring. Run it and see how quickly the number of duplicates grows; even at 10 tracks we can get 26 duplicates. # CDShuffle_dupes.py import random print('tracks | dupes') print('-------+------') for tracks in [1,2,5,10,20,50,100]: loops = 0 playlist = [] while len(playlist) < tracks: tracknum = random.randint(1,tracks) loops = loops + 1 if tracknum not in playlist: playlist.append(tracknum) dupes = loops - tracks print(f\"{tracks:4d} |{dupes:5d}\") (For reliable output it should really run the program multiple times for each value of tracks, but this program is meant to be illustrative rather than a definitive measuring device.) Remember \"Test at the edges\" so after trying a couple of typical values like 6 and 10, it would be good to try 2, 1, and even 0. \u21a9 \u21a9","title":"Solution 3"},{"location":"05_Lists_and_Strings/06_Dice_odds/","text":"Dice Odds Imagine that before we go on vacation to Vegas we want to bone up on some of the relevant odds. Let's start with the frequency of various outcomes when rolling a pair of dice. We could do this by rolling a pair of fair dice many times and recording (counting!) how many times each outcome occurs. There are 11 possible outcomes because we can observe anywhere from 2 to 12 spots on the pair of dice. This means we need to record how many twos occur, how many threes occur, how many fours occur, and so on up to how many twelves occur. Solution 1: Without lists Without using lists we could do it like this: import random ROLLS = 1000 # Initialize counters to 0. twos = 0 threes = 0 fours = 0 fives = 0 sixes = 0 sevens = 0 eights = 0 nines = 0 tens = 0 elevens = 0 twelves = 0 # Roll dice many times and record frequency of outcomes. for roll in range(ROLLS): outcome = random.randint(1, 6) + random.randint(1, 6) if outcome == 2: twos = twos + 1 elif outcome == 3: threes = threes + 1 elif outcome == 4: fours = fours + 1 elif outcome == 5: fives = fives + 1 elif outcome == 6: sixes = sixes + 1 elif outcome == 7: sevens = sevens + 1 elif outcome == 8: eights = eights + 1 elif outcome == 9: nines = nines + 1 elif outcome == 10: tens = tens + 1 elif outcome == 11: elevens = elevens + 1 else: twelves = twelves + 1 # Display results. print(\" =====================\") print(\" Outcome | Occurrences\") print(\" --------+------------\") print(f\" 2 |{twos:8d}\") print(f\" 3 |{threes:8d}\") print(f\" 4 |{fours:8d}\") print(f\" 5 |{fives:8d}\") print(f\" 6 |{sixes:8d}\") print(f\" 7 |{sevens:8d}\") print(f\" 8 |{eights:8d}\") print(f\" 9 |{nines:8d}\") print(f\" 10 |{tens:8d}\") print(f\" 11 |{elevens:8d}\") print(f\" 12 |{twelves:8d}\") print(\" ---------------------\") which produces output like this, >>> ===================== Outcome | Occurrences --------+------------ 2 | 29 3 | 66 4 | 71 5 | 100 6 | 137 7 | 173 8 | 132 9 | 122 10 | 78 11 | 59 12 | 33 --------------------- >>> The code is straightforward but lengthy, and relatively slow, because of the cascade of if s. On average it will take 5 and a half comparisons before finding the correct counter to increment. (We could do somewhat better if we reordered the tests in decreasing order of frequency, but if we knew their frequencies, we probably wouldn't be writing the code in the first place!). Solution 2: Using lists These operations can be done more compactly and quickly using a list of counters . We'll let each item in the list count one of the outcomes so we'll need eleven entries in the list all initialized to 0. Then instead of using logic tests to identify the counter to increment we can use the outcome value as an index to directly access the appropriate counter. import random ROLLS = 1000 # Initialize counters to 0. counters = [0] * 11 # Roll dice many times and record frequency of outcomes. for roll in range(ROLLS): outcome = random.randint(1, 6) + random.randint(1, 6) # Now increment the appropriate counter. # Notice that no testing is needed because we can calculate the index of the matching entry. counters[outcome-2] = counters[outcome-2] + 1 # Display results. print(\" =====================\") print(\" Outcome | Occurrences\") print(\" --------+------------\") for posn in range(11): print(f\"{posn+2:7d} |{counters[posn]:8d}\") print(\" ---------------------\") Notes: Notice the syntax used to initialize the list to contain 11 values of 0. The index of counters inside the loop is outcome-2 because lists are indexed from 0, but our first outcome value is 2 (not 0), so we need to subtract 2 from the outcome to get the matching entry in the list. This way we'll map outcome 2 to counter 0, outcome 3 to counter 1, and so on up to outcome 12 mapping onto counter 10. Notice how the body of the output table can also be generated compactly thanks to the list. The verdict Without list Using list 52 lines of code 12 lines of code Average 5.5 tests to select counter to increment. Exactly one calculation to select counter to increment.","title":"Dice Odds"},{"location":"05_Lists_and_Strings/06_Dice_odds/#dice-odds","text":"Imagine that before we go on vacation to Vegas we want to bone up on some of the relevant odds. Let's start with the frequency of various outcomes when rolling a pair of dice. We could do this by rolling a pair of fair dice many times and recording (counting!) how many times each outcome occurs. There are 11 possible outcomes because we can observe anywhere from 2 to 12 spots on the pair of dice. This means we need to record how many twos occur, how many threes occur, how many fours occur, and so on up to how many twelves occur.","title":"Dice Odds"},{"location":"05_Lists_and_Strings/06_Dice_odds/#solution-1-without-lists","text":"Without using lists we could do it like this: import random ROLLS = 1000 # Initialize counters to 0. twos = 0 threes = 0 fours = 0 fives = 0 sixes = 0 sevens = 0 eights = 0 nines = 0 tens = 0 elevens = 0 twelves = 0 # Roll dice many times and record frequency of outcomes. for roll in range(ROLLS): outcome = random.randint(1, 6) + random.randint(1, 6) if outcome == 2: twos = twos + 1 elif outcome == 3: threes = threes + 1 elif outcome == 4: fours = fours + 1 elif outcome == 5: fives = fives + 1 elif outcome == 6: sixes = sixes + 1 elif outcome == 7: sevens = sevens + 1 elif outcome == 8: eights = eights + 1 elif outcome == 9: nines = nines + 1 elif outcome == 10: tens = tens + 1 elif outcome == 11: elevens = elevens + 1 else: twelves = twelves + 1 # Display results. print(\" =====================\") print(\" Outcome | Occurrences\") print(\" --------+------------\") print(f\" 2 |{twos:8d}\") print(f\" 3 |{threes:8d}\") print(f\" 4 |{fours:8d}\") print(f\" 5 |{fives:8d}\") print(f\" 6 |{sixes:8d}\") print(f\" 7 |{sevens:8d}\") print(f\" 8 |{eights:8d}\") print(f\" 9 |{nines:8d}\") print(f\" 10 |{tens:8d}\") print(f\" 11 |{elevens:8d}\") print(f\" 12 |{twelves:8d}\") print(\" ---------------------\") which produces output like this, >>> ===================== Outcome | Occurrences --------+------------ 2 | 29 3 | 66 4 | 71 5 | 100 6 | 137 7 | 173 8 | 132 9 | 122 10 | 78 11 | 59 12 | 33 --------------------- >>> The code is straightforward but lengthy, and relatively slow, because of the cascade of if s. On average it will take 5 and a half comparisons before finding the correct counter to increment. (We could do somewhat better if we reordered the tests in decreasing order of frequency, but if we knew their frequencies, we probably wouldn't be writing the code in the first place!).","title":"Solution 1: Without lists"},{"location":"05_Lists_and_Strings/06_Dice_odds/#solution-2-using-lists","text":"These operations can be done more compactly and quickly using a list of counters . We'll let each item in the list count one of the outcomes so we'll need eleven entries in the list all initialized to 0. Then instead of using logic tests to identify the counter to increment we can use the outcome value as an index to directly access the appropriate counter. import random ROLLS = 1000 # Initialize counters to 0. counters = [0] * 11 # Roll dice many times and record frequency of outcomes. for roll in range(ROLLS): outcome = random.randint(1, 6) + random.randint(1, 6) # Now increment the appropriate counter. # Notice that no testing is needed because we can calculate the index of the matching entry. counters[outcome-2] = counters[outcome-2] + 1 # Display results. print(\" =====================\") print(\" Outcome | Occurrences\") print(\" --------+------------\") for posn in range(11): print(f\"{posn+2:7d} |{counters[posn]:8d}\") print(\" ---------------------\") Notes: Notice the syntax used to initialize the list to contain 11 values of 0. The index of counters inside the loop is outcome-2 because lists are indexed from 0, but our first outcome value is 2 (not 0), so we need to subtract 2 from the outcome to get the matching entry in the list. This way we'll map outcome 2 to counter 0, outcome 3 to counter 1, and so on up to outcome 12 mapping onto counter 10. Notice how the body of the output table can also be generated compactly thanks to the list.","title":"Solution 2: Using lists"},{"location":"05_Lists_and_Strings/06_Dice_odds/#the-verdict","text":"Without list Using list 52 lines of code 12 lines of code Average 5.5 tests to select counter to increment. Exactly one calculation to select counter to increment.","title":"The verdict"},{"location":"05_Lists_and_Strings/07_Bar_graphs/","text":"The Problem What we have is a list of numbers, say [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] and we would like to draw a bar graph of them like this, *** ******* ******** ********** ************** ************** *********** *********** ********* ****** ** Version 1 The pseudocode to do so might look like this, for each value in the list draw a bar of value asterisks which could be translated into the following Python, data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] for datum in data: print(datum * '*') Note: The use of * as a string repetition operator. The difference between the two asterisks in the second line: the first is an operator; the second is a string literal. Version 2 The graph doesn't look like much, even for a text graphics chart. Let's dress it up one step at a time. First we'll display the data value in front of the bar: data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] for datum in data: print(datum, datum * '*') To produce, 3 *** 7 ******* 8 ******** 10 ********** 14 ************** 14 ************** 11 *********** 11 *********** 9 ********* 6 ****** 2 ** Version 3 This is a little better, but the bars don't all start in the same place. We need to place our data values in fixed length fields. For this data we could do this, data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] for datum in data: print(f\"{datum:2d}\", datum * '*') and get this, 3 *** 7 ******* 8 ******** 10 ********** 14 ************** 14 ************** 11 *********** 11 *********** 9 ********* 6 ****** 2 ** but a width of 2 wouldn't work well for larger values. It would be better to find the largest value in the list and then use the length of that value as the field width. We can do that using the built-in function max to find the field width and then converting that value to a string 1 and using the len function to get the length of the string. We can then use that output field width to build an appropriate format string. The resuting code, data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] OFW = len(str(max(data))) # Output Field Width. for datum in data: # use f-string formatting to get the number to format another variable print(f\"{datum:{OFW:d}d}\", datum * '*') produces this graph, 3 *** 7 ******* 8 ******** 10 ********** 14 ************** 14 ************** 11 *********** 11 *********** 9 ********* 6 ****** 2 ** Version 4 But now we have added a potential confusion: are those the values of the bars or the labels of the data? Let's add data labels, and put the values into parentheses so our output will look like this, 2s ( 3) *** 3s ( 7) ******* 4s ( 8) ******** 5s (10) ********** 6s (14) ************** 7s (14) ************** 8s (11) *********** 9s (11) *********** 10s ( 9) ********* 11s ( 6) ****** 12s ( 2) ** Here's the Python code to do it,. data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] labels = ['2s', '3s', '4s', '5s', '6s', '7s', '8s','9s', '10s', '11s', '12s'] OFW = len(str(max(data))) # Output Field Width. label_lens = map(len, labels) # List of label lengths. LFW = max(label_lens) # Label Field Width. for i in range(len(data)): print(f\"{labels[i]:{LFW:d}s}\",f\"({data[i]:{OFW:d}d})\", data[i] * '*') Notes: For more on the map function in line 8 see The map function . The loop discipline is now index-based because we need to loop through the two lists (data and labels) at the same time picking one item from each list. Reading Code It may surprise you to learn that working programmers spend more time reading code than writing it. There's reading their own code of course, but they almost always work on large systems made up of code from many programmers, and since their code needs to work with the existing code, they need to be able to read that existing code. When you work in a production environment you have the use of intelligent editors and debuggers that help you trace through code to see what it is doing, and we will indeed use IDLE's debugger later. For now though we can use the original poor man's debugger: print statements. To understand the code above, paste it into a file and then place an appropriate print statement after each line so you can see the values that are being calculated, e.g. data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] labels = ['2s', '3s', '4s', '5s', '6s', '7s', '8s','9s', '10s', '11s', '12s'] OFW = len(str(max(data))) # Output Field Width. print('OFW = ', OFW) label_lens = map(len, labels) # List of label lengths. print('label_lens = ', label_lens) LFW = max(label_lens) # Label Field Width. print('LFW = ', LFW) for i in range(len(data)): print(f\"{labels[i]:{LFW:d}s}\",f\"({data[i]:{OFW:d}d})\", data[i] * '*') This will produce the output, OFW = 2 label_lens = [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3] LFW = 3 2s ( 3) *** 3s ( 7) ******* 4s ( 8) ******** 5s (10) ********** 6s (14) ************** 7s (14) ************** 8s (11) *********** 9s (11) *********** 10s ( 9) ********* 11s ( 6) ****** 12s ( 2) ** enabling you to see what the calculated values are. Version 5 There is one last refinement worth working on. We were fortunate that all the values in our data set were relatively small, because if any of them had been very large the bars would have wrapped across multiple lines on our screens. The final refinement is to scale the data values if they are larger than the screen is wide so that there will be no wrapped lines. Here's the code to do that. Take the time to understand what it is doing (add in print statements if necessary!). SCREEN_WIDTH = 60 data = [300, 700, 800, 1000, 1400, 1400, 1100, 1100, 900, 600, 200] labels = ['2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s', '10s', '11s', '12s'] OFW = len(str(max(data))) # Output Field Width. label_lens = map(len, labels) # List of label lengths. LFW = max(label_lens) # Label Field Width. MAX_BAR = SCREEN_WIDTH - (OFW+2) - LFW - 2 max_datum = max(data) if max_datum > MAX_BAR: scaled_data = [] for datum in data: scaled_data.append(datum * MAX_BAR // max_datum) for i in range(len(data)): print(f\"{labels[i]:{LFW:d}s}\",f\"({data[i]:{OFW:d}d})\", scaled_data[i] * '*') Notes: Note the new SCREEN_WIDTH constant at the top. This is the total width available for the graphic display. MAX_BAR is the width of the screen leftover after accounting for the space used by the labels and data values. 2 is added to OFW in the calculation of MAX_BAR to account for the ()s around the data value. The final 2 is subtracted to account for the spaces Python automatically inserts into the output after each argument. max_datum is used to avoid multiple calls to the max function each of which would have to traverse the list looking for the maximum value. scaled_data contains the data scaled into the range 0 ... MAX_BAR The corresponding output is, 2s ( 300) ********** 3s ( 700) ************************* 4s ( 800) ***************************** 5s (1000) ************************************ 6s (1400) *************************************************** 7s (1400) *************************************************** 8s (1100) **************************************** 9s (1100) **************************************** 10s ( 900) ******************************** 11s ( 600) ********************* 12s ( 200) ******* Summary While our final output isn't fancy it is a helpful visualization of the original tabular data and it allowed us to experience several common programming issues. More important is the approach demonstrated through the 5 versions of this program: The method of successive refinement . It is much easier to start with a simple program that works and gradually refine it, than to try and design the ideal system at the outset. Later in this course, and even more so in its successor, we will discuss when it is appropriate to use big up front design, and when it is appropriate to use agile design 1 . To read more about this Google \"agile software development\". \u21a9 \u21a9","title":"07 Bar graphs"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#the-problem","text":"What we have is a list of numbers, say [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] and we would like to draw a bar graph of them like this, *** ******* ******** ********** ************** ************** *********** *********** ********* ****** **","title":"The Problem"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#version-1","text":"The pseudocode to do so might look like this, for each value in the list draw a bar of value asterisks which could be translated into the following Python, data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] for datum in data: print(datum * '*') Note: The use of * as a string repetition operator. The difference between the two asterisks in the second line: the first is an operator; the second is a string literal.","title":"Version 1"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#version-2","text":"The graph doesn't look like much, even for a text graphics chart. Let's dress it up one step at a time. First we'll display the data value in front of the bar: data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] for datum in data: print(datum, datum * '*') To produce, 3 *** 7 ******* 8 ******** 10 ********** 14 ************** 14 ************** 11 *********** 11 *********** 9 ********* 6 ****** 2 **","title":"Version 2"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#version-3","text":"This is a little better, but the bars don't all start in the same place. We need to place our data values in fixed length fields. For this data we could do this, data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] for datum in data: print(f\"{datum:2d}\", datum * '*') and get this, 3 *** 7 ******* 8 ******** 10 ********** 14 ************** 14 ************** 11 *********** 11 *********** 9 ********* 6 ****** 2 ** but a width of 2 wouldn't work well for larger values. It would be better to find the largest value in the list and then use the length of that value as the field width. We can do that using the built-in function max to find the field width and then converting that value to a string 1 and using the len function to get the length of the string. We can then use that output field width to build an appropriate format string. The resuting code, data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] OFW = len(str(max(data))) # Output Field Width. for datum in data: # use f-string formatting to get the number to format another variable print(f\"{datum:{OFW:d}d}\", datum * '*') produces this graph, 3 *** 7 ******* 8 ******** 10 ********** 14 ************** 14 ************** 11 *********** 11 *********** 9 ********* 6 ****** 2 **","title":"Version 3"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#version-4","text":"But now we have added a potential confusion: are those the values of the bars or the labels of the data? Let's add data labels, and put the values into parentheses so our output will look like this, 2s ( 3) *** 3s ( 7) ******* 4s ( 8) ******** 5s (10) ********** 6s (14) ************** 7s (14) ************** 8s (11) *********** 9s (11) *********** 10s ( 9) ********* 11s ( 6) ****** 12s ( 2) ** Here's the Python code to do it,. data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] labels = ['2s', '3s', '4s', '5s', '6s', '7s', '8s','9s', '10s', '11s', '12s'] OFW = len(str(max(data))) # Output Field Width. label_lens = map(len, labels) # List of label lengths. LFW = max(label_lens) # Label Field Width. for i in range(len(data)): print(f\"{labels[i]:{LFW:d}s}\",f\"({data[i]:{OFW:d}d})\", data[i] * '*') Notes: For more on the map function in line 8 see The map function . The loop discipline is now index-based because we need to loop through the two lists (data and labels) at the same time picking one item from each list.","title":"Version 4"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#reading-code","text":"It may surprise you to learn that working programmers spend more time reading code than writing it. There's reading their own code of course, but they almost always work on large systems made up of code from many programmers, and since their code needs to work with the existing code, they need to be able to read that existing code. When you work in a production environment you have the use of intelligent editors and debuggers that help you trace through code to see what it is doing, and we will indeed use IDLE's debugger later. For now though we can use the original poor man's debugger: print statements. To understand the code above, paste it into a file and then place an appropriate print statement after each line so you can see the values that are being calculated, e.g. data = [3, 7, 8, 10, 14, 14, 11, 11, 9, 6, 2] labels = ['2s', '3s', '4s', '5s', '6s', '7s', '8s','9s', '10s', '11s', '12s'] OFW = len(str(max(data))) # Output Field Width. print('OFW = ', OFW) label_lens = map(len, labels) # List of label lengths. print('label_lens = ', label_lens) LFW = max(label_lens) # Label Field Width. print('LFW = ', LFW) for i in range(len(data)): print(f\"{labels[i]:{LFW:d}s}\",f\"({data[i]:{OFW:d}d})\", data[i] * '*') This will produce the output, OFW = 2 label_lens = [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3] LFW = 3 2s ( 3) *** 3s ( 7) ******* 4s ( 8) ******** 5s (10) ********** 6s (14) ************** 7s (14) ************** 8s (11) *********** 9s (11) *********** 10s ( 9) ********* 11s ( 6) ****** 12s ( 2) ** enabling you to see what the calculated values are.","title":"Reading Code"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#version-5","text":"There is one last refinement worth working on. We were fortunate that all the values in our data set were relatively small, because if any of them had been very large the bars would have wrapped across multiple lines on our screens. The final refinement is to scale the data values if they are larger than the screen is wide so that there will be no wrapped lines. Here's the code to do that. Take the time to understand what it is doing (add in print statements if necessary!). SCREEN_WIDTH = 60 data = [300, 700, 800, 1000, 1400, 1400, 1100, 1100, 900, 600, 200] labels = ['2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s', '10s', '11s', '12s'] OFW = len(str(max(data))) # Output Field Width. label_lens = map(len, labels) # List of label lengths. LFW = max(label_lens) # Label Field Width. MAX_BAR = SCREEN_WIDTH - (OFW+2) - LFW - 2 max_datum = max(data) if max_datum > MAX_BAR: scaled_data = [] for datum in data: scaled_data.append(datum * MAX_BAR // max_datum) for i in range(len(data)): print(f\"{labels[i]:{LFW:d}s}\",f\"({data[i]:{OFW:d}d})\", scaled_data[i] * '*') Notes: Note the new SCREEN_WIDTH constant at the top. This is the total width available for the graphic display. MAX_BAR is the width of the screen leftover after accounting for the space used by the labels and data values. 2 is added to OFW in the calculation of MAX_BAR to account for the ()s around the data value. The final 2 is subtracted to account for the spaces Python automatically inserts into the output after each argument. max_datum is used to avoid multiple calls to the max function each of which would have to traverse the list looking for the maximum value. scaled_data contains the data scaled into the range 0 ... MAX_BAR The corresponding output is, 2s ( 300) ********** 3s ( 700) ************************* 4s ( 800) ***************************** 5s (1000) ************************************ 6s (1400) *************************************************** 7s (1400) *************************************************** 8s (1100) **************************************** 9s (1100) **************************************** 10s ( 900) ******************************** 11s ( 600) ********************* 12s ( 200) *******","title":"Version 5"},{"location":"05_Lists_and_Strings/07_Bar_graphs/#summary","text":"While our final output isn't fancy it is a helpful visualization of the original tabular data and it allowed us to experience several common programming issues. More important is the approach demonstrated through the 5 versions of this program: The method of successive refinement . It is much easier to start with a simple program that works and gradually refine it, than to try and design the ideal system at the outset. Later in this course, and even more so in its successor, we will discuss when it is appropriate to use big up front design, and when it is appropriate to use agile design 1 . To read more about this Google \"agile software development\". \u21a9 \u21a9","title":"Summary"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/","text":"Representing Playing Cards In addition to computational uses such as arrays of counters, lists can also be used to represent real-world \u201cobjects\u201d, in particular composite objects that have multiple components. Consider representing a deck of playing cards. A deck of cards is made up of many similar, but not identical, objects. Plainly a deck of cards cannot be easily represented by a single integer, string or floating point value because it has so many constituents, but an ordered list seems like a promising alternative. Our representation: The simplest thing that could possibly work A standard deck of playing cards consists of 52 unique cards. Each card combines one of 13 face values (Ace up to King) and one of four suits (Clubs, Diamonds, Hearts and Spades). If we agree on the ordering of face values and suits then we could just refer to each card by a number from 0 to 51, i.e. card 0 is the Ace of Clubs, card 3 is the 4 of Clubs, and card 50 is the Queen of Spades. If we follow standard contract bridge ordering we would number the cards as follows, 0 Ace Clubs 13 Ace Diamonds 26 Ace Hearts 39 Ace Spades 1 Two Clubs 14 Two Diamonds 27 Two Hearts 40 Two Spades 2 Three Clubs 15 Three Diamonds 28 Three Hearts 41 Three Spades 3 Four Clubs 16 Four Diamonds 29 Four Hearts 42 Four Spades 4 Five Clubs 17 Five Diamonds 30 Five Hearts 43 Five Spades 5 Six Clubs 18 Six Diamonds 31 Six Hearts 44 Six Spades 6 Seven Clubs 19 Seven Diamonds 32 Seven Hearts 45 Seven Spades 7 Eight Clubs 20 Eight Diamonds 33 Eight Hearts 46 Eight Spades 8 Nine Clubs 21 Nine Diamonds 34 Nine Hearts 47 Nine Spades 9 Ten Clubs 22 Ten Diamonds 35 Ten Hearts 48 Ten Spades 10 Jack Clubs 23 Jack Diamonds 36 Jack Hearts 49 Jack Spades 11 Queen Clubs 24 Queen Diamonds 37 Queen Hearts 50 Queen Spades 12 King Clubs 25 King Diamonds 38 King Hearts 51 King Spades And a new ordered full deck of cards would be represented by the list, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..., 47, 48, 49, 50, 51] So in Python we can initialize a full deck just by saying: deck = list(range(52)) since the range command produces a range object, which can be cast to the list above. To work with the card numbers we'll need to be able to figure out the suit and face value of a card given its card number. Suit from card number To get the suit a card belongs to from its card number consider how the suits are grouped: 0 Clubs 13 Diamonds 26 Hearts 39 Spades 1 Clubs 14 Diamonds 27 Hearts 40 Spades 2 Clubs 15 Diamonds 28 Hearts 41 Spades 3 Clubs 16 Diamonds 29 Hearts 42 Spades 4 Clubs 17 Diamonds 30 Hearts 43 Spades 5 Clubs 18 Diamonds 31 Hearts 44 Spades 6 Clubs 19 Diamonds 32 Hearts 45 Spades 7 Clubs 20 Diamonds 33 Hearts 46 Spades 8 Clubs 21 Diamonds 34 Hearts 47 Spades 9 Clubs 22 Diamonds 35 Hearts 48 Spades 10 Clubs 23 Diamonds 36 Hearts 49 Spades 11 Clubs 24 Diamonds 37 Hearts 50 Spades 12 Clubs 25 Diamonds 38 Hearts 51 Spades Solution 1 One way to get the suit from the card number is to test the card number to see which group of 13 (i.e. which suit) it is in. if cardnum < 13 : suit = 'Clubs' elif cardnum < 26 : suit = 'Diamonds' elif cardnum < 39 : suit = 'Hearts' else : suit = 'Spades' Solution 2 An alternative is to get the suit from the card number by dividing the card number by 13. The result tells us which of the groups of 13 our card number is in: suit = cardnum // 13 if suit == 0 : suit = 'Clubs' elif suit == 1 : suit = 'Diamonds' elif suit == 2 : suit = 'Hearts' else : suit = 'Spades' Face value from card number To get the face value from the card number we need to look at where our card occurs within its group of 13. 0 Ace 13 Ace 26 Ace 39 Ace 1 Two 14 Two 27 Two 40 Two 2 Three 15 Three 28 Three 41 Three 3 Four 16 Four 29 Four 42 Four 4 Five 17 Five 30 Five 43 Five 5 Six 18 Six 31 Six 44 Six 6 Seven 19 Seven 32 Seven 45 Seven 7 Eight 20 Eight 33 Eight 46 Eight 8 Nine 21 Nine 34 Nine 47 Nine 9 Ten 22 Ten 35 Ten 48 Ten 10 Jack 23 Jack 36 Jack 49 Jack 11 Queen 24 Queen 37 Queen 50 Queen 12 King 25 King 38 King 51 King Solution 1 We could do this as we did above by writing the logic directly: if cardnum == 0 or cardnum == 13 or cardnum == 26 or cardnum == 39 : face_value = 'Ace' elif cardnum == 1 or cardnum == 14 or cardnum == 27 or cardnum == 40 : face_value = 'Two' elif cardnum == 2 or cardnum == 15 or cardnum == 28 or cardnum == 41 : face_value = 'Three' elif cardnum == 3 or cardnum == 16 or cardnum == 29 or cardnum == 42 : face_value = 'Four' elif cardnum == 4 or cardnum == 17 or cardnum == 30 or cardnum == 43 : face_value = 'Five' elif cardnum == 5 or cardnum == 18 or cardnum == 31 or cardnum == 44 : face_value = 'Six' elif cardnum == 6 or cardnum == 19 or cardnum == 32 or cardnum == 45 : face_value = 'Seven' elif cardnum == 7 or cardnum == 20 or cardnum == 33 or cardnum == 46 : face_value = 'Eight' elif cardnum == 8 or cardnum == 21 or cardnum == 34 or cardnum == 47 : face_value = 'Nine' elif cardnum == 9 or cardnum == 22 or cardnum == 35 or cardnum == 48 : face_value = 'Ten' elif cardnum == 10 or cardnum == 23 or cardnum == 36 or cardnum == 49 : face_value = 'Jack' elif cardnum == 11 or cardnum == 24 or cardnum == 37 or cardnum == 50 : face_value = 'Queen' else: face_value = 'King' Solution 2 Or we could do the same thing using list membership tests instead of equality tests, if cardnum in [0, 13, 26, 39]: face_value = 'Ace' elif cardnum in [1, 14, 27, 40]: face_value = 'Two' elif cardnum in [2, 15, 28, 41]: face_value = 'Three' elif cardnum in [3, 16, 29, 42]: face_value = 'Four' elif cardnum in [4, 17, 30, 43]: face_value = 'Five' elif cardnum in [5, 18, 31, 44]: face_value = 'Six' elif cardnum in [6, 19, 32, 45]: face_value = 'Seven' elif cardnum in [7, 20, 33, 46]: face_value = 'Eight' elif cardnum in [8, 21, 34, 47]: face_value = 'Nine' elif cardnum in [9, 22, 35, 48]: face_value = 'Ten' elif cardnum in [10, 23, 36, 49]: face_value = 'Jack' elif cardnum in [11, 24, 37, 50]: face_value = 'Queen' else: face_value = 'Kind' Solution 3 We could also do it by considering the remainder when we divide the card number by 13. face_value = cardnum % 13 if face_value == 0 : face_value = 'Ace' elif face_value == 1 : face_value = 'Two' elif face_value == 2 : face_value = 'Three' elif face_value == 3 : face_value = 'Four' elif face_value == 4 : face_value = 'Five' elif face_value == 5 : face_value = 'Six' elif face_value == 6 : face_value = 'Seven' elif face_value == 7 : face_value = 'Eight' elif face_value == 8 : face_value = 'Nine' elif face_value == 9 : face_value = 'Ten' elif face_value == 10 : face_value = 'Jack' elif face_value == 11 : face_value = 'Queen' else : face_value = 'King' Solution 4 A different and very compact modification to Solution 3 is to use list lookup instead of if statements. We'll store the face values in a list, and then use the remainder of the division by 13 to access the appropriate entry in the list: FACE_VALUES = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', \\ 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King'] face_value = cardnum % 13 print('The face value of card number', cardnum, 'is', FACE_VALUES[face_value]) Study this code carefully. List lookups like this one are very convenient. They are brief and thus easier to read and understand than the lengthy if cascades above, and the list is easier to edit than either of the previous code-intensive approaches. Now that we can work with individual cards let's move on to working with hands, i.e. groups of cards. Dealing a hand How can we deal a hand of cards from our deck of cards? Solution 1 One approach is to shuffle the cards in the deck and then to deal from the top of deck using the list method pop() . import random # Create the deck of cards. deck = list(range(52)) # Shuffle the deck of cards for swaps in range(104): posn1 = random.randint(0, 51) posn2 = random.randint(0, 51) # Swap the cards at posn1 and posn2 (deck[posn1], deck[posn2]) = (deck[posn2], deck[posn1]) # Create the empty hand. hand = [] # Deal 5 cards from the deck into the hand. for card in range(0, 5): hand.append( deck.pop() ) (You can read about what is going on in the last line of the first for loop in Tuples .) Solution 2 An alternative is to select cards at random from inside the deck to add to the hand. import random deck = list(range(52)) hand = [] for card in range(5) : # Choose the card to deal. posn = random.randint(0, len(deck) - 1) # Append the number at that position to the hand. hand.append(deck[posn]) # Delete that card from the deck. del(deck[posn]) Putting it together Pulling selected pieces together we can write code like this, import random # Define handy string constants. FACE_VALUES = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King'] SUITS = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] # Create deck of cards. deck = list(range(52)) # Create empty hand. hand = [] # Deal 5 cards into hand. for deal in range(5) : posn = random.randint(0, len(deck) - 1) hand.append(deck[posn]) del(deck[posn]) # Display the cards in the hand. for card in hand: print(FACE_VALUES[card % 13], 'of', SUITS[card // 13]) Try it out! Then try making some changes to get a feel for how the code works.","title":"Representing Playing Cards"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#representing-playing-cards","text":"In addition to computational uses such as arrays of counters, lists can also be used to represent real-world \u201cobjects\u201d, in particular composite objects that have multiple components. Consider representing a deck of playing cards. A deck of cards is made up of many similar, but not identical, objects. Plainly a deck of cards cannot be easily represented by a single integer, string or floating point value because it has so many constituents, but an ordered list seems like a promising alternative.","title":"Representing Playing Cards"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#our-representation-the-simplest-thing-that-could-possibly-work","text":"A standard deck of playing cards consists of 52 unique cards. Each card combines one of 13 face values (Ace up to King) and one of four suits (Clubs, Diamonds, Hearts and Spades). If we agree on the ordering of face values and suits then we could just refer to each card by a number from 0 to 51, i.e. card 0 is the Ace of Clubs, card 3 is the 4 of Clubs, and card 50 is the Queen of Spades. If we follow standard contract bridge ordering we would number the cards as follows, 0 Ace Clubs 13 Ace Diamonds 26 Ace Hearts 39 Ace Spades 1 Two Clubs 14 Two Diamonds 27 Two Hearts 40 Two Spades 2 Three Clubs 15 Three Diamonds 28 Three Hearts 41 Three Spades 3 Four Clubs 16 Four Diamonds 29 Four Hearts 42 Four Spades 4 Five Clubs 17 Five Diamonds 30 Five Hearts 43 Five Spades 5 Six Clubs 18 Six Diamonds 31 Six Hearts 44 Six Spades 6 Seven Clubs 19 Seven Diamonds 32 Seven Hearts 45 Seven Spades 7 Eight Clubs 20 Eight Diamonds 33 Eight Hearts 46 Eight Spades 8 Nine Clubs 21 Nine Diamonds 34 Nine Hearts 47 Nine Spades 9 Ten Clubs 22 Ten Diamonds 35 Ten Hearts 48 Ten Spades 10 Jack Clubs 23 Jack Diamonds 36 Jack Hearts 49 Jack Spades 11 Queen Clubs 24 Queen Diamonds 37 Queen Hearts 50 Queen Spades 12 King Clubs 25 King Diamonds 38 King Hearts 51 King Spades And a new ordered full deck of cards would be represented by the list, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..., 47, 48, 49, 50, 51] So in Python we can initialize a full deck just by saying: deck = list(range(52)) since the range command produces a range object, which can be cast to the list above. To work with the card numbers we'll need to be able to figure out the suit and face value of a card given its card number.","title":"Our representation: The simplest thing that could possibly work"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#suit-from-card-number","text":"To get the suit a card belongs to from its card number consider how the suits are grouped: 0 Clubs 13 Diamonds 26 Hearts 39 Spades 1 Clubs 14 Diamonds 27 Hearts 40 Spades 2 Clubs 15 Diamonds 28 Hearts 41 Spades 3 Clubs 16 Diamonds 29 Hearts 42 Spades 4 Clubs 17 Diamonds 30 Hearts 43 Spades 5 Clubs 18 Diamonds 31 Hearts 44 Spades 6 Clubs 19 Diamonds 32 Hearts 45 Spades 7 Clubs 20 Diamonds 33 Hearts 46 Spades 8 Clubs 21 Diamonds 34 Hearts 47 Spades 9 Clubs 22 Diamonds 35 Hearts 48 Spades 10 Clubs 23 Diamonds 36 Hearts 49 Spades 11 Clubs 24 Diamonds 37 Hearts 50 Spades 12 Clubs 25 Diamonds 38 Hearts 51 Spades","title":"Suit from card number"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-1","text":"One way to get the suit from the card number is to test the card number to see which group of 13 (i.e. which suit) it is in. if cardnum < 13 : suit = 'Clubs' elif cardnum < 26 : suit = 'Diamonds' elif cardnum < 39 : suit = 'Hearts' else : suit = 'Spades'","title":"Solution 1"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-2","text":"An alternative is to get the suit from the card number by dividing the card number by 13. The result tells us which of the groups of 13 our card number is in: suit = cardnum // 13 if suit == 0 : suit = 'Clubs' elif suit == 1 : suit = 'Diamonds' elif suit == 2 : suit = 'Hearts' else : suit = 'Spades'","title":"Solution 2"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#face-value-from-card-number","text":"To get the face value from the card number we need to look at where our card occurs within its group of 13. 0 Ace 13 Ace 26 Ace 39 Ace 1 Two 14 Two 27 Two 40 Two 2 Three 15 Three 28 Three 41 Three 3 Four 16 Four 29 Four 42 Four 4 Five 17 Five 30 Five 43 Five 5 Six 18 Six 31 Six 44 Six 6 Seven 19 Seven 32 Seven 45 Seven 7 Eight 20 Eight 33 Eight 46 Eight 8 Nine 21 Nine 34 Nine 47 Nine 9 Ten 22 Ten 35 Ten 48 Ten 10 Jack 23 Jack 36 Jack 49 Jack 11 Queen 24 Queen 37 Queen 50 Queen 12 King 25 King 38 King 51 King","title":"Face value from card number"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-1_1","text":"We could do this as we did above by writing the logic directly: if cardnum == 0 or cardnum == 13 or cardnum == 26 or cardnum == 39 : face_value = 'Ace' elif cardnum == 1 or cardnum == 14 or cardnum == 27 or cardnum == 40 : face_value = 'Two' elif cardnum == 2 or cardnum == 15 or cardnum == 28 or cardnum == 41 : face_value = 'Three' elif cardnum == 3 or cardnum == 16 or cardnum == 29 or cardnum == 42 : face_value = 'Four' elif cardnum == 4 or cardnum == 17 or cardnum == 30 or cardnum == 43 : face_value = 'Five' elif cardnum == 5 or cardnum == 18 or cardnum == 31 or cardnum == 44 : face_value = 'Six' elif cardnum == 6 or cardnum == 19 or cardnum == 32 or cardnum == 45 : face_value = 'Seven' elif cardnum == 7 or cardnum == 20 or cardnum == 33 or cardnum == 46 : face_value = 'Eight' elif cardnum == 8 or cardnum == 21 or cardnum == 34 or cardnum == 47 : face_value = 'Nine' elif cardnum == 9 or cardnum == 22 or cardnum == 35 or cardnum == 48 : face_value = 'Ten' elif cardnum == 10 or cardnum == 23 or cardnum == 36 or cardnum == 49 : face_value = 'Jack' elif cardnum == 11 or cardnum == 24 or cardnum == 37 or cardnum == 50 : face_value = 'Queen' else: face_value = 'King'","title":"Solution 1"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-2_1","text":"Or we could do the same thing using list membership tests instead of equality tests, if cardnum in [0, 13, 26, 39]: face_value = 'Ace' elif cardnum in [1, 14, 27, 40]: face_value = 'Two' elif cardnum in [2, 15, 28, 41]: face_value = 'Three' elif cardnum in [3, 16, 29, 42]: face_value = 'Four' elif cardnum in [4, 17, 30, 43]: face_value = 'Five' elif cardnum in [5, 18, 31, 44]: face_value = 'Six' elif cardnum in [6, 19, 32, 45]: face_value = 'Seven' elif cardnum in [7, 20, 33, 46]: face_value = 'Eight' elif cardnum in [8, 21, 34, 47]: face_value = 'Nine' elif cardnum in [9, 22, 35, 48]: face_value = 'Ten' elif cardnum in [10, 23, 36, 49]: face_value = 'Jack' elif cardnum in [11, 24, 37, 50]: face_value = 'Queen' else: face_value = 'Kind'","title":"Solution 2"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-3","text":"We could also do it by considering the remainder when we divide the card number by 13. face_value = cardnum % 13 if face_value == 0 : face_value = 'Ace' elif face_value == 1 : face_value = 'Two' elif face_value == 2 : face_value = 'Three' elif face_value == 3 : face_value = 'Four' elif face_value == 4 : face_value = 'Five' elif face_value == 5 : face_value = 'Six' elif face_value == 6 : face_value = 'Seven' elif face_value == 7 : face_value = 'Eight' elif face_value == 8 : face_value = 'Nine' elif face_value == 9 : face_value = 'Ten' elif face_value == 10 : face_value = 'Jack' elif face_value == 11 : face_value = 'Queen' else : face_value = 'King'","title":"Solution 3"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-4","text":"A different and very compact modification to Solution 3 is to use list lookup instead of if statements. We'll store the face values in a list, and then use the remainder of the division by 13 to access the appropriate entry in the list: FACE_VALUES = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', \\ 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King'] face_value = cardnum % 13 print('The face value of card number', cardnum, 'is', FACE_VALUES[face_value]) Study this code carefully. List lookups like this one are very convenient. They are brief and thus easier to read and understand than the lengthy if cascades above, and the list is easier to edit than either of the previous code-intensive approaches. Now that we can work with individual cards let's move on to working with hands, i.e. groups of cards.","title":"Solution 4"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#dealing-a-hand","text":"How can we deal a hand of cards from our deck of cards?","title":"Dealing a hand"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-1_2","text":"One approach is to shuffle the cards in the deck and then to deal from the top of deck using the list method pop() . import random # Create the deck of cards. deck = list(range(52)) # Shuffle the deck of cards for swaps in range(104): posn1 = random.randint(0, 51) posn2 = random.randint(0, 51) # Swap the cards at posn1 and posn2 (deck[posn1], deck[posn2]) = (deck[posn2], deck[posn1]) # Create the empty hand. hand = [] # Deal 5 cards from the deck into the hand. for card in range(0, 5): hand.append( deck.pop() ) (You can read about what is going on in the last line of the first for loop in Tuples .)","title":"Solution 1"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#solution-2_2","text":"An alternative is to select cards at random from inside the deck to add to the hand. import random deck = list(range(52)) hand = [] for card in range(5) : # Choose the card to deal. posn = random.randint(0, len(deck) - 1) # Append the number at that position to the hand. hand.append(deck[posn]) # Delete that card from the deck. del(deck[posn])","title":"Solution 2"},{"location":"05_Lists_and_Strings/08_Representing_playing_cards/#putting-it-together","text":"Pulling selected pieces together we can write code like this, import random # Define handy string constants. FACE_VALUES = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King'] SUITS = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] # Create deck of cards. deck = list(range(52)) # Create empty hand. hand = [] # Deal 5 cards into hand. for deal in range(5) : posn = random.randint(0, len(deck) - 1) hand.append(deck[posn]) del(deck[posn]) # Display the cards in the hand. for card in hand: print(FACE_VALUES[card % 13], 'of', SUITS[card // 13]) Try it out! Then try making some changes to get a feel for how the code works.","title":"Putting it together"},{"location":"05_Lists_and_Strings/09_Poker_hands/","text":"Poker hands We've got a hand of cards; what now? Let's suppose we are playing poker and want to know how good our hand is. In the game of Poker the value of a hand is assessed from high to low as shown at Wikipedia . Let's start by seeing how we could write code to detect if our hand is a flush, i.e. that all the cards in the hand are from the same suit. Since the face values of the cards are irrelevant let's create a second list containing just the suit numbers (0 for clubs, 1 for diamonds, 2 for hearts, and 3 for spades) of the cards in our hand. suit_list = [] for card in hand: suit_list.append(card//13) For a typical hand suit_list might look like [1, 0, 3, 0, 2] (for a hand with a diamond, a club, a spade, another diamond and a heart), but for a flush it will look like [1, 1, 1, 1, 1] , i.e. all the numbers will be the same. Solution 1 If the cards in the hand all have the same suit then the suit number of the second card is the same as the suit number of the first, and the suit number of the third card is the same as the suit number of the second, and so on. For a five card hand then we could write our test in Python like this, if suit_list[1] == suit_list[0] and suit_list[2] == suit_list[1] and \\ suit_list[3] == suit_list[2] and suit_list[4] == suit_list[3]: print(\"That's a flush!\") else: print(\"Sorry no flush here.\") But hands in other card games may not always have five cards so let's generalize this code to work for any number of cards in the hand. To generalize the code above to any length of hand we need to place the comparison test into a loop and arrange for the loop to compare each neighbouring pair of cards, e.g. by comparing each card to the one before it. If they are the same then we may have a flush, but if they are different then we definitely do not have a flush. So if we get all the way to the end of suit_list and they were always the same then it is a flush. The way we implement that logic in Python is to use a Boolean flag variable to keep track of whether it is a flush or not. We'll start out assuming the hand is a flush and so set our flush flag variable to be True at the start. As we loop through the hand, if the suit of a card ever differs from that of the previous card we'll set the flag variable to be False . In most hands we will actually set it to False more than once, which doesn't matter as long as it is False at the end. What does matter is that we never set it to True inside the loop or else we may inadvertently reset it to True after setting it to False because of an earlier mismatch. Remember even one mismatch means it isn't a flush! The pseudocode for this is, Set the flag variable flush to True Starting with the second card in the hand and proceeding to the last card in the hand If the suit of this card is NOT the same as the suit of the previous card Set the flag variable flush to False If the flag variable flush is True This is a flush Otherwise This is NOT a flush This can be implemented in Python as, flush = True # Start by assuming it is a flush. # The first test compares the second card to the first card, # so the initial previous card is the first card in the hand. prev_card = suit_list[0] for card in suit_list[1:]: # Note: To loop starting with the second card we use a slice of the list, # that begins in the second position, i.e. position #1. if card != prev_card: # If this card's suit is not the same as the previous one's. flush = False # It's not a flush. prev_card = card # Update previous card: This card will be the previous card # next time around. if flush: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\") We could also implement the same pseudocode using quite different Python statements, e.g. we could loop through suit_list using index position, i.e. accessing each entry by its position index, and dispense with the need for the variable prev_card . flush = True for posn in range(1, len(suit_list)-1): if suit_list[posn] != suit_list[posn-1]: flush = False if flush: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\") Solution 2 Another approach would be to count how many cards there are of each suit. If the count is ever the same as the length of the hand then it's a flush. For example if in a 5 card hand we get 5 diamonds then it's a flush. The pseudocode for this is, Count the number of clubs If the number of clubs equals the number of cards It is a flush Count the number of diamonds If the number of diamonds equals the number of cards It is a flush Count the number of hearts If the number of hearts equals the number of cards It is a flush Count the number of spades If the number of spades equals the number of cards It is a flush There is some obvious repetition above which we can replace with a loop to get, For each suit Count the number of cards in that suit If the number equals the number of cards It is a flush Translating this into Python gives us, flush = False for suit in [0,1,2,3]: count = 0 for card_suit in suit_list: if card_suit == suit: count = count + 1 if count == len(suit_list): flush = True if flush: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\") Solution 3 Yet another approach takes advantage of some of python's built-in list methods. For example the count method counts how often a value occurs in a list. If suit_list represents a flush then the first value in it should occur as many times as there are elements in the list, e.g. 5 times in a 5 card hand. This gives us the very brief, if suit_list.count(suit_list[0]) == len(suit_list): print(\"That's a flush!\") else: print(\"Sorry, no flush here.\") Solution 4 Another approach that leverages Python's built-in list methods begins by noticing that in a flush the first and last values in suit_list are the same, e.g. [ 2 , 2, 2, 2, 2 ]. Of course this can be true of non-flush hands as well, e.g. [ 2 , 1, 3, 0, 2 ], but if we sort the non-flush hand before comparing the first and last values we will catch that, e.g. [ 2 , 1, 3, 0, 2 ] sorted becomes [0, 1, 2 , 2 , 3] and now the first and last values are different. We can do this in Python like this, suit_list.sort() if suit_list[0] == suit_list[len(suit_list) - 1]: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\") Summary With solutions 3 and 4 being so short why waste time on long solutions like 1 and 2? Well not all languages provide the rich set of list methods that Python does, so you may have to resort to approaches like solutions 1 and 2. Also, solutions 1 and 2 showed techniques that are useful in a wide variety of problems: comparing elements of a list pairwise looping from part way through a list to the end looping through a list by index position using flag variables using counters In short because it was good for you, and to remind you that: There's (almost) always more than one way to solve it!","title":"Poker hands"},{"location":"05_Lists_and_Strings/09_Poker_hands/#poker-hands","text":"We've got a hand of cards; what now? Let's suppose we are playing poker and want to know how good our hand is. In the game of Poker the value of a hand is assessed from high to low as shown at Wikipedia . Let's start by seeing how we could write code to detect if our hand is a flush, i.e. that all the cards in the hand are from the same suit. Since the face values of the cards are irrelevant let's create a second list containing just the suit numbers (0 for clubs, 1 for diamonds, 2 for hearts, and 3 for spades) of the cards in our hand. suit_list = [] for card in hand: suit_list.append(card//13) For a typical hand suit_list might look like [1, 0, 3, 0, 2] (for a hand with a diamond, a club, a spade, another diamond and a heart), but for a flush it will look like [1, 1, 1, 1, 1] , i.e. all the numbers will be the same.","title":"Poker hands"},{"location":"05_Lists_and_Strings/09_Poker_hands/#solution-1","text":"If the cards in the hand all have the same suit then the suit number of the second card is the same as the suit number of the first, and the suit number of the third card is the same as the suit number of the second, and so on. For a five card hand then we could write our test in Python like this, if suit_list[1] == suit_list[0] and suit_list[2] == suit_list[1] and \\ suit_list[3] == suit_list[2] and suit_list[4] == suit_list[3]: print(\"That's a flush!\") else: print(\"Sorry no flush here.\") But hands in other card games may not always have five cards so let's generalize this code to work for any number of cards in the hand. To generalize the code above to any length of hand we need to place the comparison test into a loop and arrange for the loop to compare each neighbouring pair of cards, e.g. by comparing each card to the one before it. If they are the same then we may have a flush, but if they are different then we definitely do not have a flush. So if we get all the way to the end of suit_list and they were always the same then it is a flush. The way we implement that logic in Python is to use a Boolean flag variable to keep track of whether it is a flush or not. We'll start out assuming the hand is a flush and so set our flush flag variable to be True at the start. As we loop through the hand, if the suit of a card ever differs from that of the previous card we'll set the flag variable to be False . In most hands we will actually set it to False more than once, which doesn't matter as long as it is False at the end. What does matter is that we never set it to True inside the loop or else we may inadvertently reset it to True after setting it to False because of an earlier mismatch. Remember even one mismatch means it isn't a flush! The pseudocode for this is, Set the flag variable flush to True Starting with the second card in the hand and proceeding to the last card in the hand If the suit of this card is NOT the same as the suit of the previous card Set the flag variable flush to False If the flag variable flush is True This is a flush Otherwise This is NOT a flush This can be implemented in Python as, flush = True # Start by assuming it is a flush. # The first test compares the second card to the first card, # so the initial previous card is the first card in the hand. prev_card = suit_list[0] for card in suit_list[1:]: # Note: To loop starting with the second card we use a slice of the list, # that begins in the second position, i.e. position #1. if card != prev_card: # If this card's suit is not the same as the previous one's. flush = False # It's not a flush. prev_card = card # Update previous card: This card will be the previous card # next time around. if flush: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\") We could also implement the same pseudocode using quite different Python statements, e.g. we could loop through suit_list using index position, i.e. accessing each entry by its position index, and dispense with the need for the variable prev_card . flush = True for posn in range(1, len(suit_list)-1): if suit_list[posn] != suit_list[posn-1]: flush = False if flush: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\")","title":"Solution 1"},{"location":"05_Lists_and_Strings/09_Poker_hands/#solution-2","text":"Another approach would be to count how many cards there are of each suit. If the count is ever the same as the length of the hand then it's a flush. For example if in a 5 card hand we get 5 diamonds then it's a flush. The pseudocode for this is, Count the number of clubs If the number of clubs equals the number of cards It is a flush Count the number of diamonds If the number of diamonds equals the number of cards It is a flush Count the number of hearts If the number of hearts equals the number of cards It is a flush Count the number of spades If the number of spades equals the number of cards It is a flush There is some obvious repetition above which we can replace with a loop to get, For each suit Count the number of cards in that suit If the number equals the number of cards It is a flush Translating this into Python gives us, flush = False for suit in [0,1,2,3]: count = 0 for card_suit in suit_list: if card_suit == suit: count = count + 1 if count == len(suit_list): flush = True if flush: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\")","title":"Solution 2"},{"location":"05_Lists_and_Strings/09_Poker_hands/#solution-3","text":"Yet another approach takes advantage of some of python's built-in list methods. For example the count method counts how often a value occurs in a list. If suit_list represents a flush then the first value in it should occur as many times as there are elements in the list, e.g. 5 times in a 5 card hand. This gives us the very brief, if suit_list.count(suit_list[0]) == len(suit_list): print(\"That's a flush!\") else: print(\"Sorry, no flush here.\")","title":"Solution 3"},{"location":"05_Lists_and_Strings/09_Poker_hands/#solution-4","text":"Another approach that leverages Python's built-in list methods begins by noticing that in a flush the first and last values in suit_list are the same, e.g. [ 2 , 2, 2, 2, 2 ]. Of course this can be true of non-flush hands as well, e.g. [ 2 , 1, 3, 0, 2 ], but if we sort the non-flush hand before comparing the first and last values we will catch that, e.g. [ 2 , 1, 3, 0, 2 ] sorted becomes [0, 1, 2 , 2 , 3] and now the first and last values are different. We can do this in Python like this, suit_list.sort() if suit_list[0] == suit_list[len(suit_list) - 1]: print(\"That's a flush!\") else: print(\"Sorry, no flush here.\")","title":"Solution 4"},{"location":"05_Lists_and_Strings/09_Poker_hands/#summary","text":"With solutions 3 and 4 being so short why waste time on long solutions like 1 and 2? Well not all languages provide the rich set of list methods that Python does, so you may have to resort to approaches like solutions 1 and 2. Also, solutions 1 and 2 showed techniques that are useful in a wide variety of problems: comparing elements of a list pairwise looping from part way through a list to the end looping through a list by index position using flag variables using counters In short because it was good for you, and to remind you that: There's (almost) always more than one way to solve it!","title":"Summary"},{"location":"05_Lists_and_Strings/10_Playing_cards_An_alternative_representation/","text":"Playing Cards: An alternative representation So far we have represented a deck of cards by a list of unique numbers. This made it convenient to initialize using deck = range(52) , but required some work to get a card's suit and face value given its card number. An alternative representation would begin by noting that each card has two characteristics, i.e. a suit and a face value, so perhaps we should represent each card by a pair of values. For example the two of clubs could be represented by the pair of values '2' and 'C' (for clubs) and the Queen of Hearts could be represented by 'Q' and 'H' . A brand new deck would look like: deck = [['A','C'], ['2','C'], ['3','C'], ['4','C'], ['5','C'], ['6','C'], ['7','C'], ['8','C'], ['9','C'], ['10','C'], ['J','C'], ['Q','C'], ['K','C'], ['A','D'], ['2','D'], ['3','D'], ['4','D'], ['5','D'], ['6','D'], ['7','D'], ['8','D'], ['9','D'], ['10','D'], ['J','D'], ['Q','D'], ['K','D'], ['A','H'], ['2','H'], ['3','H'], ['4','H'], ['5','H'], ['6','H'], ['7','H'], ['8','H'], ['9','H'], ['10','H'], ['J','H'], ['Q','H'], ['K','H'], ['A','S'], ['2','S'], ['3','S'], ['4','S'], ['5','S'], ['6','S'], ['7','S'], ['8','S'], ['9','S'], ['10','S'], ['J','S'], ['Q','S'], ['K','S']] This list is both repetitive and long meaning there is a good chance of making an inconspicuous error when typing it in by hand (Quick! Have I made an error above? Can't easily tell? That's the point.) Since there is a clear repetitive pattern in the list we should be able to generate it programmatically. The nature of the pattern is that the first item in the pair goes from 'A', to '2', and on to 'K' four times. The second element changes more slowly. It is 'C' for the first 13 elements, then 'D' for the next 13, then 'H' and finally 'S' for the final 13. This pattern of a slowly changing value and a quickly changing one reminds me of nested loops and suggests this code, FACE_VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] SUITS = ['C', 'D', 'H', 'S'] deck = [] for suit in SUITS : for face_value in FACE_VALUES : deck.append([face_value, suit]) The maxim that there is more than one way to do it applies to data representations just as much as to algorithms!","title":"Playing Cards: An alternative representation"},{"location":"05_Lists_and_Strings/10_Playing_cards_An_alternative_representation/#playing-cards-an-alternative-representation","text":"So far we have represented a deck of cards by a list of unique numbers. This made it convenient to initialize using deck = range(52) , but required some work to get a card's suit and face value given its card number. An alternative representation would begin by noting that each card has two characteristics, i.e. a suit and a face value, so perhaps we should represent each card by a pair of values. For example the two of clubs could be represented by the pair of values '2' and 'C' (for clubs) and the Queen of Hearts could be represented by 'Q' and 'H' . A brand new deck would look like: deck = [['A','C'], ['2','C'], ['3','C'], ['4','C'], ['5','C'], ['6','C'], ['7','C'], ['8','C'], ['9','C'], ['10','C'], ['J','C'], ['Q','C'], ['K','C'], ['A','D'], ['2','D'], ['3','D'], ['4','D'], ['5','D'], ['6','D'], ['7','D'], ['8','D'], ['9','D'], ['10','D'], ['J','D'], ['Q','D'], ['K','D'], ['A','H'], ['2','H'], ['3','H'], ['4','H'], ['5','H'], ['6','H'], ['7','H'], ['8','H'], ['9','H'], ['10','H'], ['J','H'], ['Q','H'], ['K','H'], ['A','S'], ['2','S'], ['3','S'], ['4','S'], ['5','S'], ['6','S'], ['7','S'], ['8','S'], ['9','S'], ['10','S'], ['J','S'], ['Q','S'], ['K','S']] This list is both repetitive and long meaning there is a good chance of making an inconspicuous error when typing it in by hand (Quick! Have I made an error above? Can't easily tell? That's the point.) Since there is a clear repetitive pattern in the list we should be able to generate it programmatically. The nature of the pattern is that the first item in the pair goes from 'A', to '2', and on to 'K' four times. The second element changes more slowly. It is 'C' for the first 13 elements, then 'D' for the next 13, then 'H' and finally 'S' for the final 13. This pattern of a slowly changing value and a quickly changing one reminds me of nested loops and suggests this code, FACE_VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] SUITS = ['C', 'D', 'H', 'S'] deck = [] for suit in SUITS : for face_value in FACE_VALUES : deck.append([face_value, suit])","title":"Playing Cards: An alternative representation"},{"location":"05_Lists_and_Strings/10_Playing_cards_An_alternative_representation/#the-maxim-that-there-is-more-than-one-way-to-do-it-applies-to-data-representations-just-as-much-as-to-algorithms","text":"","title":"The maxim that there is more than one way to do it applies to data representations just as much as to algorithms!"},{"location":"05_Lists_and_Strings/11_What_is_this_x_o_o_x_o_x/","text":"What is this [ [ 'X', 'O', '' ], [ 'O', 'X', 'O' ], [ '', '', 'X'] ] ? Thinking like the computer, we know 52 is an integer value, we know 52.801 is a floating point value because of the decimal point, and we know 'Tim' is a string because of the quotes around it Similarly we know [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] is a list because of the square brackets around it. Yes, it also has square brackets inside it, but ignore those for a moment. What matters is that it has the pattern [ ... stuff ...] which makes it a list. Now what is it a list of? Well the commas separate the items of the list and the things between the commas, i.e. ['X', 'O', '' ] , [ 'O', 'X', 'O' ] and, [ '', '', 'X'] , are all surrounded by square brackets so they are_also_lists. That means that the entire construct is a list of lists . When the sizes of all the lists are the same as they are here (because the outer list has three elements, and each inner element also has three elements) the whole is often called a multi-dimensional list, in this particular case a two-dimensional (2-D) list*. These are also sometimes called arrays, especially in mathematical applications. This 2-D list represents the state of a game of Tic-Tac-Toe. This is easier to see if we write it differently (in a way that is still valid Python by the way) and show it beside the game it is representing. [['X', 'O', ''], X | O | ---+---+--- ['O', 'X', 'O'], O | X | O ---+---+--- [ '', '', 'X']] | | X We access the items in a 2-D list by first choosing the sublist we want and then specifying the item in the sublist we want. For example if we name our 2-D list g , g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] then g[0] refers to the entire first row, i.e. ['X', 'O', '' ] and g[0][1] refers to the second element in that row or 'O' . Here is a table listing the names of each cell in g : g[0][0] g[0][1] g[0][2] g[1][0] g[1][1] g[1][2] g[2][0] g[2][1] g[2][2] The general pattern here is g[ row ][ col ] , i.e. the first index specifies the row, and the second index specifies the column. So we can test to see if someone has won by filling in the top row using code like this, if g[0][0]==g[0][1] and g[0][1]==g[0][2]: print(g[0][0], 'has won!') else: print('No one has won in the top row.') which will display the message, No one has won in the top row. Similarly we can check to see if someone has won along the main (upper-left to lower-right) diagonal with code like this, if g[0][0]==g[1][1] and g[1][1]==g[2][2]: print(g[0][0], 'has won!') else: print('No one has won on the main diagonal.') which will display the message, X has won! Lists can certainly have more than two dimensions, but it gets hard to draw them!","title":"What is this [ [ 'X', 'O', '' ], [ 'O', 'X', 'O' ], [ '', '', 'X'] ] ?"},{"location":"05_Lists_and_Strings/11_What_is_this_x_o_o_x_o_x/#what-is-this-x-o-o-x-o-x","text":"Thinking like the computer, we know 52 is an integer value, we know 52.801 is a floating point value because of the decimal point, and we know 'Tim' is a string because of the quotes around it Similarly we know [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] is a list because of the square brackets around it. Yes, it also has square brackets inside it, but ignore those for a moment. What matters is that it has the pattern [ ... stuff ...] which makes it a list. Now what is it a list of? Well the commas separate the items of the list and the things between the commas, i.e. ['X', 'O', '' ] , [ 'O', 'X', 'O' ] and, [ '', '', 'X'] , are all surrounded by square brackets so they are_also_lists. That means that the entire construct is a list of lists . When the sizes of all the lists are the same as they are here (because the outer list has three elements, and each inner element also has three elements) the whole is often called a multi-dimensional list, in this particular case a two-dimensional (2-D) list*. These are also sometimes called arrays, especially in mathematical applications. This 2-D list represents the state of a game of Tic-Tac-Toe. This is easier to see if we write it differently (in a way that is still valid Python by the way) and show it beside the game it is representing. [['X', 'O', ''], X | O | ---+---+--- ['O', 'X', 'O'], O | X | O ---+---+--- [ '', '', 'X']] | | X We access the items in a 2-D list by first choosing the sublist we want and then specifying the item in the sublist we want. For example if we name our 2-D list g , g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] then g[0] refers to the entire first row, i.e. ['X', 'O', '' ] and g[0][1] refers to the second element in that row or 'O' . Here is a table listing the names of each cell in g : g[0][0] g[0][1] g[0][2] g[1][0] g[1][1] g[1][2] g[2][0] g[2][1] g[2][2] The general pattern here is g[ row ][ col ] , i.e. the first index specifies the row, and the second index specifies the column. So we can test to see if someone has won by filling in the top row using code like this, if g[0][0]==g[0][1] and g[0][1]==g[0][2]: print(g[0][0], 'has won!') else: print('No one has won in the top row.') which will display the message, No one has won in the top row. Similarly we can check to see if someone has won along the main (upper-left to lower-right) diagonal with code like this, if g[0][0]==g[1][1] and g[1][1]==g[2][2]: print(g[0][0], 'has won!') else: print('No one has won on the main diagonal.') which will display the message, X has won! Lists can certainly have more than two dimensions, but it gets hard to draw them!","title":"What is this [ [ 'X', 'O', '' ], [ 'O', 'X', 'O' ], [ '', '', 'X'] ] ?"},{"location":"05_Lists_and_Strings/12_Palindrome/","text":"Palindrome Problem Write a program that inputs a string and determines if it is a palindrome. A palindrome is a string that reads the same forwards or backwards, e.g. \"bob\" and \"madam\". An excellent program would be able to deal with entire phrases by ignoring capitalization, spaces and punctuation in the input, e.g. \"A man, a plan, a canal, Panama!\" is a palindromic phrase and should be identified as such. Solution 1 Ignoring, for the moment, palindromic phrases and focussing instead on words like \"madam\", the striking thing about a palindrome is that it is the same forwards and backwards. That means that the first letter is the same as the last letter, the second letter is the same as the second last letter, etc. In pseudocode, if first_letter == last_letter and second_letter == second_last_letter and ... Then it is a palindrome. else It is NOT a palindrome. Let's move this one step closer to Python by figuring out the indices of those letter positions, if s[0]==s[len(s)-1] and s[1]==s[len(s)-2] and s[2]==s[len(s)-3] and ... Then it is a palindrome. else It is NOT a palindrome. We have enough programming experience by now to see that this solution is unworkable exactly as it is since we don't know ahead of time how many test expressions we need (because we don't know ahead of time how long the string is). But the concept is sound and we can make it workable if we replace the if statement with a loop that iterates through the font half of the string comparing the characters there to their counterparts in the back half of the string. We'll use the same strategy to detect a palindrome that we did to detect a flush in a poker hand : Assume the word is a palindrome and then test to see if we are right. As before we will use a flag variable to keep track. palindrome = True # Our flag variable. for offset values from 0 to len(s)/2 if s[offset] != s[len(s)-1-offset] palindrome = False if palindrome then it is a palindrome else It is NOT a palindrome Now it's a small step to actual Python (long live stepwise refinement!): s = \"madam\" palindrome = True for offset in range(0, len(s)/2): if s[offset] != s[len(s)-1-offset]: palindrome = False if palindrome: print(\"It is a palindrome!\") else: print(\"It is NOT a palindrome.\") Solution 2 Python is often described as a batteries-included language because its built-in libraries are so extensive. We had good luck earlier finding short solutions by leveraging the libraries so let's try that again. A palindrome is a string that is the same forward and backward. That means it is the same as its reverse. So, another approach would be to build the reverse of a string and compare it to the original. If they are the same then it's a palindrome. Lists have a built-in reverse method, but unfortunately strings don't (because they are immutable they can't have a method that changes them). Still, perhaps we can convert our string to a list. Let's try it in the Python shell and see, >>> s = \"madam\" >>> slist = list(s) >>> slist ['m', 'a', 'd', 'a', 'm'] >>> That was easy! Now we can reverse that list, >>> slist.reverse() >>> slist ['m', 'a', 'd', 'a', 'm'] >>> build a string from it and compare that to the original string. (Note that we can't just compare slist and the result of slist.reverse() because reverse changes the list in place , that is it changes slist itself rather than creating a new string). We build a string from a list using a joining string and the string method join . Here's a general example: >>> iplist = ['199', '147', '23', '5'] >>> ip = '.'.join(iplist) >>> ip '199.147.23.5' >>> In our case we want to join our characters without anything between them. We can do that by using the empty string '' (that's two single quotes with nothing between them) as our joining string, >>> s_reversed = ''.join(slist) >>> s_reversed 'madam' >>> Putting all these pieces together we have, s = \"madam\" slist = list(s) slist.reverse() s_reversed = ''.join(slist) if s == s_reversed: print(\"It is a palindrome!\") else: print(\"It is NOT a palindrome.\") Refinements The original problem statement taunted us by saying that \u201cAn excellent program would be able to deal with phrases by ignoring capitalization, spaces and punctuation in the input, e.g. 'A man, a plan, a canal, Panama!' is a palindromic phrase\u201d and it would be nice if our code identified it as such. The trick here is to preprocess the string before letting our code from above at it. What we'll do is take the string and build a new one from it. As we build the new one we will lowercase any capital letters, and exclude any characters that are not alphabetic. The resulting code is, s = \"A man, a plan, a canal, panama.\" print(s, \"becomes...\",end='') s_new = '' for c in s: if c.isalpha(): if c.isupper(): s_new = s_new + c.lower() else: s_new = s_new + c print(s_new) and the output is, >>> A man, a plan, a canal, panama. becomes... amanaplanacanalpanama >>> If we place this code before either of our palindrome tests from above we have a complete, and hopefully excellent , program. Testing So far we have just used \"madam\" and been pleased when our code correctly identified it as a palindrome, but that's not sufficient testing. What would be good additional tests? Well madam is a palindrome with an odd number of letters, but we should also test one with an even number of letters. In addition we should test non-palindromes with both odd, and even numbers of letters. We should also test \"at the edges\". This suggests we test some short strings, perhaps one letter and two letter strings. All one letter strings are palindromes but we should try both palindromic and non-palindromic two letter strings. And of course we should test a string with non-alphabetic characters in it. A good set of test values then would be: madam maam motor moor a oo at A man, a plan, a canal, Panama! Running our program multiple times to test all of these would be tiring so it would be nice if we could automate it. We could do that by putting our test values into a list and looping through it to run all the tests. Thus the testing version of our program might look like this, TESTS = ['madam', 'maam', 'motor', 'moor', 'a', 'oo', 'at', 'A man, a plan, a canal, Panama!'] print('Testing Solution 1:') for s in TESTS: print(s,end=' ') # Preprocess s to lower case and remove non-alphas. s_new = '' for c in s: if c.isalpha(): if c.isupper(): s_new = s_new + c.lower() else: s_new = s_new + c s = s_new # Replace s with s_new. # Test to see if s is a palindrome using Solution 1. palindrome = True for offset in range(0, len(s)//2): if s[offset] != s[len(s)-1-offset]: palindrome = False if palindrome: print(\"is a palindrome!\") else: print(\"is NOT a palindrome.\") This is an awkward way to test our code because we need to edit our original program. Fortunately Python allows us to make our palindrome testing code a stand alone function, and then to embed it into a module that does automatic testing when run on its own, but from which we can import the palindrome function if we need to use it. Creating such modules and functions is the topic of the next course module.","title":"Palindrome"},{"location":"05_Lists_and_Strings/12_Palindrome/#palindrome","text":"","title":"Palindrome"},{"location":"05_Lists_and_Strings/12_Palindrome/#problem","text":"Write a program that inputs a string and determines if it is a palindrome. A palindrome is a string that reads the same forwards or backwards, e.g. \"bob\" and \"madam\". An excellent program would be able to deal with entire phrases by ignoring capitalization, spaces and punctuation in the input, e.g. \"A man, a plan, a canal, Panama!\" is a palindromic phrase and should be identified as such.","title":"Problem"},{"location":"05_Lists_and_Strings/12_Palindrome/#solution-1","text":"Ignoring, for the moment, palindromic phrases and focussing instead on words like \"madam\", the striking thing about a palindrome is that it is the same forwards and backwards. That means that the first letter is the same as the last letter, the second letter is the same as the second last letter, etc. In pseudocode, if first_letter == last_letter and second_letter == second_last_letter and ... Then it is a palindrome. else It is NOT a palindrome. Let's move this one step closer to Python by figuring out the indices of those letter positions, if s[0]==s[len(s)-1] and s[1]==s[len(s)-2] and s[2]==s[len(s)-3] and ... Then it is a palindrome. else It is NOT a palindrome. We have enough programming experience by now to see that this solution is unworkable exactly as it is since we don't know ahead of time how many test expressions we need (because we don't know ahead of time how long the string is). But the concept is sound and we can make it workable if we replace the if statement with a loop that iterates through the font half of the string comparing the characters there to their counterparts in the back half of the string. We'll use the same strategy to detect a palindrome that we did to detect a flush in a poker hand : Assume the word is a palindrome and then test to see if we are right. As before we will use a flag variable to keep track. palindrome = True # Our flag variable. for offset values from 0 to len(s)/2 if s[offset] != s[len(s)-1-offset] palindrome = False if palindrome then it is a palindrome else It is NOT a palindrome Now it's a small step to actual Python (long live stepwise refinement!): s = \"madam\" palindrome = True for offset in range(0, len(s)/2): if s[offset] != s[len(s)-1-offset]: palindrome = False if palindrome: print(\"It is a palindrome!\") else: print(\"It is NOT a palindrome.\")","title":"Solution 1"},{"location":"05_Lists_and_Strings/12_Palindrome/#solution-2","text":"Python is often described as a batteries-included language because its built-in libraries are so extensive. We had good luck earlier finding short solutions by leveraging the libraries so let's try that again. A palindrome is a string that is the same forward and backward. That means it is the same as its reverse. So, another approach would be to build the reverse of a string and compare it to the original. If they are the same then it's a palindrome. Lists have a built-in reverse method, but unfortunately strings don't (because they are immutable they can't have a method that changes them). Still, perhaps we can convert our string to a list. Let's try it in the Python shell and see, >>> s = \"madam\" >>> slist = list(s) >>> slist ['m', 'a', 'd', 'a', 'm'] >>> That was easy! Now we can reverse that list, >>> slist.reverse() >>> slist ['m', 'a', 'd', 'a', 'm'] >>> build a string from it and compare that to the original string. (Note that we can't just compare slist and the result of slist.reverse() because reverse changes the list in place , that is it changes slist itself rather than creating a new string). We build a string from a list using a joining string and the string method join . Here's a general example: >>> iplist = ['199', '147', '23', '5'] >>> ip = '.'.join(iplist) >>> ip '199.147.23.5' >>> In our case we want to join our characters without anything between them. We can do that by using the empty string '' (that's two single quotes with nothing between them) as our joining string, >>> s_reversed = ''.join(slist) >>> s_reversed 'madam' >>> Putting all these pieces together we have, s = \"madam\" slist = list(s) slist.reverse() s_reversed = ''.join(slist) if s == s_reversed: print(\"It is a palindrome!\") else: print(\"It is NOT a palindrome.\")","title":"Solution 2"},{"location":"05_Lists_and_Strings/12_Palindrome/#refinements","text":"The original problem statement taunted us by saying that \u201cAn excellent program would be able to deal with phrases by ignoring capitalization, spaces and punctuation in the input, e.g. 'A man, a plan, a canal, Panama!' is a palindromic phrase\u201d and it would be nice if our code identified it as such. The trick here is to preprocess the string before letting our code from above at it. What we'll do is take the string and build a new one from it. As we build the new one we will lowercase any capital letters, and exclude any characters that are not alphabetic. The resulting code is, s = \"A man, a plan, a canal, panama.\" print(s, \"becomes...\",end='') s_new = '' for c in s: if c.isalpha(): if c.isupper(): s_new = s_new + c.lower() else: s_new = s_new + c print(s_new) and the output is, >>> A man, a plan, a canal, panama. becomes... amanaplanacanalpanama >>> If we place this code before either of our palindrome tests from above we have a complete, and hopefully excellent , program.","title":"Refinements"},{"location":"05_Lists_and_Strings/12_Palindrome/#testing","text":"So far we have just used \"madam\" and been pleased when our code correctly identified it as a palindrome, but that's not sufficient testing. What would be good additional tests? Well madam is a palindrome with an odd number of letters, but we should also test one with an even number of letters. In addition we should test non-palindromes with both odd, and even numbers of letters. We should also test \"at the edges\". This suggests we test some short strings, perhaps one letter and two letter strings. All one letter strings are palindromes but we should try both palindromic and non-palindromic two letter strings. And of course we should test a string with non-alphabetic characters in it. A good set of test values then would be: madam maam motor moor a oo at A man, a plan, a canal, Panama! Running our program multiple times to test all of these would be tiring so it would be nice if we could automate it. We could do that by putting our test values into a list and looping through it to run all the tests. Thus the testing version of our program might look like this, TESTS = ['madam', 'maam', 'motor', 'moor', 'a', 'oo', 'at', 'A man, a plan, a canal, Panama!'] print('Testing Solution 1:') for s in TESTS: print(s,end=' ') # Preprocess s to lower case and remove non-alphas. s_new = '' for c in s: if c.isalpha(): if c.isupper(): s_new = s_new + c.lower() else: s_new = s_new + c s = s_new # Replace s with s_new. # Test to see if s is a palindrome using Solution 1. palindrome = True for offset in range(0, len(s)//2): if s[offset] != s[len(s)-1-offset]: palindrome = False if palindrome: print(\"is a palindrome!\") else: print(\"is NOT a palindrome.\") This is an awkward way to test our code because we need to edit our original program. Fortunately Python allows us to make our palindrome testing code a stand alone function, and then to embed it into a module that does automatic testing when run on its own, but from which we can import the palindrome function if we need to use it. Creating such modules and functions is the topic of the next course module.","title":"Testing"},{"location":"05_Lists_and_Strings/13_Built_in_type_conversions/","text":"Built-in Type Conversions The built-in type names can be used as functions to convert a value from one type to another. What happens is that the type name triggers the specified type's constructor to build a new object from the given existing one. >>> int(4.5) # Build an int from the floating point value 4.5 4 >>> float(4) # Build a floating point value from the integer value 4 4.0 >>> str(4) # Build a string from the integer 4 '4' >>> int('4') # Build an integer from the string '4' 4 >>> float(\"4\") # Build a floating point value from the string \"4\" 4.0 >>> list(\"Tim\") # Build a list from the string \"Tim\" ['T', 'i', 'm'] >>> str(['no','more']) # Build a string from a list of strings. \"['no', 'more']\" >>> # ^But you just get the printable representation of the list. >>> list(4) # Build a list from the integer 4. Traceback (most recent call last): File \"<pyshell#68>\", line 1, in -toplevel- list(4) TypeError: iteration over non-sequence >>> # ^But it can't be done. Note that some conversions are not helpful (in the second last case the programmer probably wanted to concatenate the two strings and so should have used the string method join ), and others are not possible (as in the last example of trying to build a list from an int ).","title":"Built-in Type Conversions"},{"location":"05_Lists_and_Strings/13_Built_in_type_conversions/#built-in-type-conversions","text":"The built-in type names can be used as functions to convert a value from one type to another. What happens is that the type name triggers the specified type's constructor to build a new object from the given existing one. >>> int(4.5) # Build an int from the floating point value 4.5 4 >>> float(4) # Build a floating point value from the integer value 4 4.0 >>> str(4) # Build a string from the integer 4 '4' >>> int('4') # Build an integer from the string '4' 4 >>> float(\"4\") # Build a floating point value from the string \"4\" 4.0 >>> list(\"Tim\") # Build a list from the string \"Tim\" ['T', 'i', 'm'] >>> str(['no','more']) # Build a string from a list of strings. \"['no', 'more']\" >>> # ^But you just get the printable representation of the list. >>> list(4) # Build a list from the integer 4. Traceback (most recent call last): File \"<pyshell#68>\", line 1, in -toplevel- list(4) TypeError: iteration over non-sequence >>> # ^But it can't be done. Note that some conversions are not helpful (in the second last case the programmer probably wanted to concatenate the two strings and so should have used the string method join ), and others are not possible (as in the last example of trying to build a list from an int ).","title":"Built-in Type Conversions"},{"location":"05_Lists_and_Strings/14_The_map_function/","text":"The map() function The map function (seen in Bar Graph ) can simplify some list processing. The command, map(fn, seq) builds a new list from an existing one by applying the function fn to every member of the sequence seq . For example if you have the list of strings, names = ['Tim', 'Mary', 'Stephanie', 'Bob'] , and want a list of the lengths of those strings map is just the ticket. It creates a map object that can be cast to a list: >>> names = ['Tim', 'Mary', 'Stephanie', 'Bob'] >>> len_list = map(len, names) >>> list(len_list) [3, 4, 9, 3] >>> map doesn't do anything magical it just replaces the loop construction, len_list = [] for item in names: len_list.append(len(item)) with a more compact, and less error-prone notation. Some languages don't provide a map function in which case you may want to write your own 1 ] since it's so handy. No you don't know how quite yet, but you'll see how in the very next module! \u21a9","title":"The map() function"},{"location":"05_Lists_and_Strings/14_The_map_function/#the-map-function","text":"The map function (seen in Bar Graph ) can simplify some list processing. The command, map(fn, seq) builds a new list from an existing one by applying the function fn to every member of the sequence seq . For example if you have the list of strings, names = ['Tim', 'Mary', 'Stephanie', 'Bob'] , and want a list of the lengths of those strings map is just the ticket. It creates a map object that can be cast to a list: >>> names = ['Tim', 'Mary', 'Stephanie', 'Bob'] >>> len_list = map(len, names) >>> list(len_list) [3, 4, 9, 3] >>> map doesn't do anything magical it just replaces the loop construction, len_list = [] for item in names: len_list.append(len(item)) with a more compact, and less error-prone notation. Some languages don't provide a map function in which case you may want to write your own 1 ] since it's so handy. No you don't know how quite yet, but you'll see how in the very next module! \u21a9","title":"The map() function"},{"location":"05_Lists_and_Strings/15_Tuples/","text":"Tuples In Representing Playing Cards there was the unfamiliar line, (deck[posn1], deck[posn2]) = (deck[posn2], deck[posn1]) The items on each side of the equals sign are tuples . You know you are looking at a tuple because of the round parentheses , i.e. () , surrounding it 1 . Tuples are a bit of an odd duck data type. They work much like lists, except that they are immutable, i.e. they can't be changed (which means that many list methods can't be applied to them). What use is a list you can't change? Not very much generally, but there are some special cases where that combination of properties is just the ticket. This is one of them, so let's get back to that code. What is this code (deck[posn1], deck[posn2]) = (deck[posn2], deck[posn1]) doing? It is swapping the values of deck[posn1] and deck[posn2] . A simpler example would be, >>> a = 5 # set the value of a >>> b = 1 # set the value of b >>> (a,b) = (b,a) # swap the values of a and b >>> print(a) 1 >>> print(b) 5 >>> Here a tuple is created on the right side and unpacked into the target tuple on the left hand side. The statement says, reading it left to right, assign the names a and b the values named by b and a . The magic of tuple packing and unpacking makes this seem to happen in parallel so no values get overwritten before their time. The net effect is to swap the names on the values 5 and 1. Now you should be able to look at the earlier deck code and see what it is doing. Swapping in other languages Tuples are a Python oddity. In most other languages you swap variables using a temporary variable. To do the second swap above you would do something like, a = 5 b = 1 ... temp = a a = b b = temp Language lawyers will point out that the tuple constructor is the comma, not the parentheses and they'd be right, but standard practice is to surround tuples with a more visible marker like ()s, which I will do, and so will you! \u21a9","title":"Tuples"},{"location":"05_Lists_and_Strings/15_Tuples/#tuples","text":"In Representing Playing Cards there was the unfamiliar line, (deck[posn1], deck[posn2]) = (deck[posn2], deck[posn1]) The items on each side of the equals sign are tuples . You know you are looking at a tuple because of the round parentheses , i.e. () , surrounding it 1 . Tuples are a bit of an odd duck data type. They work much like lists, except that they are immutable, i.e. they can't be changed (which means that many list methods can't be applied to them). What use is a list you can't change? Not very much generally, but there are some special cases where that combination of properties is just the ticket. This is one of them, so let's get back to that code. What is this code (deck[posn1], deck[posn2]) = (deck[posn2], deck[posn1]) doing? It is swapping the values of deck[posn1] and deck[posn2] . A simpler example would be, >>> a = 5 # set the value of a >>> b = 1 # set the value of b >>> (a,b) = (b,a) # swap the values of a and b >>> print(a) 1 >>> print(b) 5 >>> Here a tuple is created on the right side and unpacked into the target tuple on the left hand side. The statement says, reading it left to right, assign the names a and b the values named by b and a . The magic of tuple packing and unpacking makes this seem to happen in parallel so no values get overwritten before their time. The net effect is to swap the names on the values 5 and 1. Now you should be able to look at the earlier deck code and see what it is doing.","title":"Tuples"},{"location":"05_Lists_and_Strings/15_Tuples/#swapping-in-other-languages","text":"Tuples are a Python oddity. In most other languages you swap variables using a temporary variable. To do the second swap above you would do something like, a = 5 b = 1 ... temp = a a = b b = temp Language lawyers will point out that the tuple constructor is the comma, not the parentheses and they'd be right, but standard practice is to surround tuples with a more visible marker like ()s, which I will do, and so will you! \u21a9","title":"Swapping in other languages"},{"location":"05_Lists_and_Strings/90_Assignment_5/","text":"Assignment 5 Problems Tic-Tac-Toe Write a program that looks at a list of lists representing a Tic-Tac-Toe game, determines if someone has won, and if so says who. (You can assume the game state has arisen in the course of a legal game). Embed your code in the file a5p1kate.py Dedup Write a program that removes duplicate values from a list, i.e. if the list starts out as [4, 2, 5, 2, 4] , then after your code fragment runs it should be [4, 2, 5] . Embed your code in the file a5p2kate.py (A real-life application would be to remove duplicates from a list of IP addresses so you have a list of unique visitors to your site. In this case the list might look like [ '10.9.0.31', '199.247.52.3', '10.9.0.31', '43.98.12.4', '72.1.3.55', '199.247.52.3', ...] ). Poker Full House Write a program that decides if a list of card numbers is a full house. A full house is a hand in which 3 cards share one face value and the other two share a different face value, e.g. three sevens and two aces. For example the list [6, 32, 39, 0, 45] is a full house because cards 6, 32 and 45 are sevens and cards 39 and 0 are aces. (See Wikipedia for more examples). Use the first representation shown in the module notes, i.e. the one in Representing Playing Cards . Do not remove your test values from the program so I can see how thoroughly you tested your code. Feel free to adapt one of the test frameworks from the problems above to help you in testing your code. Password checker Most computer systems require the user to select a password. Unfortunately many users, perhaps most, choose poor passwords, i.e. passwords that are easily guessed, or that can be looked up in a dictionary. Weak passwords present security problems because they compromise the integrity of the system. To avoid weak passwords many systems now test the password the user types, and decide whether to accept it or not. Here is an (abbreviated) excerpt from a manual describing the process on one actual system (where the name of the password program is passwd ). Think of this as the specification for your program and try to implement it as precisely as possible (if you detect ambiguities in it be sure to ask for clarification). When used to change a password, passwd prompts everyone for their old password, if any. It then prompts for the new password twice. If the two copies are not identical the cycle of prompting for the new password is repeated for at most two more times. When the two copies are identical a check is made to ensure that the new password meets construction requirements. Passwords must be constructed to meet the following requirements: Each password must have at least six characters. Each password must contain at least one lower-case alphabetic character. Each password must contain at least one upper-case alphabetic character. Each password must contain at least one numeric or special character. Each password must differ from the user's login name and the reverse of that login name. For this comparison, an upper case letter and its corresponding lower case letter are equivalent. New passwords must differ from the old in at least three positions (for this comparison, an upper case letter and its corresponding lower case letter are equivalent). Write a program that behaves as specified by this excerpt. Notes: \"Alphabetic\" refers to all upper or lower case letters. (These requirements ensure they do not use a \"word\", i.e. a string that could be looked up in a dictionary, or their phone/SIN/etc. number -- two common choices). The real passwd program, after validating the proposed new password, encrypts it and writes it to a file, but we're omitting that final step ... for now! In actual use the program would make a \u201csystem call\u201d to get the current user's login name. Since we have not seen how to do this yet, your program will have to read in the login name. Here are a couple of sample outputs generated by running a solution program: ============================================= Password Checker --------------------------------------------- Enter the login name: ttopper Enter your current password: sp33dKills Enter new password: duckie Confirm new password: duvkie New passwords do not match! Try again. Enter new password: duckie Confirm new password: duckie Password must contain at least one upper case letter. Password not acceptable. Password not changed. Done. ============================================= Password Checker --------------------------------------------- Enter the login name: ttopper Enter your current password: sp33dKills Enter new password: d1cT10nary Confirm new password: d1cT10nary Password changed. Done. Not the friendliest exchanges in the world, but hopefully clear enough. Logistics Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So your solution to problem 1 on this assignment will be named a5p1bob.py and your solution for problem will be named a5p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Assignment 5"},{"location":"05_Lists_and_Strings/90_Assignment_5/#assignment-5","text":"","title":"Assignment 5"},{"location":"05_Lists_and_Strings/90_Assignment_5/#problems","text":"","title":"Problems"},{"location":"05_Lists_and_Strings/90_Assignment_5/#tic-tac-toe","text":"Write a program that looks at a list of lists representing a Tic-Tac-Toe game, determines if someone has won, and if so says who. (You can assume the game state has arisen in the course of a legal game). Embed your code in the file a5p1kate.py","title":"Tic-Tac-Toe"},{"location":"05_Lists_and_Strings/90_Assignment_5/#dedup","text":"Write a program that removes duplicate values from a list, i.e. if the list starts out as [4, 2, 5, 2, 4] , then after your code fragment runs it should be [4, 2, 5] . Embed your code in the file a5p2kate.py (A real-life application would be to remove duplicates from a list of IP addresses so you have a list of unique visitors to your site. In this case the list might look like [ '10.9.0.31', '199.247.52.3', '10.9.0.31', '43.98.12.4', '72.1.3.55', '199.247.52.3', ...] ).","title":"Dedup"},{"location":"05_Lists_and_Strings/90_Assignment_5/#poker-full-house","text":"Write a program that decides if a list of card numbers is a full house. A full house is a hand in which 3 cards share one face value and the other two share a different face value, e.g. three sevens and two aces. For example the list [6, 32, 39, 0, 45] is a full house because cards 6, 32 and 45 are sevens and cards 39 and 0 are aces. (See Wikipedia for more examples). Use the first representation shown in the module notes, i.e. the one in Representing Playing Cards . Do not remove your test values from the program so I can see how thoroughly you tested your code. Feel free to adapt one of the test frameworks from the problems above to help you in testing your code.","title":"Poker Full House"},{"location":"05_Lists_and_Strings/90_Assignment_5/#password-checker","text":"Most computer systems require the user to select a password. Unfortunately many users, perhaps most, choose poor passwords, i.e. passwords that are easily guessed, or that can be looked up in a dictionary. Weak passwords present security problems because they compromise the integrity of the system. To avoid weak passwords many systems now test the password the user types, and decide whether to accept it or not. Here is an (abbreviated) excerpt from a manual describing the process on one actual system (where the name of the password program is passwd ). Think of this as the specification for your program and try to implement it as precisely as possible (if you detect ambiguities in it be sure to ask for clarification). When used to change a password, passwd prompts everyone for their old password, if any. It then prompts for the new password twice. If the two copies are not identical the cycle of prompting for the new password is repeated for at most two more times. When the two copies are identical a check is made to ensure that the new password meets construction requirements. Passwords must be constructed to meet the following requirements: Each password must have at least six characters. Each password must contain at least one lower-case alphabetic character. Each password must contain at least one upper-case alphabetic character. Each password must contain at least one numeric or special character. Each password must differ from the user's login name and the reverse of that login name. For this comparison, an upper case letter and its corresponding lower case letter are equivalent. New passwords must differ from the old in at least three positions (for this comparison, an upper case letter and its corresponding lower case letter are equivalent). Write a program that behaves as specified by this excerpt. Notes: \"Alphabetic\" refers to all upper or lower case letters. (These requirements ensure they do not use a \"word\", i.e. a string that could be looked up in a dictionary, or their phone/SIN/etc. number -- two common choices). The real passwd program, after validating the proposed new password, encrypts it and writes it to a file, but we're omitting that final step ... for now! In actual use the program would make a \u201csystem call\u201d to get the current user's login name. Since we have not seen how to do this yet, your program will have to read in the login name. Here are a couple of sample outputs generated by running a solution program: ============================================= Password Checker --------------------------------------------- Enter the login name: ttopper Enter your current password: sp33dKills Enter new password: duckie Confirm new password: duvkie New passwords do not match! Try again. Enter new password: duckie Confirm new password: duckie Password must contain at least one upper case letter. Password not acceptable. Password not changed. Done. ============================================= Password Checker --------------------------------------------- Enter the login name: ttopper Enter your current password: sp33dKills Enter new password: d1cT10nary Confirm new password: d1cT10nary Password changed. Done. Not the friendliest exchanges in the world, but hopefully clear enough.","title":"Password checker"},{"location":"05_Lists_and_Strings/90_Assignment_5/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So your solution to problem 1 on this assignment will be named a5p1bob.py and your solution for problem will be named a5p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Logistics"},{"location":"06_Functions/","text":"Introduction: Coding in chunks \ud83e\uddf1 How time flies \u2014 at the end of this module you'll be halfway through the course material! Brian Kernighan says that \u201c Controlling complexity is the essence of computer programming \u201d and this week we start to look at language features that allow us to control complexity. Hopefully you have noticed that your longer programs, for example the password checking program, are made up of \"chunks\" of code that almost stand on their own. Programming languages give you a way to isolate these chunks so you can focus on writing them one at a time (reducing the complexity of what you have to think about, win) and then give them names so you can reuse them (reducing the complexity of writing future programs, win-win!). Sometimes we reuse one chunk multiple times in the same program, for example we've written several programs that call random.randint() more than once, and sometimes we reuse chunks of code in multiple programs. Python provides three ways of chunking \u2014 functions, classes and modules \u2014 and this week we'll cover functions and modules, and develop some \u201cchunks\u201d for working with playing cards. Modularization Functions Writing functions: is_even() Writing functions: Syntax summary s_odd() Example: dice_roll() Default Arguments Playing Card Functions 1 Reusing Functions Modules Documenting modules and functions Summary: Module Layout Example: Playing Card Functions 2 Refining import Scope The Perils of Mutability* Reference Semantics Using versus changing a list Copying a list List comprehensions What are these pyc files? Finding the Standard Library Modules Assignment 6","title":"Introduction: Coding in chunks \ud83e\uddf1"},{"location":"06_Functions/#introduction-coding-in-chunks","text":"How time flies \u2014 at the end of this module you'll be halfway through the course material! Brian Kernighan says that \u201c Controlling complexity is the essence of computer programming \u201d and this week we start to look at language features that allow us to control complexity. Hopefully you have noticed that your longer programs, for example the password checking program, are made up of \"chunks\" of code that almost stand on their own. Programming languages give you a way to isolate these chunks so you can focus on writing them one at a time (reducing the complexity of what you have to think about, win) and then give them names so you can reuse them (reducing the complexity of writing future programs, win-win!). Sometimes we reuse one chunk multiple times in the same program, for example we've written several programs that call random.randint() more than once, and sometimes we reuse chunks of code in multiple programs. Python provides three ways of chunking \u2014 functions, classes and modules \u2014 and this week we'll cover functions and modules, and develop some \u201cchunks\u201d for working with playing cards. Modularization Functions Writing functions: is_even() Writing functions: Syntax summary s_odd() Example: dice_roll() Default Arguments Playing Card Functions 1 Reusing Functions Modules Documenting modules and functions Summary: Module Layout Example: Playing Card Functions 2 Refining import Scope The Perils of Mutability* Reference Semantics Using versus changing a list Copying a list List comprehensions What are these pyc files? Finding the Standard Library Modules Assignment 6","title":"Introduction: Coding in chunks \ud83e\uddf1"},{"location":"06_Functions/01_Modularization/","text":"Modularization The first module in this course introduced the six essential imperative programming operations. There were three simple statements, input gets a value from the input stream and stores it in memory. processing processes/combines/manipulates values stored in memory and stores the result in memory output sends a value to the output stream and three control structures, sequential processing in which statements are executed one at a time in sequence selection in which one group of statements or another, but not both, are executed repetition in which a group of statements is executed repeatedly I also introduced one \u201cbonus\u201d structure: modularity . Many modern computer scientists would take issue with the bonus characterization and argue that modularization is perhaps the most fundamental structure provided by modern programming languages. I do not disagree with their assessment. I refer to the other control structures as essential because it is logically impossible to write all programs without each and every one of them. It is possible to write a program without modularization, but extremely difficult, and the resulting program if it was ever successfully written and tested would be very difficult to modify or maintain. Why is modularization so important? Because it enables us to reduce the complexity of our programs, while at the same time allowing us to create reusable chunks of code . We reduce complexity by using a divide and conquer strategy, i.e. taking a large program and dividing it into smaller, more manageable, pieces. If we choose our pieces carefully, we can accumulate a collection of modules that are reusable. This saves us time on future projects by allowing us to avoid reinventing the wheel. Reducing complexity is important because there is a (small) limit to the number of things the human brain can think about at once. Cognitive psychologists often peg the capacity of short term memory at 7 plus or minus two items, because people can on average only recall between 5 and 9 items from a sequence they are given to remember. This biological limitation makes it very difficult to think about problems involving a dozen units, much less ones involving hundreds of disparate parts. One way of organizing the complexity of a large system is to divide it into hierarchies that only have a handful of items on any given level. This division is modularization. Dividing a problem well, i.e. in a way that makes the problem simpler to solve, is a skill that is developed through practice and by studying examples. As we tackle different programming problems and projects we will build up a storehouse of modules. If we modularize our problems well we will develop a toolkit of reusable modules that we can use in the future to avoid rewriting code we have written before. Choosing modules for reusability is more objective than choosing them to reduce complexity: the main rule is to make each module do one thing, and only one thing, well, and to avoid side effects. We avoid side effects by having each module restrict its actions to as narrow a domain as possible. Python enables modularization through the use of functions , classes , and modules . In this module of the course we will consider the first and third of these, i.e. functions and modules. The second item, classes, is the subject of the entire third part of the course.","title":"Modularization"},{"location":"06_Functions/01_Modularization/#modularization","text":"The first module in this course introduced the six essential imperative programming operations. There were three simple statements, input gets a value from the input stream and stores it in memory. processing processes/combines/manipulates values stored in memory and stores the result in memory output sends a value to the output stream and three control structures, sequential processing in which statements are executed one at a time in sequence selection in which one group of statements or another, but not both, are executed repetition in which a group of statements is executed repeatedly I also introduced one \u201cbonus\u201d structure: modularity . Many modern computer scientists would take issue with the bonus characterization and argue that modularization is perhaps the most fundamental structure provided by modern programming languages. I do not disagree with their assessment. I refer to the other control structures as essential because it is logically impossible to write all programs without each and every one of them. It is possible to write a program without modularization, but extremely difficult, and the resulting program if it was ever successfully written and tested would be very difficult to modify or maintain. Why is modularization so important? Because it enables us to reduce the complexity of our programs, while at the same time allowing us to create reusable chunks of code . We reduce complexity by using a divide and conquer strategy, i.e. taking a large program and dividing it into smaller, more manageable, pieces. If we choose our pieces carefully, we can accumulate a collection of modules that are reusable. This saves us time on future projects by allowing us to avoid reinventing the wheel. Reducing complexity is important because there is a (small) limit to the number of things the human brain can think about at once. Cognitive psychologists often peg the capacity of short term memory at 7 plus or minus two items, because people can on average only recall between 5 and 9 items from a sequence they are given to remember. This biological limitation makes it very difficult to think about problems involving a dozen units, much less ones involving hundreds of disparate parts. One way of organizing the complexity of a large system is to divide it into hierarchies that only have a handful of items on any given level. This division is modularization. Dividing a problem well, i.e. in a way that makes the problem simpler to solve, is a skill that is developed through practice and by studying examples. As we tackle different programming problems and projects we will build up a storehouse of modules. If we modularize our problems well we will develop a toolkit of reusable modules that we can use in the future to avoid rewriting code we have written before. Choosing modules for reusability is more objective than choosing them to reduce complexity: the main rule is to make each module do one thing, and only one thing, well, and to avoid side effects. We avoid side effects by having each module restrict its actions to as narrow a domain as possible. Python enables modularization through the use of functions , classes , and modules . In this module of the course we will consider the first and third of these, i.e. functions and modules. The second item, classes, is the subject of the entire third part of the course.","title":"Modularization"},{"location":"06_Functions/02_Functions/","text":"Functions So far my description of modularization may seem hopelessly abstract. What do these modules look like? In Python the simplest form of modularization is to create functions. We have already used many of Python's built-in functions, e.g. range() , len() , math.sqrt() , and random.randint() , and now it is time to learn to write our own functions. There is a bit of terminology that will help us talk about functions. We say that \u201cthe function len() when called, returns an integer specified by its argument\u201d. What do the terms called , return , and argument refer to? Consider the specific statement, mismash = [0, True, 3.8, \"Don't Panic\"] print(len(mismash)) To call a function is to invoke it and we do that by entering its name followed by parentheses. The name of the function being used here is len . To do its job it needs to find the length of a list. We tell it which one by providing the list we need to know the length of. This value is the argument to the function. It is sometimes also called the function parameter . The function len will calculate the length of the list 4 . This is the value it returns or its return value . You can imagine the return value replacing the function call so the code above is equivalent to print(4) So every function has, a name a list of parameters enclosed in parentheses after the name of the function (this list may be \"empty\", i.e. there may be no values specified, but the parentheses must still be present to mark the name as specifying a function rather than a variable), and a return value , the value that will replace the expression calling the function (this value may be None if the function does something rather than calculating something ).","title":"Functions"},{"location":"06_Functions/02_Functions/#functions","text":"So far my description of modularization may seem hopelessly abstract. What do these modules look like? In Python the simplest form of modularization is to create functions. We have already used many of Python's built-in functions, e.g. range() , len() , math.sqrt() , and random.randint() , and now it is time to learn to write our own functions. There is a bit of terminology that will help us talk about functions. We say that \u201cthe function len() when called, returns an integer specified by its argument\u201d. What do the terms called , return , and argument refer to? Consider the specific statement, mismash = [0, True, 3.8, \"Don't Panic\"] print(len(mismash)) To call a function is to invoke it and we do that by entering its name followed by parentheses. The name of the function being used here is len . To do its job it needs to find the length of a list. We tell it which one by providing the list we need to know the length of. This value is the argument to the function. It is sometimes also called the function parameter . The function len will calculate the length of the list 4 . This is the value it returns or its return value . You can imagine the return value replacing the function call so the code above is equivalent to print(4) So every function has, a name a list of parameters enclosed in parentheses after the name of the function (this list may be \"empty\", i.e. there may be no values specified, but the parentheses must still be present to mark the name as specifying a function rather than a variable), and a return value , the value that will replace the expression calling the function (this value may be None if the function does something rather than calculating something ).","title":"Functions"},{"location":"06_Functions/03_Writing_functions_is_even/","text":"Writing functions: is_even() We've used several of Python's built-in functions, but how do we write our own? This is most easily shown by example, so to be concrete let's suppose we want a function that tells us if a number is even. It's usually easiest to write a function by starting with how you want to use it. Let's say we are working on a game and wish we could write, num = random.randint(0,100) if is_even(num): print(\"Good news your magic number is even! 10 bonus points for you.\") else: print(\"Bad news, your magic number is odd.\") The good thing about specifying the use of our function before writing it is that now we know, what the name of the function should be: is_even , that it will take one parameter num in our case, that it returns a Boolean value, i.e. either True or False . So we know its name, parameter and return type, and we know from previous experience how to implement its core functionality: if n % 2 == 0: # It's even else: # It's odd All we need now is to tie these things together with the necessary syntax like this, import random def is_even(n): if n % 2 == 0: return True else: return False num = random.randint(0,100) if is_even(num): print(\"Good news your magic number is even! 10 bonus points for you.\") else: print(\"Bad news, your magic number is odd.\") Notes: The keyword def marks the begining of a function definition. It is followed by the name of the function, the parameter list enclosed in parentheses, and a colon. The code to be executed when the function is called is indented after the definition line. The return statement terminates the execution of the function as soon as it is executed and returns the specified value (either True or False above). As you can see above a single function may have more than one return statement. The names of the parameter in the program and in the function do not need to be the same. num in the program is referred to as n in the function. You may wonder looking at the code above what we have gained. After all we have removed num%2 == 0 from an if test and replaced it with 5 lines of code \u2014 this hardly seems simpler! What you can't see in the example above (but will a few examples into the future) is that this new function can be reused easily in other programs. This speaks to why the names of the parameters do not need to be the same in the function and the program \u2014 if they did the function could not be easily reused! Imagine if the built-in square root function could only be used if the variable it was passed was named x . That's not very reusable. Instead the name in the function definition line is aliased to the value named in the call to the function. We can picture memory looking like this before the function is called, Like this while the function is executing (see how n the name of the parameter in the function is an alias for the value of num the name of 48 in the program?), And like this again after the function has terminated, Note that the value of num was not changed by the function and this is as it should be. We don't want a function that decides if a number is even to change the number in the course of deciding. Note also that functions do not leave any lasting trace in memory. When the function terminates, any memory it has been using is freed and returned to the system. This can lead to a third benefit of functions. In some types of programs they reduce memory consumption because memory is only allocated while it is needed, whereas normal variables exist for the entire run of the program (or at least from the time they are created until the end of the program).","title":"Writing functions: is_even()"},{"location":"06_Functions/03_Writing_functions_is_even/#writing-functions-is_even","text":"We've used several of Python's built-in functions, but how do we write our own? This is most easily shown by example, so to be concrete let's suppose we want a function that tells us if a number is even. It's usually easiest to write a function by starting with how you want to use it. Let's say we are working on a game and wish we could write, num = random.randint(0,100) if is_even(num): print(\"Good news your magic number is even! 10 bonus points for you.\") else: print(\"Bad news, your magic number is odd.\") The good thing about specifying the use of our function before writing it is that now we know, what the name of the function should be: is_even , that it will take one parameter num in our case, that it returns a Boolean value, i.e. either True or False . So we know its name, parameter and return type, and we know from previous experience how to implement its core functionality: if n % 2 == 0: # It's even else: # It's odd All we need now is to tie these things together with the necessary syntax like this, import random def is_even(n): if n % 2 == 0: return True else: return False num = random.randint(0,100) if is_even(num): print(\"Good news your magic number is even! 10 bonus points for you.\") else: print(\"Bad news, your magic number is odd.\") Notes: The keyword def marks the begining of a function definition. It is followed by the name of the function, the parameter list enclosed in parentheses, and a colon. The code to be executed when the function is called is indented after the definition line. The return statement terminates the execution of the function as soon as it is executed and returns the specified value (either True or False above). As you can see above a single function may have more than one return statement. The names of the parameter in the program and in the function do not need to be the same. num in the program is referred to as n in the function. You may wonder looking at the code above what we have gained. After all we have removed num%2 == 0 from an if test and replaced it with 5 lines of code \u2014 this hardly seems simpler! What you can't see in the example above (but will a few examples into the future) is that this new function can be reused easily in other programs. This speaks to why the names of the parameters do not need to be the same in the function and the program \u2014 if they did the function could not be easily reused! Imagine if the built-in square root function could only be used if the variable it was passed was named x . That's not very reusable. Instead the name in the function definition line is aliased to the value named in the call to the function. We can picture memory looking like this before the function is called, Like this while the function is executing (see how n the name of the parameter in the function is an alias for the value of num the name of 48 in the program?), And like this again after the function has terminated, Note that the value of num was not changed by the function and this is as it should be. We don't want a function that decides if a number is even to change the number in the course of deciding. Note also that functions do not leave any lasting trace in memory. When the function terminates, any memory it has been using is freed and returned to the system. This can lead to a third benefit of functions. In some types of programs they reduce memory consumption because memory is only allocated while it is needed, whereas normal variables exist for the entire run of the program (or at least from the time they are created until the end of the program).","title":"Writing functions: is_even()"},{"location":"06_Functions/04_Writing_functions_Syntax_summary/","text":"Writing functions: Syntax summary Here is a template for writing Python functions: def function-name ( parameter-list ): ... ... function-body ... return expression ... return expression And here are a couple of guidelines: We prefer to have a single return expression as the last line of the function. If this guideline is followed then other programmers know where to look to find out what value is returned, and don't have to hunt through the function trying to spot all the return points. Having said that this is a preference not a requirement . Some code really is cleaner with multiple return s spread throughout the function, but this is unusual enough that you should do a quick mental check to verify that it is preferable. If you do not include a return statement, the value returned will the special value None , but it is better to be explicit that this is your intention by placing a blank return statement in the function than by just not having one (because then other programmers will not waste brain cycles wondering if you intended to return None , or forgot to include a return ).","title":"Writing functions: Syntax summary"},{"location":"06_Functions/04_Writing_functions_Syntax_summary/#writing-functions-syntax-summary","text":"Here is a template for writing Python functions: def function-name ( parameter-list ): ... ... function-body ... return expression ... return expression And here are a couple of guidelines: We prefer to have a single return expression as the last line of the function. If this guideline is followed then other programmers know where to look to find out what value is returned, and don't have to hunt through the function trying to spot all the return points. Having said that this is a preference not a requirement . Some code really is cleaner with multiple return s spread throughout the function, but this is unusual enough that you should do a quick mental check to verify that it is preferable. If you do not include a return statement, the value returned will the special value None , but it is better to be explicit that this is your intention by placing a blank return statement in the function than by just not having one (because then other programmers will not waste brain cycles wondering if you intended to return None , or forgot to include a return ).","title":"Writing functions: Syntax summary"},{"location":"06_Functions/05_Is_odd/","text":"is_odd() Now consider writing a function is_odd . We could do so by basing it on our approach in is_even , def is_even(n): if n%2 == 0: return True else: return False so is_odd could be written as, def is_odd(n): if n%2 != 0: return True else: return False An alternative would be to base it on is_even itself (rather than just reusing the same approach). Taking this tack we would write is_odd as, def is_odd(n): return not is_even(n) which just calls is_even and negates its return value. Most programmers would prefer the second version even though in it is_odd is no longer a standalone function, but is instead dependent on is_even . Why? Well the second version involves writing less code and the result is shorter. More importantly if someday a better way of determining if a number is even is found only one function needs to be rewritten ( is_even ) and the other ( is_odd ) automatically benefits from the improvement. We are unlikely to find a better way of testing for evenness, but there are many other computationally intensive processes where better methods are continually being developed and the fewer places in our code we need to implement the new methods to take advantage of them the better.","title":"is_odd()"},{"location":"06_Functions/05_Is_odd/#is_odd","text":"Now consider writing a function is_odd . We could do so by basing it on our approach in is_even , def is_even(n): if n%2 == 0: return True else: return False so is_odd could be written as, def is_odd(n): if n%2 != 0: return True else: return False An alternative would be to base it on is_even itself (rather than just reusing the same approach). Taking this tack we would write is_odd as, def is_odd(n): return not is_even(n) which just calls is_even and negates its return value. Most programmers would prefer the second version even though in it is_odd is no longer a standalone function, but is instead dependent on is_even . Why? Well the second version involves writing less code and the result is shorter. More importantly if someday a better way of determining if a number is even is found only one function needs to be rewritten ( is_even ) and the other ( is_odd ) automatically benefits from the improvement. We are unlikely to find a better way of testing for evenness, but there are many other computationally intensive processes where better methods are continually being developed and the fewer places in our code we need to implement the new methods to take advantage of them the better.","title":"is_odd()"},{"location":"06_Functions/06_Example_Dice_roll/","text":"Example: dice_roll() Now suppose we wish to write a function that rolls a die for us. We would like to be able to write code like this, total = dice_roll() + dice_roll() to simulate rolling a pair of dice. What can we tell by looking at this code? the name of our function will be dice_roll it takes no arguments (because there is nothing inside the brackets) it returns something that can be added together and stored (so not None ). This leads to the code, def dice_roll(): return random.randint(1,6) which we could use like this, import random def dice_roll(): return random.randint(1,6) total = dice_roll() + dice_roll() print(\"On your first roll you got:\", total) This code works, but could be improved by being generalized to dice with other than six sides like these (with 4, 6, 8, 12, 20 and 10 sides respectively), We can do that by having our function take an argument specifying the number of sides, import random def dice_roll(sides): return random.randint(1,sides) total = dice_roll(6) + dice_roll(6) print(\"On your first roll you got:\", total)","title":"Example: dice_roll()"},{"location":"06_Functions/06_Example_Dice_roll/#example-dice_roll","text":"Now suppose we wish to write a function that rolls a die for us. We would like to be able to write code like this, total = dice_roll() + dice_roll() to simulate rolling a pair of dice. What can we tell by looking at this code? the name of our function will be dice_roll it takes no arguments (because there is nothing inside the brackets) it returns something that can be added together and stored (so not None ). This leads to the code, def dice_roll(): return random.randint(1,6) which we could use like this, import random def dice_roll(): return random.randint(1,6) total = dice_roll() + dice_roll() print(\"On your first roll you got:\", total) This code works, but could be improved by being generalized to dice with other than six sides like these (with 4, 6, 8, 12, 20 and 10 sides respectively), We can do that by having our function take an argument specifying the number of sides, import random def dice_roll(sides): return random.randint(1,sides) total = dice_roll(6) + dice_roll(6) print(\"On your first roll you got:\", total)","title":"Example: dice_roll()"},{"location":"06_Functions/07_Default_arguments/","text":"Default Arguments On the previous page we improved our dice rolling function so that it could be used for dice with other than 6 sides, however this also made it more complicated to use in the most common case because we have to provide a parameter specifying the number of sides. To avoid this complication Python allows us to specify the default values of arguments. \u201cDefault\u201d in this context means that if a value isn't given the default value is used. Here's our dice rolling function with the default number of sides set to 6. import random def dice_roll(sides = 6): return random.randint(1,sides) print('Your results are:') print('6-sided die:', dice_roll()) print('20-sided die:', dice_roll(20)) and the output from a sample run is: >>> Your results are: 6-sided die: 5 20-sided die: 17 >>> Default argument values are common throughout Python. For example the range function defaults to a starting value of 0 and a stepsize of 1.","title":"Default Arguments"},{"location":"06_Functions/07_Default_arguments/#default-arguments","text":"On the previous page we improved our dice rolling function so that it could be used for dice with other than 6 sides, however this also made it more complicated to use in the most common case because we have to provide a parameter specifying the number of sides. To avoid this complication Python allows us to specify the default values of arguments. \u201cDefault\u201d in this context means that if a value isn't given the default value is used. Here's our dice rolling function with the default number of sides set to 6. import random def dice_roll(sides = 6): return random.randint(1,sides) print('Your results are:') print('6-sided die:', dice_roll()) print('20-sided die:', dice_roll(20)) and the output from a sample run is: >>> Your results are: 6-sided die: 5 20-sided die: 17 >>> Default argument values are common throughout Python. For example the range function defaults to a starting value of 0 and a stepsize of 1.","title":"Default Arguments"},{"location":"06_Functions/08_Playing_card_functions_1/","text":"Playing Card Functions 1 We've worked with playing cards a few times so far and will be doing so again, so it would save us time if we had a standard set of tools for working with them. In programming these tools are a set of functions (and later classes) for manipulating them. Let's start with functions that are passed a card number and return the face value of the card and the suit of the card. Recall that we determine the suit of a card by determining which block of 13 it is in which we find by dividing the card number by thirteen. Similarly we determine the face value of a card by determining its offset within a group of thirteen using modulo. Packing those earlier methods into functions gives us, SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) with output >>> Card 15 is the Three of Diamonds >>> We'll probably have to display card labels, e.g. \u201cThree of Diamonds\u201d, fairly often so let's add a function for that too, SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] def label(cardnum): return face_value(cardnum) + \" of \" + suit(cardnum) card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) print(\"Card\", card, \"is the\", label(card)) to get output like, >>> Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds >>> Note how we reused our suit and face_value functions to define label in the same way we reused is_even to define is_odd earlier. Now if we have to write more programs that work with playing cards (and you will dear student!) we can use these functions and avoid rewriting this common functionality over and over again.","title":"Playing Card Functions 1"},{"location":"06_Functions/08_Playing_card_functions_1/#playing-card-functions-1","text":"We've worked with playing cards a few times so far and will be doing so again, so it would save us time if we had a standard set of tools for working with them. In programming these tools are a set of functions (and later classes) for manipulating them. Let's start with functions that are passed a card number and return the face value of the card and the suit of the card. Recall that we determine the suit of a card by determining which block of 13 it is in which we find by dividing the card number by thirteen. Similarly we determine the face value of a card by determining its offset within a group of thirteen using modulo. Packing those earlier methods into functions gives us, SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) with output >>> Card 15 is the Three of Diamonds >>> We'll probably have to display card labels, e.g. \u201cThree of Diamonds\u201d, fairly often so let's add a function for that too, SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] def label(cardnum): return face_value(cardnum) + \" of \" + suit(cardnum) card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) print(\"Card\", card, \"is the\", label(card)) to get output like, >>> Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds >>> Note how we reused our suit and face_value functions to define label in the same way we reused is_even to define is_odd earlier. Now if we have to write more programs that work with playing cards (and you will dear student!) we can use these functions and avoid rewriting this common functionality over and over again.","title":"Playing Card Functions 1"},{"location":"06_Functions/09_Reusing_functions/","text":"Reusing Functions Now that we've written some reusable functions dealing with playing cards the question arises as to just how we go about reusing them. One way to reuse them would be to open the program file containing them and copy and paste the functions (and the constants SUITS and FACE_VALUES ) into our working program file. But what if we later improve these functions? Then we'd have to recopy and repaste them. The same would apply if (God forbid!) we found a bug that we had to fix in one of these functions. Then we'd have to remember all the programs into which we'd copied and pasted them and replace the buggy versions with the new ones. It would be nice if that copying and pasting could be automated somehow so that code always benefited automatically from improvements to our functions. Well it turns out that automatically copying and pasting code is tricky and thus unreliable. Instead programmers have found the best way to reuse code is to have a way to include the contents (all of them or just some of them) of one file in another. Python does this using modules and the import command. We have already used import to get at functions in the math and random modules. Now we will see how to use it to get at functions we have written in our own programs.","title":"Reusing Functions"},{"location":"06_Functions/09_Reusing_functions/#reusing-functions","text":"Now that we've written some reusable functions dealing with playing cards the question arises as to just how we go about reusing them. One way to reuse them would be to open the program file containing them and copy and paste the functions (and the constants SUITS and FACE_VALUES ) into our working program file. But what if we later improve these functions? Then we'd have to recopy and repaste them. The same would apply if (God forbid!) we found a bug that we had to fix in one of these functions. Then we'd have to remember all the programs into which we'd copied and pasted them and replace the buggy versions with the new ones. It would be nice if that copying and pasting could be automated somehow so that code always benefited automatically from improvements to our functions. Well it turns out that automatically copying and pasting code is tricky and thus unreliable. Instead programmers have found the best way to reuse code is to have a way to include the contents (all of them or just some of them) of one file in another. Python does this using modules and the import command. We have already used import to get at functions in the math and random modules. Now we will see how to use it to get at functions we have written in our own programs.","title":"Reusing Functions"},{"location":"06_Functions/10_Modules/","text":"Modules Any Python program is a module and other programs can use the functions and variables in it (and classes too etc.), but for its contents to be reused easily there are some standard practices to follow. We'll work with our previous program containing the playing card functions and now named playing_cards.py , # playing_cards.py SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) Now suppose that in our new Blackjack program we have a hand of card numbers and would like to display the cards in the hand. We write code like this, # blackjack.py ... print('You are holding,') for card in hand: print('The', label(card)) ... in hopes of generating output like this, You are holding, The Three of Diamonds The Four of Spades The Nine of Clubs A first try One program accesses another program's functions by importing the program, so to be able to use label we need to import playing_cards.py . To access the functions in playing_cards.py we preface the function name with the module name separated by a period . . We need to do this because modules are objects (like lists and strings) and the definitions inside them are their attributes. So label 's full name will be its module name, playing_cards , followed by its function name, label (just like we have done with math.sqrt or random.randint , think of it as a lastname.firstname system for now), # blackjack.py import playing_cards hand = [15, 42, 8] print('You are holding,') for card in hand: print('The', playing_cards.label(card)) Note that when importing a module we omit the .py suffix, as we do when we refer to the module within the program, i.e. import playing_cards instead of import playing_cards.py and playing_cards.label , instead of playing_cards.py.label . A problem This almost works but the output isn't quite what we wanted, >>> Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds You are holding, The Three of Diamonds The Four of Spades The Nine of Clubs >>> We have the output we want, but above it we have extraneous output from playing_cards.py . The reason we get the undesired output is that modules are run upon import , i.e. when you import a module the first thing Python does is to run it. It runs it becuse this interprets the code in the module making the definitions in the file available to the current program. One fix to eliminate the undesired otuput would be to delete the print statements from playing_cards.py . But this is an ugly fix, not an elegant solution. Those print statements in playing_cards.py may be serving a purpose. In fact standard practice is to include code in all modules to test the functions in the module (these are called unit tests ). The last thing we want to do is remove code that tests our module and verifies that it works! A solution Fortunately Python can tell if a program is running on its own or being imported. When it is running on its own, it is assigned the name __main__ . The double underscores are another Python standard practice: they signal that this is an internal Python name. You should never give a variable of your own a name beginning with double underscores. When it is imported on the other hand it is assigned a name based on its file name less the .py suffix. So when we execute playing_cards.py on its own its name is __main__ , but when we import it it's name is playing_cards . Watch. If I add a statement to display the module's __name__ attribute (look for it on line 16) # playing_cards.pySUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] def label(cardnum): return face_value(cardnum) + \" of \" + suit(cardnum) print('My name is', __name__) # Line 16! card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) print(\"Card\", card, \"is the\", label(card)) when I run playing_cards.py it displays, >>> My name is __main__ Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds but when I run blackjack.py look what it says its name is, >>> My name is playing_cards Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds You are holding, The Three of Diamonds The Four of Spades The Nine of Clubs I know this has been a long explanation, but it points us to a simple solution. We will introduce an if test into playing_cards.py that will see what its current name is. If it is __main__ it will run the tests and otherwise it will not. This way the tests will not be run when the file is imported, but are still available by running the module on its own. Our modified playing_cards.py will look like this, # playing_cards.py SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] def label(cardnum): return face_value(cardnum) + \" of \" + suit(cardnum) if __name__ == '__main__': card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) print(\"Card\", card, \"is the\", label(card))","title":"Modules"},{"location":"06_Functions/10_Modules/#modules","text":"Any Python program is a module and other programs can use the functions and variables in it (and classes too etc.), but for its contents to be reused easily there are some standard practices to follow. We'll work with our previous program containing the playing card functions and now named playing_cards.py , # playing_cards.py SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) Now suppose that in our new Blackjack program we have a hand of card numbers and would like to display the cards in the hand. We write code like this, # blackjack.py ... print('You are holding,') for card in hand: print('The', label(card)) ... in hopes of generating output like this, You are holding, The Three of Diamonds The Four of Spades The Nine of Clubs","title":"Modules"},{"location":"06_Functions/10_Modules/#a-first-try","text":"One program accesses another program's functions by importing the program, so to be able to use label we need to import playing_cards.py . To access the functions in playing_cards.py we preface the function name with the module name separated by a period . . We need to do this because modules are objects (like lists and strings) and the definitions inside them are their attributes. So label 's full name will be its module name, playing_cards , followed by its function name, label (just like we have done with math.sqrt or random.randint , think of it as a lastname.firstname system for now), # blackjack.py import playing_cards hand = [15, 42, 8] print('You are holding,') for card in hand: print('The', playing_cards.label(card)) Note that when importing a module we omit the .py suffix, as we do when we refer to the module within the program, i.e. import playing_cards instead of import playing_cards.py and playing_cards.label , instead of playing_cards.py.label .","title":"A first try"},{"location":"06_Functions/10_Modules/#a-problem","text":"This almost works but the output isn't quite what we wanted, >>> Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds You are holding, The Three of Diamonds The Four of Spades The Nine of Clubs >>> We have the output we want, but above it we have extraneous output from playing_cards.py . The reason we get the undesired output is that modules are run upon import , i.e. when you import a module the first thing Python does is to run it. It runs it becuse this interprets the code in the module making the definitions in the file available to the current program. One fix to eliminate the undesired otuput would be to delete the print statements from playing_cards.py . But this is an ugly fix, not an elegant solution. Those print statements in playing_cards.py may be serving a purpose. In fact standard practice is to include code in all modules to test the functions in the module (these are called unit tests ). The last thing we want to do is remove code that tests our module and verifies that it works!","title":"A problem"},{"location":"06_Functions/10_Modules/#a-solution","text":"Fortunately Python can tell if a program is running on its own or being imported. When it is running on its own, it is assigned the name __main__ . The double underscores are another Python standard practice: they signal that this is an internal Python name. You should never give a variable of your own a name beginning with double underscores. When it is imported on the other hand it is assigned a name based on its file name less the .py suffix. So when we execute playing_cards.py on its own its name is __main__ , but when we import it it's name is playing_cards . Watch. If I add a statement to display the module's __name__ attribute (look for it on line 16) # playing_cards.pySUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] def label(cardnum): return face_value(cardnum) + \" of \" + suit(cardnum) print('My name is', __name__) # Line 16! card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) print(\"Card\", card, \"is the\", label(card)) when I run playing_cards.py it displays, >>> My name is __main__ Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds but when I run blackjack.py look what it says its name is, >>> My name is playing_cards Card 15 is the Three of Diamonds Card 15 is the Three of Diamonds You are holding, The Three of Diamonds The Four of Spades The Nine of Clubs I know this has been a long explanation, but it points us to a simple solution. We will introduce an if test into playing_cards.py that will see what its current name is. If it is __main__ it will run the tests and otherwise it will not. This way the tests will not be run when the file is imported, but are still available by running the module on its own. Our modified playing_cards.py will look like this, # playing_cards.py SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] def label(cardnum): return face_value(cardnum) + \" of \" + suit(cardnum) if __name__ == '__main__': card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) print(\"Card\", card, \"is the\", label(card))","title":"A solution"},{"location":"06_Functions/11_Documenting_modules_and_functions/","text":"Documenting modules and functions The goal of documentation is to provide enough information for other programmers (or ourselves in six months!) to know how to use our code (that is to run a program, or import and use its components), and to understand it well enough to verify it and/or modify it. So far our documentation has consisted of a block of header comments identifying the module and programmer, and occasional comments inserted into the code to explain tricky points. Modules and the functions in them require further documentation. The primary mechanism used to provide it is docstrings. These are triple quoted strings that appear at the top of the module and immediately after each function definition. Here's an artificial example, # module_docn.py '''This is the module documentation pointing out that this is an artificial test module.''' def test_fn_1(): '''This is the first test function. It doesn't do anything.''' return def test_fn_2(): '''This is the second test function which also does nothing.''' return In an actual module these docstrings would be helpful to a programmer reading your code by explaining what the module and each function in it were designed to do. You can see lots of real examples in the standard library modules . Python also has built-in commands that extract this documentation. Recall that when we import a module in the shell we can use dir to see it's attributes. Here's an example for a real module, math , >>> import math >>> dir(math) ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'exp2', 'exp1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma','gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc', 'ulp'] >>> and here's the dir for our artificial module, >>> import module_docn >>> dir(module_docn) ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'test_fn_1', 'test_fn_2'] >>> You can see that in addition to the Python reserved names, i.e. __builtins__ to __package__ there are our two functions test_fn_1 and test_fn_2 . We've already seen that the reserved name __name__ gives the current name of this module which will be module_docn if it has been imported or __main__ if it is running. Now let's see what __doc__ is, >>> print(module_docn.__doc__) This is the module documentation pointing out that this is an artificial test module. >>> module_docn.__doc__ contains the module docstring. And now you may see why they are called docstrings: because they are the strings that get assigned to the __doc__ attributes. The docstrings for tst_fn_1 and test_fn_2 are also available in their __doc__ attributes, >>> print(module_docn.test_fn_1.__doc__) This is the first test function. It doesn't do anything. >>> print(module_docn.test_fn_2.__doc__) This is the second test function. It also doesn't do anything. >>> The docstrings are so useful but this is such a cumbersome way to access them that Python provides the built-in command help to provide easy access to them and improve the formatting of their display, e.g. >>> help(module_docn) Help on module module_docn: NAME module_docn DESCRIPTION This is the module documentation pointing out that this is an artificial test module. FUNCTIONS test_fn_1() This is the first test function. It doesn't do anything. test_fn_2() This is the second test function which also does nothing. FILE \\\\home\\profiles\\kreed\\documents\\cpsc128\\programs\\module_docn.py >>> All the information displayed is automatically extracted from the docstrings in the module. The pydoc module which is used behind the scenes by help is also used to produce much of the HTML Python documentation you encounter on the web. Just for completeness I will point out that help can also be used on an individual member function, >>> help(module_docn.test_fn_1) Help on function test_fn_1 in module module_docn: test_fn_1() This is the first test function. It doesn't do anything. >>> or more usefully on real functions, >>> help(math.sqrt) Help on built-in function sqrt in module math: sqrt(...) sqrt(x) Return the square root of x. >>> Summary Place triple quoted docstrings at the top of each module and after each function definition. These should provide provide descriptions of what the module and each function do. Use the help() built-in to access the docstrings of modules and functions you import.","title":"Documenting modules and functions"},{"location":"06_Functions/11_Documenting_modules_and_functions/#documenting-modules-and-functions","text":"The goal of documentation is to provide enough information for other programmers (or ourselves in six months!) to know how to use our code (that is to run a program, or import and use its components), and to understand it well enough to verify it and/or modify it. So far our documentation has consisted of a block of header comments identifying the module and programmer, and occasional comments inserted into the code to explain tricky points. Modules and the functions in them require further documentation. The primary mechanism used to provide it is docstrings. These are triple quoted strings that appear at the top of the module and immediately after each function definition. Here's an artificial example, # module_docn.py '''This is the module documentation pointing out that this is an artificial test module.''' def test_fn_1(): '''This is the first test function. It doesn't do anything.''' return def test_fn_2(): '''This is the second test function which also does nothing.''' return In an actual module these docstrings would be helpful to a programmer reading your code by explaining what the module and each function in it were designed to do. You can see lots of real examples in the standard library modules . Python also has built-in commands that extract this documentation. Recall that when we import a module in the shell we can use dir to see it's attributes. Here's an example for a real module, math , >>> import math >>> dir(math) ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'exp2', 'exp1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma','gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc', 'ulp'] >>> and here's the dir for our artificial module, >>> import module_docn >>> dir(module_docn) ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'test_fn_1', 'test_fn_2'] >>> You can see that in addition to the Python reserved names, i.e. __builtins__ to __package__ there are our two functions test_fn_1 and test_fn_2 . We've already seen that the reserved name __name__ gives the current name of this module which will be module_docn if it has been imported or __main__ if it is running. Now let's see what __doc__ is, >>> print(module_docn.__doc__) This is the module documentation pointing out that this is an artificial test module. >>> module_docn.__doc__ contains the module docstring. And now you may see why they are called docstrings: because they are the strings that get assigned to the __doc__ attributes. The docstrings for tst_fn_1 and test_fn_2 are also available in their __doc__ attributes, >>> print(module_docn.test_fn_1.__doc__) This is the first test function. It doesn't do anything. >>> print(module_docn.test_fn_2.__doc__) This is the second test function. It also doesn't do anything. >>> The docstrings are so useful but this is such a cumbersome way to access them that Python provides the built-in command help to provide easy access to them and improve the formatting of their display, e.g. >>> help(module_docn) Help on module module_docn: NAME module_docn DESCRIPTION This is the module documentation pointing out that this is an artificial test module. FUNCTIONS test_fn_1() This is the first test function. It doesn't do anything. test_fn_2() This is the second test function which also does nothing. FILE \\\\home\\profiles\\kreed\\documents\\cpsc128\\programs\\module_docn.py >>> All the information displayed is automatically extracted from the docstrings in the module. The pydoc module which is used behind the scenes by help is also used to produce much of the HTML Python documentation you encounter on the web. Just for completeness I will point out that help can also be used on an individual member function, >>> help(module_docn.test_fn_1) Help on function test_fn_1 in module module_docn: test_fn_1() This is the first test function. It doesn't do anything. >>> or more usefully on real functions, >>> help(math.sqrt) Help on built-in function sqrt in module math: sqrt(...) sqrt(x) Return the square root of x. >>>","title":"Documenting modules and functions"},{"location":"06_Functions/11_Documenting_modules_and_functions/#summary","text":"Place triple quoted docstrings at the top of each module and after each function definition. These should provide provide descriptions of what the module and each function do. Use the help() built-in to access the docstrings of modules and functions you import.","title":"Summary"},{"location":"06_Functions/12_Summary_Module_layout/","text":"Summary: Module Layout The standard layout for modules is, # filename.py # ... ''' Module docstring ''' # import statements import ... import ... ... # Function definitions def name( args ): ''' Function docstring ''' ... def name( args ): ''' Function docstring ''' ... ... if __name__ == '__main__': # Unit tests ...","title":"Summary: Module Layout"},{"location":"06_Functions/12_Summary_Module_layout/#summary-module-layout","text":"The standard layout for modules is, # filename.py # ... ''' Module docstring ''' # import statements import ... import ... ... # Function definitions def name( args ): ''' Function docstring ''' ... def name( args ): ''' Function docstring ''' ... ... if __name__ == '__main__': # Unit tests ...","title":"Summary: Module Layout"},{"location":"06_Functions/13_Example_Playing_card_functions_2/","text":"Example: Playing Card Functions 2 Just to provide further examples for study here is a slightly more complete playing cards module: # playing_cards_2.py # Tim Topper # Fall 2012 ''' Contains functions and values for working with playing cards. Cards are simply represented by the numbers from 0 to 51 mapped as follows: 0 : Ace of Clubs 1 : Two of Clubs ... 12 : King of Clubs 13 : Ace of Diamonds ... 25 : King of Diamonds 26 : Ace of Hearts ... 50 : Queen of Spades 51 : King of Spades A deck of cards and hands of cards are both simply lists of card numbers. ''' import random SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): '''Returns the suit name, e.g. 'Clubs', of the card it is passed.''' return SUITS[cardnum // 13] def face_value(cardnum): '''Returns the face value, e.g. 'Three', of the card it is passed.''' return FACE_VALUES[cardnum % 13] def label(cardnum): '''Returns a string describing the card it is passed, e.g. 'Queen of Hearts'.''' return face_value(cardnum) + \" of \" + suit(cardnum) def create_deck(): '''Returns a new unshuffled deck of cards.''' return list(range(0,52)) def shuffle(deck): '''Shuffles the card list it is passed by selecting pairs of cards at random and swapping them.''' shuffles = 2 * len(deck) for shuffle in range(shuffles): posn1 = random.randint(0, len(deck)-1) posn2 = random.randint(0, len(deck)-1) deck[posn1], deck[posn2] = deck[posn2], deck[posn1] return def deal(deck): '''Returns (deals) a card from deck.''' return deck.pop() if __name__ == '__main__': # Unit tests # N.B. More needed! deck = create_deck() print('New deck:', deck) shuffle( deck) print('Shuffled deck:', deck) print('Dealing a card...') card = deal(deck) print(' Card number:', card) print(' Face value:', face_value(card)) print(' Suit:', suit(card)) print(' Description:', label(card)) print('Deck after dealing:', deck) Here is an output when it is run, >>> New deck: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] Shuffled deck: [13, 26, 10, 15, 6, 50, 12, 2, 27, 4, 0, 11, 5, 37, 16, 49, 14, 30, 1, 18, 35, 42, 41, 34, 20, 25, 22, 51, 29, 21, 28, 31, 3, 32, 38, 7, 17, 33, 24, 43, 46, 39, 8, 47, 45, 23, 44, 19, 48, 9, 36, 40] Dealing a card... Card number: 40 Face value: Two Suit: Spades Description: Two of Spades Deck after dealing: [13, 26, 10, 15, 6, 50, 12, 2, 27, 4, 0, 11, 5, 37, 16, 49, 14, 30, 1, 18, 35, 42, 41, 34, 20, 25, 22, 51, 29, 21, 28, 31, 3, 32, 38, 7, 17, 33, 24, 43, 46, 39, 8, 47, 45, 23, 44, 19, 48, 9, 36] >>> and here is the output from help after importing it, >>> import playing_cards_2 >>> help( playing_cards_2) Help on module playing_cards_2: NAME playing_cards_2 DESCRIPTION Contains functions and values for working with playing cards. Cards are simply represented by the numbers from 0 to 51 mapped as follows: 0 : Ace of Clubs 1 : Two of Clubs ... 12 : King of Clubs 13 : Ace of Diamonds ... 25 : King of Diamonds 26 : Ace of Hearts ... 50 : Queen of Spades 51 : King of Spades A deck of cards and hands of cards are both simply lists of card numbers. FUNCTIONS create_deck() Returns a new unshuffled deck of cards. deal(deck) Returns (deals) a card from deck. face_value(cardnum) Returns the face value, e.g. 'Three', of the card it is passed. label(cardnum) Returns a string describing the card it is passed, e.g. 'Queen of Hearts'. shuffle(deck) Shuffles the card list it is passed by selecting pairs of cards at random and swapping them. suit(cardnum) Returns the suit name, e.g. 'Clubs', of the card it is passed. DATA FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', ... SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FILE \\\\home\\profiles\\kreed\\documents\\cpsc128\\programs\\playing_cards_2.py >>>","title":"Example: Playing Card Functions 2"},{"location":"06_Functions/13_Example_Playing_card_functions_2/#example-playing-card-functions-2","text":"Just to provide further examples for study here is a slightly more complete playing cards module: # playing_cards_2.py # Tim Topper # Fall 2012 ''' Contains functions and values for working with playing cards. Cards are simply represented by the numbers from 0 to 51 mapped as follows: 0 : Ace of Clubs 1 : Two of Clubs ... 12 : King of Clubs 13 : Ace of Diamonds ... 25 : King of Diamonds 26 : Ace of Hearts ... 50 : Queen of Spades 51 : King of Spades A deck of cards and hands of cards are both simply lists of card numbers. ''' import random SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): '''Returns the suit name, e.g. 'Clubs', of the card it is passed.''' return SUITS[cardnum // 13] def face_value(cardnum): '''Returns the face value, e.g. 'Three', of the card it is passed.''' return FACE_VALUES[cardnum % 13] def label(cardnum): '''Returns a string describing the card it is passed, e.g. 'Queen of Hearts'.''' return face_value(cardnum) + \" of \" + suit(cardnum) def create_deck(): '''Returns a new unshuffled deck of cards.''' return list(range(0,52)) def shuffle(deck): '''Shuffles the card list it is passed by selecting pairs of cards at random and swapping them.''' shuffles = 2 * len(deck) for shuffle in range(shuffles): posn1 = random.randint(0, len(deck)-1) posn2 = random.randint(0, len(deck)-1) deck[posn1], deck[posn2] = deck[posn2], deck[posn1] return def deal(deck): '''Returns (deals) a card from deck.''' return deck.pop() if __name__ == '__main__': # Unit tests # N.B. More needed! deck = create_deck() print('New deck:', deck) shuffle( deck) print('Shuffled deck:', deck) print('Dealing a card...') card = deal(deck) print(' Card number:', card) print(' Face value:', face_value(card)) print(' Suit:', suit(card)) print(' Description:', label(card)) print('Deck after dealing:', deck) Here is an output when it is run, >>> New deck: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] Shuffled deck: [13, 26, 10, 15, 6, 50, 12, 2, 27, 4, 0, 11, 5, 37, 16, 49, 14, 30, 1, 18, 35, 42, 41, 34, 20, 25, 22, 51, 29, 21, 28, 31, 3, 32, 38, 7, 17, 33, 24, 43, 46, 39, 8, 47, 45, 23, 44, 19, 48, 9, 36, 40] Dealing a card... Card number: 40 Face value: Two Suit: Spades Description: Two of Spades Deck after dealing: [13, 26, 10, 15, 6, 50, 12, 2, 27, 4, 0, 11, 5, 37, 16, 49, 14, 30, 1, 18, 35, 42, 41, 34, 20, 25, 22, 51, 29, 21, 28, 31, 3, 32, 38, 7, 17, 33, 24, 43, 46, 39, 8, 47, 45, 23, 44, 19, 48, 9, 36] >>> and here is the output from help after importing it, >>> import playing_cards_2 >>> help( playing_cards_2) Help on module playing_cards_2: NAME playing_cards_2 DESCRIPTION Contains functions and values for working with playing cards. Cards are simply represented by the numbers from 0 to 51 mapped as follows: 0 : Ace of Clubs 1 : Two of Clubs ... 12 : King of Clubs 13 : Ace of Diamonds ... 25 : King of Diamonds 26 : Ace of Hearts ... 50 : Queen of Spades 51 : King of Spades A deck of cards and hands of cards are both simply lists of card numbers. FUNCTIONS create_deck() Returns a new unshuffled deck of cards. deal(deck) Returns (deals) a card from deck. face_value(cardnum) Returns the face value, e.g. 'Three', of the card it is passed. label(cardnum) Returns a string describing the card it is passed, e.g. 'Queen of Hearts'. shuffle(deck) Shuffles the card list it is passed by selecting pairs of cards at random and swapping them. suit(cardnum) Returns the suit name, e.g. 'Clubs', of the card it is passed. DATA FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', ... SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FILE \\\\home\\profiles\\kreed\\documents\\cpsc128\\programs\\playing_cards_2.py >>>","title":"Example: Playing Card Functions 2"},{"location":"06_Functions/14_Refining_import/","text":"Refining import We saw in playing_cards.py that we had to refer to label by its full name playing_cards.label . This is not what we originally wanted. The original desire was to be able to write, # blackjack.py ... print('You are holding,') for card in hand: print('The', label(card)) ... Python allows us to do this using variations in import syntax. If we only want to import the function label from the module playing_cards.py and to refer to it by its 'first name' alone, i.e. as label , we can write from playing_cards import label ... print('You are holding,') for card in hand: print('The', label(card).) ... If you want to import all the functions in playing_cards and refer to them just by their \u201cfirst names\u201d you can use, from playing_cards import * ... print('You are holding,') for card in hand: print('The', label(card)) ... You can even rename a function as you import it. If you want to import label but refer to it as card_name you can use, from playing_cards import label as card_name ... print('You are holding,') for card in hand: print('The', card_name(card)) ... A warning! There is a danger of making a habit of importing functions and referring to them by first name as in the first two examples above. If multiple modules have functions by the same name, e.g. you import two modules both of which have a function named label , the second import of label will redefine the function and you will only have access to that version. Like all conveniences there is a cost!","title":"Refining import"},{"location":"06_Functions/14_Refining_import/#refining-import","text":"We saw in playing_cards.py that we had to refer to label by its full name playing_cards.label . This is not what we originally wanted. The original desire was to be able to write, # blackjack.py ... print('You are holding,') for card in hand: print('The', label(card)) ... Python allows us to do this using variations in import syntax. If we only want to import the function label from the module playing_cards.py and to refer to it by its 'first name' alone, i.e. as label , we can write from playing_cards import label ... print('You are holding,') for card in hand: print('The', label(card).) ... If you want to import all the functions in playing_cards and refer to them just by their \u201cfirst names\u201d you can use, from playing_cards import * ... print('You are holding,') for card in hand: print('The', label(card)) ... You can even rename a function as you import it. If you want to import label but refer to it as card_name you can use, from playing_cards import label as card_name ... print('You are holding,') for card in hand: print('The', card_name(card)) ...","title":"Refining import"},{"location":"06_Functions/14_Refining_import/#a-warning","text":"There is a danger of making a habit of importing functions and referring to them by first name as in the first two examples above. If multiple modules have functions by the same name, e.g. you import two modules both of which have a function named label , the second import of label will redefine the function and you will only have access to that version. Like all conveniences there is a cost!","title":"A warning!"},{"location":"06_Functions/15_Scope/","text":"Scope This is a somewhat technical issue I wish we could delay. But you're going to bump into it at some point, and we'd better see it before you do. If it doesn't make perfect sense on first reading make a mental note of it, and come back to it when you suspect you are bumping into it hard. Look again at our card functions, # playing_cards.py SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) We saw earlier that names passed into functions get assigned aliases. For example the object 15 is referred to by the name card outside the function above, and by the name cardnum inside the function. The function suit \u201cknows\u201d about cardnum because it assigns the name in its definition statement. But, how does it know about SUITS ? SUITS exists outside the function, and isn't aliased in it, so how does suit know what it is? LEGB The answer is that Python functions follow a clear process in trying to resolve names . This process is easy to remember using the mnemonic LEGB. The letters remind us that Python first looks in the Local context, i.e. the current function. Then it looks in any Enclosing functions, i.e. functions that contain the current one. (See inner() below for an example of this.) Then it looks in the Global context, i.e. the module. Finally it checks the Built-in names for a match. In going through this list Python stops as soon as it finds a match, i.e. if it finds the name defined in the current function it stops looking. So in our code above it finds cardnum defined in the local function. When it looks for SUITS it doesn't find it defined in the function, and then doesn't find an enclosing function, so it looks in the module above the function, and finds it there. If it hadn't, it would have checked to see if there is a built-in variable called SUITS . Beware! One way scope can trick new programmers is that local definitions hide global ones which in turn can hide built-in values and functions. Work through the following examples carefully noting the output. Sooner or later one of these will happen to you. # scope_egs.py print('Example 1: Local variable') def f(): x = 1 print('Inside x is', x) f() print('Outside x is', x) # Error! Comment this line out once you understand why it is an error. print() print('Example 2: Global variable') x = 1 def f(): print('Inside x is', x) f() print('Outside x is', x) print() print('Example 3: Local variable hides global variable inside function') x = 1 def f(): x = 2 print('Inside x is', 2) f() print('Outside x is', x) print() print('Example 4: Lots of hiding') x = 1 def outer(): x = 2 def inner(): x = 3 print('Here in inner x is', x) inner() print('Here in outer x is', x) inner() # Error! Comment this line out once you understand why it is an error. outer() print('Out here x is', x) print('Example 5: Hiding the built-in len') def len(): print('I am not the real len') len()","title":"Scope"},{"location":"06_Functions/15_Scope/#scope","text":"This is a somewhat technical issue I wish we could delay. But you're going to bump into it at some point, and we'd better see it before you do. If it doesn't make perfect sense on first reading make a mental note of it, and come back to it when you suspect you are bumping into it hard. Look again at our card functions, # playing_cards.py SUITS = ('Clubs', 'Diamonds', 'Hearts', 'Spades') FACE_VALUES = ('Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King') def suit(cardnum): return SUITS[cardnum // 13] def face_value(cardnum): return FACE_VALUES[cardnum % 13] card = 15 print(\"Card\", card, \"is the\", face_value(card), \"of\", suit(card)) We saw earlier that names passed into functions get assigned aliases. For example the object 15 is referred to by the name card outside the function above, and by the name cardnum inside the function. The function suit \u201cknows\u201d about cardnum because it assigns the name in its definition statement. But, how does it know about SUITS ? SUITS exists outside the function, and isn't aliased in it, so how does suit know what it is?","title":"Scope"},{"location":"06_Functions/15_Scope/#legb","text":"The answer is that Python functions follow a clear process in trying to resolve names . This process is easy to remember using the mnemonic LEGB. The letters remind us that Python first looks in the Local context, i.e. the current function. Then it looks in any Enclosing functions, i.e. functions that contain the current one. (See inner() below for an example of this.) Then it looks in the Global context, i.e. the module. Finally it checks the Built-in names for a match. In going through this list Python stops as soon as it finds a match, i.e. if it finds the name defined in the current function it stops looking. So in our code above it finds cardnum defined in the local function. When it looks for SUITS it doesn't find it defined in the function, and then doesn't find an enclosing function, so it looks in the module above the function, and finds it there. If it hadn't, it would have checked to see if there is a built-in variable called SUITS .","title":"LEGB"},{"location":"06_Functions/15_Scope/#beware","text":"One way scope can trick new programmers is that local definitions hide global ones which in turn can hide built-in values and functions. Work through the following examples carefully noting the output. Sooner or later one of these will happen to you. # scope_egs.py print('Example 1: Local variable') def f(): x = 1 print('Inside x is', x) f() print('Outside x is', x) # Error! Comment this line out once you understand why it is an error. print() print('Example 2: Global variable') x = 1 def f(): print('Inside x is', x) f() print('Outside x is', x) print() print('Example 3: Local variable hides global variable inside function') x = 1 def f(): x = 2 print('Inside x is', 2) f() print('Outside x is', x) print() print('Example 4: Lots of hiding') x = 1 def outer(): x = 2 def inner(): x = 3 print('Here in inner x is', x) inner() print('Here in outer x is', x) inner() # Error! Comment this line out once you understand why it is an error. outer() print('Out here x is', x) print('Example 5: Hiding the built-in len') def len(): print('I am not the real len') len()","title":"Beware!"},{"location":"06_Functions/16_The_perils_of_mutability/","text":"The Perils of Mutability 1 This is another technical issue, but like scope you're going to bump into it at some point, and we'd better see it before you do. As with scope, if it doesn't make perfect sense on first reading make a mental note of it, and come back to it when you suspect you are bumping into it hard. Immutability Consider the function increment below. What do you suppose it does? Try running the code below to see if your guess is correct. # increment.py def increment(n): n = n + 1 num = 48 increment( num ) print(num) Most students expect the value 49 to be printed and are surprised when 48 is instead. After all it looks as though increment should, well, increment the value it is passed and since it was passed 48 it should have incremented it to 49 and printing num should display this value. The programmer might even have intended this, but has been foiled by the fact that in Python, numbers, like strings, are immutable . When increment begins to run we can picture memory looking like this, Now what happens when the line n = n + 1 is executed? The processor fetches the value that n names, i.e. 48, adds one to it to get 49 and then stores this new value with the name n . Memory now looks like this, Why doesn't it look like this? Because numbers are immutable, so the 48 can't be changed into 49 or into anything else for that matter. Instead a new value, 49, is created and assigned to the name n , and this doesn't affect the value referred to by the name num . Aside If you want an increment function you would write and use it slightly differently: def increment(n): return n+1 num = 48 num = increment(num) print(num) Try it and see. Mutability Unlike numbers and strings, lists are mutable so they can be affected when passed to functions, e.g. def increment(seq): seq.append(42) lst = [48] increment( lst ) print(lst) What result do you expect this to produce? Try it to see if you're right. The mutability of lists can surprise us even without invoking a function. Consider this code fragment. Make your prediction then run it to see if you're right, l = [ 'Tim' ] n = l l.append( 'Joyce' ) print(l) print(n) Things can get trickier. Try your predictive abilities on this, a = 'Tim' b = 'Tom' lst = [b, a] a = 'Matt' lst[1] = lst[0] print(lst) Neither mutable nor immutable values behave the way most students expect, but mutability trips them up more often than immutability so the page is named for the more dangerous case. \u21a9","title":"The Perils of Mutability1"},{"location":"06_Functions/16_The_perils_of_mutability/#the-perils-of-mutability1","text":"This is another technical issue, but like scope you're going to bump into it at some point, and we'd better see it before you do. As with scope, if it doesn't make perfect sense on first reading make a mental note of it, and come back to it when you suspect you are bumping into it hard.","title":"The Perils of Mutability1"},{"location":"06_Functions/16_The_perils_of_mutability/#immutability","text":"Consider the function increment below. What do you suppose it does? Try running the code below to see if your guess is correct. # increment.py def increment(n): n = n + 1 num = 48 increment( num ) print(num) Most students expect the value 49 to be printed and are surprised when 48 is instead. After all it looks as though increment should, well, increment the value it is passed and since it was passed 48 it should have incremented it to 49 and printing num should display this value. The programmer might even have intended this, but has been foiled by the fact that in Python, numbers, like strings, are immutable . When increment begins to run we can picture memory looking like this, Now what happens when the line n = n + 1 is executed? The processor fetches the value that n names, i.e. 48, adds one to it to get 49 and then stores this new value with the name n . Memory now looks like this, Why doesn't it look like this? Because numbers are immutable, so the 48 can't be changed into 49 or into anything else for that matter. Instead a new value, 49, is created and assigned to the name n , and this doesn't affect the value referred to by the name num .","title":"Immutability"},{"location":"06_Functions/16_The_perils_of_mutability/#aside","text":"If you want an increment function you would write and use it slightly differently: def increment(n): return n+1 num = 48 num = increment(num) print(num) Try it and see.","title":"Aside"},{"location":"06_Functions/16_The_perils_of_mutability/#mutability","text":"Unlike numbers and strings, lists are mutable so they can be affected when passed to functions, e.g. def increment(seq): seq.append(42) lst = [48] increment( lst ) print(lst) What result do you expect this to produce? Try it to see if you're right. The mutability of lists can surprise us even without invoking a function. Consider this code fragment. Make your prediction then run it to see if you're right, l = [ 'Tim' ] n = l l.append( 'Joyce' ) print(l) print(n) Things can get trickier. Try your predictive abilities on this, a = 'Tim' b = 'Tom' lst = [b, a] a = 'Matt' lst[1] = lst[0] print(lst) Neither mutable nor immutable values behave the way most students expect, but mutability trips them up more often than immutability so the page is named for the more dangerous case. \u21a9","title":"Mutability"},{"location":"06_Functions/17_Reference_semantics/","text":"Object destruction: Garbage collection* using reference counting The other thing to note is that the assignment lst[1] = lst[0] not only causes lst[1] to refer to 'Tom' like lst[0] does it also triggers the destruction of the object 'Tim' . It does so because Python uses reference counting to decide when an object can safely be destroyed and the memory it is using reclaimed. Reference counting garbage collection is based on the insight that once the number of references to an object declines to 0 that object can never be accessed by a program, therefore it is safe to destroy it. This happens to 'Tim' when the last reference to it ( lst[1] ) is removed. This is also what happens to local variables in functions when the function ends: as the local names are deleted the reference counts to the objects drop to 0 and they can be destroyed (unless they are passed back by a return statement which creates a reference to them from a name in the calling function). In terms of our diagrams an object's reference count is the number of arrow heads pointing to it. At the end of the previous code fragment the reference count of 'Matt' is 1, and the reference count of 'Tom' is 3. With practice these semantics will become second nature, but at first you may find it necessary to draw diagrams like those above when debugging your code. Memory management (the creation and deletion of memory structures, including objects), was the bane of C and C++ programmers' lives. If you did not carefully destroy objects once they were no longer needed you created a memory leak, so called because the amount of memory your program used slowly but steadily increased (since you weren't reclaiming memory), making it seem like your system was slowly leaking available memory. Java was the first widely successful language to make memory management automatic. That meant that programmers could create objects and that the system would automatically determine when it was safe to reclaim them. This reclamation process goes by the colourful name garbage collection . There are numerous ways of determining when given memory can safely be reclaimed; reference counting is just one of them.","title":"Object destruction: Garbage collection* using reference counting"},{"location":"06_Functions/17_Reference_semantics/#object-destruction-garbage-collection-using-reference-counting","text":"The other thing to note is that the assignment lst[1] = lst[0] not only causes lst[1] to refer to 'Tom' like lst[0] does it also triggers the destruction of the object 'Tim' . It does so because Python uses reference counting to decide when an object can safely be destroyed and the memory it is using reclaimed. Reference counting garbage collection is based on the insight that once the number of references to an object declines to 0 that object can never be accessed by a program, therefore it is safe to destroy it. This happens to 'Tim' when the last reference to it ( lst[1] ) is removed. This is also what happens to local variables in functions when the function ends: as the local names are deleted the reference counts to the objects drop to 0 and they can be destroyed (unless they are passed back by a return statement which creates a reference to them from a name in the calling function). In terms of our diagrams an object's reference count is the number of arrow heads pointing to it. At the end of the previous code fragment the reference count of 'Matt' is 1, and the reference count of 'Tom' is 3. With practice these semantics will become second nature, but at first you may find it necessary to draw diagrams like those above when debugging your code. Memory management (the creation and deletion of memory structures, including objects), was the bane of C and C++ programmers' lives. If you did not carefully destroy objects once they were no longer needed you created a memory leak, so called because the amount of memory your program used slowly but steadily increased (since you weren't reclaiming memory), making it seem like your system was slowly leaking available memory. Java was the first widely successful language to make memory management automatic. That meant that programmers could create objects and that the system would automatically determine when it was safe to reclaim them. This reclamation process goes by the colourful name garbage collection . There are numerous ways of determining when given memory can safely be reclaimed; reference counting is just one of them.","title":"Object destruction: Garbage collection* using reference counting"},{"location":"06_Functions/18_Using_versus_changing_a_list/","text":"Using versus changing a list Reference semantics provides some insight into the different approaches needed to use and to change a list. Using a list First consider the case where you just want to use the values in a list. Perhaps they represent the lengths of bars to draw, e.g. magnitudes = [41, 14, 27, 5, 32] for m in magnitudes: print(m*'=') This works nicely producing the output, >>> magnitudes = [41, 14, 27, 5, 32] >>> for m in magnitudes: print(m*'=') ========================================= ============== =========================== ===== ================================ >>> Changing a list What doesn't work Now suppose we want to add 10% to each value in the list. We might reason that in the for loop above m takes the value of each entry in the list, so changing it will change the values in the list and so try to do what we want like this, for m in magnitudes: m = m + m//10 but testing will reveal that it doesn't do what we want, >>> magnitudes = [41, 14, 27, 5, 32] >>> for m in magnitudes: m = m + m//10 >>> print(magnitudes) [41, 14, 27, 5, 32] >>> because the list is unchanged. Have you already spotted the problem? The first part of our thinking that \"m takes on the value of each entry in the list\" was correct. The problem is with our second part \"changing it will change the values in the list\". Here's what memory looks like at the start of the first iteration of the loop and after the assignment statement inside has executed, for m in magnitudes: m = m + m//10 Notice carefully what happened. The expression m + m//10 was evaluated 41 + 41//10 \u2192 41 + 4 \u2192 45 yielding the object 45, so the name m was set to refer to this object (remember: \"Assignment creates a reference to an object\"!) leaving the list unchanged. What works 1 There are a number of ways to get around this problem. The most general* is to access the list contents by index, for i in range( len(magnitudes )): magnitudes[i] = magnitudes[i] + magnitudes[i]//10 and testing shows it works, >>> for i in range( len(magnitudes )): magnitudes[i] = magnitudes[i] + magnitudes[i]//10 >>> print(magnitudes) [45, 15, 29, 5, 35] >>> But why does it work? Because the assignment statement on the first iteration becomes magnitudes[0] = magnitudes[0] + magnitudes[0]//10 . And magnitudes[0] is the precise name of the reference that is the first entry in the list so we are changing it directly. Similarly on the later iterations we will change magnitudes[1] , magnitudes[2] and so on. Remember that the entries in magnitudes do have indirect names! What works 2 Another approach is to create a new list with the modified values and then assign it to the old name, e.g. tmp = [] for m in magnitudes: tmp.append(m + m//10) magnitudes = tmp Other things that work For more Pythonic approaches to the problem consult the last 3 sections of this module. Summary When working with lists be clear in your own mind whether you are_using_the elements in the list, or_modifying_them and choose your coding approach accordingly. For_use_ for item in thelist: # do stuff with item For_modification_ for i in range( len(thelist) ): thelist[i] = ... Most general because it can be done across many languages. Some would also say it is the least \"Pythonic\", but it's still the first one for us to consider because the aim of this course is to teach programming not just Python.","title":"Using versus changing a list"},{"location":"06_Functions/18_Using_versus_changing_a_list/#using-versus-changing-a-list","text":"Reference semantics provides some insight into the different approaches needed to use and to change a list.","title":"Using versus changing a list"},{"location":"06_Functions/18_Using_versus_changing_a_list/#using-a-list","text":"First consider the case where you just want to use the values in a list. Perhaps they represent the lengths of bars to draw, e.g. magnitudes = [41, 14, 27, 5, 32] for m in magnitudes: print(m*'=') This works nicely producing the output, >>> magnitudes = [41, 14, 27, 5, 32] >>> for m in magnitudes: print(m*'=') ========================================= ============== =========================== ===== ================================ >>>","title":"Using a list"},{"location":"06_Functions/18_Using_versus_changing_a_list/#changing-a-list","text":"","title":"Changing a list"},{"location":"06_Functions/18_Using_versus_changing_a_list/#what-doesnt-work","text":"Now suppose we want to add 10% to each value in the list. We might reason that in the for loop above m takes the value of each entry in the list, so changing it will change the values in the list and so try to do what we want like this, for m in magnitudes: m = m + m//10 but testing will reveal that it doesn't do what we want, >>> magnitudes = [41, 14, 27, 5, 32] >>> for m in magnitudes: m = m + m//10 >>> print(magnitudes) [41, 14, 27, 5, 32] >>> because the list is unchanged. Have you already spotted the problem? The first part of our thinking that \"m takes on the value of each entry in the list\" was correct. The problem is with our second part \"changing it will change the values in the list\". Here's what memory looks like at the start of the first iteration of the loop and after the assignment statement inside has executed, for m in magnitudes: m = m + m//10 Notice carefully what happened. The expression m + m//10 was evaluated 41 + 41//10 \u2192 41 + 4 \u2192 45 yielding the object 45, so the name m was set to refer to this object (remember: \"Assignment creates a reference to an object\"!) leaving the list unchanged.","title":"What doesn't work"},{"location":"06_Functions/18_Using_versus_changing_a_list/#what-works-1","text":"There are a number of ways to get around this problem. The most general* is to access the list contents by index, for i in range( len(magnitudes )): magnitudes[i] = magnitudes[i] + magnitudes[i]//10 and testing shows it works, >>> for i in range( len(magnitudes )): magnitudes[i] = magnitudes[i] + magnitudes[i]//10 >>> print(magnitudes) [45, 15, 29, 5, 35] >>> But why does it work? Because the assignment statement on the first iteration becomes magnitudes[0] = magnitudes[0] + magnitudes[0]//10 . And magnitudes[0] is the precise name of the reference that is the first entry in the list so we are changing it directly. Similarly on the later iterations we will change magnitudes[1] , magnitudes[2] and so on. Remember that the entries in magnitudes do have indirect names!","title":"What works 1"},{"location":"06_Functions/18_Using_versus_changing_a_list/#what-works-2","text":"Another approach is to create a new list with the modified values and then assign it to the old name, e.g. tmp = [] for m in magnitudes: tmp.append(m + m//10) magnitudes = tmp","title":"What works 2"},{"location":"06_Functions/18_Using_versus_changing_a_list/#other-things-that-work","text":"For more Pythonic approaches to the problem consult the last 3 sections of this module.","title":"Other things that work"},{"location":"06_Functions/18_Using_versus_changing_a_list/#summary","text":"When working with lists be clear in your own mind whether you are_using_the elements in the list, or_modifying_them and choose your coding approach accordingly. For_use_ for item in thelist: # do stuff with item For_modification_ for i in range( len(thelist) ): thelist[i] = ... Most general because it can be done across many languages. Some would also say it is the least \"Pythonic\", but it's still the first one for us to consider because the aim of this course is to teach programming not just Python.","title":"Summary"},{"location":"06_Functions/19_Copying_a_list/","text":"Copying a list What doesn't work As with changing a list, our first attempt at copying a list may not succeed. The most common thing students try is something like this, magnitudes = [41, 14, 27, 5, 32] copy = magnitudes Reasoning that copy will now contain a copy of magnitudes. Of course a moment's thought about how reference semantics works will show that magnitudes and copy are now both references to the same list object, i.e. What works (sort of) 1 One way to copy a list is to create an empty one, and then loop through the source list appending elements to the new one, magnitudes = [41, 14, 27, 5, 32] copy = [] for m in magnitudes: copy.append(m) this gets us what we wanted, What works (sort of) 2 and 3 Copying a list is so common that there are some Pythonic shortcuts available. One is to take a slice of the entire list and assign it to copy, copy = magnitudes[:] This works because slices create new objects . Another is to use the class constructor 1 for lists, list , to create a new list from an existing one, copy = list(magnitude) What's with the \u201c(sort of)\u201d? Well sometimes these do all we want, but other times its important to realize they are all creating first level copies of the lists. Recall our Tic-Tac-Toe lists: g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] Watch what happens when make a copy and then modify the copy, >>> g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> cc = g[:] >>> print(cc) [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> cc[0][0] = 'A' >>> print(cc) [['A', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> print(g) [['A', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> Do you see it? Changing element cc[0][0] to 'A' also changed element g[0][0] . But if cc is a copy of g that shouldn't have happened! The problem is that cc isn't a complete copy of g . It only copied the first level references in g . Those references still point to the same sublist objects, i.e. So since cc[0] and g[0] still reference the same list object, changing cc[0][0] changes g[0][0] . Deep copying As the Tic-Tac-Toe example shows sometimes we have objects containing references to other objects, and in some applications there can be far more than just two levels of reference. What to do if we still need a copy of the complete structure? This comes up often enough that Python provides a standard library function to create the copy for you, >>> import copy >>> g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> cc = copy.deepcopy(g) >>> cc[0][0] = 'A' >>> print(cc) [['A', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> print(g) [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> Summary Create a shallow copy using a slice, copy = original[:] or the list constructor, copy = list(original) . If a deep copy is needed (it often isn't), use the copy module, copy = copy.deepcopy(original) . We used these before for converting from one object type to another, but they can also be used to create another object of one type from an existing object of that same type. \u21a9","title":"Copying a list"},{"location":"06_Functions/19_Copying_a_list/#copying-a-list","text":"","title":"Copying a list"},{"location":"06_Functions/19_Copying_a_list/#what-doesnt-work","text":"As with changing a list, our first attempt at copying a list may not succeed. The most common thing students try is something like this, magnitudes = [41, 14, 27, 5, 32] copy = magnitudes Reasoning that copy will now contain a copy of magnitudes. Of course a moment's thought about how reference semantics works will show that magnitudes and copy are now both references to the same list object, i.e.","title":"What doesn't work"},{"location":"06_Functions/19_Copying_a_list/#what-works-sort-of-1","text":"One way to copy a list is to create an empty one, and then loop through the source list appending elements to the new one, magnitudes = [41, 14, 27, 5, 32] copy = [] for m in magnitudes: copy.append(m) this gets us what we wanted,","title":"What works (sort of) 1"},{"location":"06_Functions/19_Copying_a_list/#what-works-sort-of-2-and-3","text":"Copying a list is so common that there are some Pythonic shortcuts available. One is to take a slice of the entire list and assign it to copy, copy = magnitudes[:] This works because slices create new objects . Another is to use the class constructor 1 for lists, list , to create a new list from an existing one, copy = list(magnitude)","title":"What works (sort of) 2 and 3"},{"location":"06_Functions/19_Copying_a_list/#whats-with-the-sort-of","text":"Well sometimes these do all we want, but other times its important to realize they are all creating first level copies of the lists. Recall our Tic-Tac-Toe lists: g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] Watch what happens when make a copy and then modify the copy, >>> g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> cc = g[:] >>> print(cc) [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> cc[0][0] = 'A' >>> print(cc) [['A', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> print(g) [['A', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> Do you see it? Changing element cc[0][0] to 'A' also changed element g[0][0] . But if cc is a copy of g that shouldn't have happened! The problem is that cc isn't a complete copy of g . It only copied the first level references in g . Those references still point to the same sublist objects, i.e. So since cc[0] and g[0] still reference the same list object, changing cc[0][0] changes g[0][0] .","title":"What's with the \u201c(sort of)\u201d?"},{"location":"06_Functions/19_Copying_a_list/#deep-copying","text":"As the Tic-Tac-Toe example shows sometimes we have objects containing references to other objects, and in some applications there can be far more than just two levels of reference. What to do if we still need a copy of the complete structure? This comes up often enough that Python provides a standard library function to create the copy for you, >>> import copy >>> g = [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> cc = copy.deepcopy(g) >>> cc[0][0] = 'A' >>> print(cc) [['A', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>> print(g) [['X', 'O', ''], ['O', 'X', 'O'], ['', '', 'X']] >>>","title":"Deep copying"},{"location":"06_Functions/19_Copying_a_list/#summary","text":"Create a shallow copy using a slice, copy = original[:] or the list constructor, copy = list(original) . If a deep copy is needed (it often isn't), use the copy module, copy = copy.deepcopy(original) . We used these before for converting from one object type to another, but they can also be used to create another object of one type from an existing object of that same type. \u21a9","title":"Summary"},{"location":"06_Functions/20_List_comprehensions/","text":"List comprehensions List comprehensions are not understandings of lists, but a shortcut notation for generating one list from another. The shortcut notation was created because we process a list to create another so often. Consider creating a list of playing card face values from a list of their card numbers. We could do it like this, hand = [12, 42, 8, 29, 11] face_values = [] for card in hand: face_values.append( card%13 ) Or we could use the shortcut notation provided by list comprehensions and do this, face_values = [card%13 for card in hand] (The square parentheses are a reminder that the expression on the right is creating a list.) A list comprehension is a general expression mechanism that generates lists instead of numbers or strings, e.g. [x**2 for x in range(5)] will generate, >>> [x**2 for x in range(5)] [0, 1, 4, 9, 16] >>> You can even add a test at the end to filter out some of the results, e.g. >>> [x**2 for x in range(5) if x**2 % 2 == 0] [0, 4, 16] >>> Syntax summary [ expression for name in sequence if test ]","title":"List comprehensions"},{"location":"06_Functions/20_List_comprehensions/#list-comprehensions","text":"List comprehensions are not understandings of lists, but a shortcut notation for generating one list from another. The shortcut notation was created because we process a list to create another so often. Consider creating a list of playing card face values from a list of their card numbers. We could do it like this, hand = [12, 42, 8, 29, 11] face_values = [] for card in hand: face_values.append( card%13 ) Or we could use the shortcut notation provided by list comprehensions and do this, face_values = [card%13 for card in hand] (The square parentheses are a reminder that the expression on the right is creating a list.) A list comprehension is a general expression mechanism that generates lists instead of numbers or strings, e.g. [x**2 for x in range(5)] will generate, >>> [x**2 for x in range(5)] [0, 1, 4, 9, 16] >>> You can even add a test at the end to filter out some of the results, e.g. >>> [x**2 for x in range(5) if x**2 % 2 == 0] [0, 4, 16] >>>","title":"List comprehensions"},{"location":"06_Functions/20_List_comprehensions/#syntax-summary","text":"[ expression for name in sequence if test ]","title":"Syntax summary"},{"location":"06_Functions/21_What_are_these_pyc_files/","text":"What are these pyc files? By now you may have noticed a folder __pycache__ of .pyc files appearing in your working directories without your having created them. While it's true you didn't manually create them you did cause them to be created. Remember that when you import a module it is executed. One result of this execution is a .pyc file. Those pyc files are compiled versions of modules. Having them makes later imports quicker because the modules do not have to be recompiled; instead the pyc file can be used immediately. So, each time you import a module you trigger the creation of a pyc file. You can delete them if they annoy you, but it will slow later imports, and they'll get recreated when needed anyway.","title":"What are these pyc files?"},{"location":"06_Functions/21_What_are_these_pyc_files/#what-are-these-pyc-files","text":"By now you may have noticed a folder __pycache__ of .pyc files appearing in your working directories without your having created them. While it's true you didn't manually create them you did cause them to be created. Remember that when you import a module it is executed. One result of this execution is a .pyc file. Those pyc files are compiled versions of modules. Having them makes later imports quicker because the modules do not have to be recompiled; instead the pyc file can be used immediately. So, each time you import a module you trigger the creation of a pyc file. You can delete them if they annoy you, but it will slow later imports, and they'll get recreated when needed anyway.","title":"What are these pyc files?"},{"location":"06_Functions/22_Finding_the_standard_library_modules/","text":"Finding the Standard Library Modules Python is often referred to as a \u201cbatteries included\u201d language because its standard library offers so much functionality you rarely have to download other, separate, tools. The standard library modules also offer the student programmer a rich resource of high quality code to study and learn from. Sometimes though it is not obvious where to find the standard library files on your computer. Fortunately you can ask Python to tell you where they are. First import the sys module, then look at its path attribute. This attribute is a list of all the directories Python will search in the order they will be searched when you look for a module. For example, >>> import sys >>> sys.path ['//home/Profiles/kreed/Documents/CPSC128/Programs', 'C:\\\\Program Files\\\\Python311\\\\Lib\\\\idlelib', 'C:\\\\Program Files\\\\Python311\\\\python311.zip', 'C:\\\\Program Files\\\\Python311\\\\Lib', 'C:\\\\Program Files\\\\Python311\\\\DLLs', 'C:\\\\Program Files\\\\Python311', 'C:\\\\Program Files\\\\Python311\\\\Lib\\\\site-packages'] >>> Here we can see that it will begin by looking in my current directory //home/Profiles/kreed/Documents/CPSC128/Programs and then work through the remainder of the list. The search stops when the first match is found. Note: The bulk of the libraries are found in the lib directory and its descendants, on this machine that means the fourth entry C:\\\\Program Files\\\\Python311\\\\Lib . Note that since this path is available through introspection it can be changed dynamically by a running program \u2014 a useful trick in some situations.","title":"Finding the Standard Library Modules"},{"location":"06_Functions/22_Finding_the_standard_library_modules/#finding-the-standard-library-modules","text":"Python is often referred to as a \u201cbatteries included\u201d language because its standard library offers so much functionality you rarely have to download other, separate, tools. The standard library modules also offer the student programmer a rich resource of high quality code to study and learn from. Sometimes though it is not obvious where to find the standard library files on your computer. Fortunately you can ask Python to tell you where they are. First import the sys module, then look at its path attribute. This attribute is a list of all the directories Python will search in the order they will be searched when you look for a module. For example, >>> import sys >>> sys.path ['//home/Profiles/kreed/Documents/CPSC128/Programs', 'C:\\\\Program Files\\\\Python311\\\\Lib\\\\idlelib', 'C:\\\\Program Files\\\\Python311\\\\python311.zip', 'C:\\\\Program Files\\\\Python311\\\\Lib', 'C:\\\\Program Files\\\\Python311\\\\DLLs', 'C:\\\\Program Files\\\\Python311', 'C:\\\\Program Files\\\\Python311\\\\Lib\\\\site-packages'] >>> Here we can see that it will begin by looking in my current directory //home/Profiles/kreed/Documents/CPSC128/Programs and then work through the remainder of the list. The search stops when the first match is found. Note: The bulk of the libraries are found in the lib directory and its descendants, on this machine that means the fourth entry C:\\\\Program Files\\\\Python311\\\\Lib . Note that since this path is available through introspection it can be changed dynamically by a running program \u2014 a useful trick in some situations.","title":"Finding the Standard Library Modules"},{"location":"06_Functions/90_Assignment_6/","text":"Assignment 6 Problems Insert the necessary function definitions into the code below so that it will work properly (i.e. as shown in the sample runs below it). Notes: 0 is a one-digit, even, unsigned number. You may not make any changes to the code below, i.e. your functions have to fit the code, you are not allowed to modify the code to fit your functions. # a6p1name.py # Just some practice writing little functions. # Insert the necessary functions here. line(60, '=') print('Function practice') line(60, '-') num = int(input('Give me an integer value: ')) print('Your number contains', ndigits(num), end = ' ') print('digits, is', even_or_odd(num), end = '') if ispos(num): print(', and is positive.') else: print(', but is not positive.') line(60, '-') ============================================================ Function practice ------------------------------------------------------------ Give me an integer value: 78931 Your number contains 5 digits, is odd and is positive. ------------------------------------------------------------ ============================================================ Function practice ------------------------------------------------------------ Give me an integer value: -122 Your number contains 3 digits, is even but is not positive. ------------------------------------------------------------ Hint : There are several ways of tackling the ndigits function. You can find the number of digits by counting how many times you can divide a number by 10 before you get 0, e.g. 7 can be divided by 10 once, while 732 can be divided 3 times. You can use the logarithm of the number to the base 10. You can convert the number to a string and then use len() to see how long the string is. The next three problems all involve writing functions to determine if a list of card numbers represents a straight. A straight is a hand in which the cards\u2019 face values form a sequence, e.g. 3, 4, 5, 6, 7 and 6, 4, 7, 3, 5 are both straights (even though the numbers in the second case are not in order), but 3, 4, 5, 7, 8 and 4, 5, 6, 5, 7 are not (the first, because 6 is missing, and the second because of the duplicate 5s). Note that the cards do not have to be in the same suit, e.g. the hand containing 2\u2663, 3\u2666, 4\u2663, 5\u2660 and 6\u2665 is a straight. There are numerous computational approaches that can be taken to decide if a list of card numbers is a straight or not. Each of the following problems describes one of them and provides pseudocode for it. Your job is to faithfully translate each pseudocode description into a Python function . (Hint: You will notice that all three approaches contain the operation \"replace the card numbers in the copy with numbers representing their face values\". To avoid rewriting, that would make a good function, no?) One approach to seeing if the cards in the list are a straight is to sort them in ascending order and then see if each one is one larger than the previous one. That is we take 6, 4, 7, 3, 5 and sort it to get 3, 4, 5 ,6, 7, and then we make sure the second entry (4) is one larger than the first (3), and that the third entry (5) is one larger than the second (4), and so on. If they all are it's a straight, but if we find neighbouring values that are the same, or that are more than 1 apart it's not a straight. Pseudocode: def isStraight(hand): '''Return True if the cards in hand are a straight, and False otherwise.''' make a copy of hand (so we don't change it) and work with the copy from now on replace the card numbers in the copy with numbers representing their face values (e.g. 1 for Ace, 2 for Two, ... and 13 for King) sort the copy in ascending numerical order Check that each value is one larger than the previous value: assume the cards are a straight by setting a flag to True for each value in the copy starting with the second value and going to the last value if this value if not one greater than the previous value set the flag to False if the flag is still True it's a straight otherwise it's not Our second approach begins the same way as the first, i.e. by replacing card numbers by face values and sorting them, but then we compare the sorted list to a test list with the same starting value. What test list? Suppose I tell you I have a five card straight starting from a face value of 3. You could say \"Oh you have a 3, a 4, a 5, a 6 and a 7.\" The idea here is to build the necessary test list and compare it to the actual list and to see if they match. If they do it's a straight, otherwise it's not. Pseudocode: def isStraight(hand): '''Return True if the cards in hand are a straight, and False otherwise.''' make a copy of hand (so we don't change it) and work with the copy from now on replace the card numbers in the copy with numbers representing their face values (e.g. 1 for Ace, 2 for Two, ... and 13 for King) sort the copy in ascending numerical order find the minimum face value in the list build a new list containing the values a straight starting with that minimum value would contain, i.e. a list of consecutive numbers starting with the min value and having the same number of values in it as the hand, e.g. min value = 3 and hand size = 5 implies a test list of [3, 4, 5, 6, 7] (Hint: Use the range command to build the test list.) if the test list equals the sorted copy it's a straight else it's not Our final approach is based on the observation that the cards in a straight must all be different, and that the first and last cards' face values will differ by the length of the hand minus 1, e.g. in a five card hand the face value of the last card will be 5 minus 1 or 4 greater than the first card (as it is for example in [3, 4, 5, 6, 7] where 7 is 4 greater than 3). Of course the hand [3, 3, 5, 7, 7] also has the right range of values but isn't a straight because the face values in it are not unique (see the first condition in the first sentence above \"the cards in a straight must all be different\"). Which leads to the second test in the pseudocode below: def isStraight(hand): '''Return True if the cards in hand are a straight, and False otherwise.''' make a copy of hand (so we don't change it) and work with the copy from now on replace the card numbers in the copy with numbers representing their face values find the minimum face value (Hint: Use the min function.) find the maximum face value (Hint: Can't you guess?) # If the largest and smallest values are the right distance apart # e.g. in a five card hand they 4 apart if max - min equals length of the list - 1 then # and all the values in the list are different # i.e. they all occur exactly once set the counter of unique values to 0 for each value in the list if the number of times it ocurs in the list is 1 (Hint: Use the count method.) add one to the counter of unique values if the count of unique values equals the length of the list it's a straight otherwise it's not else it's not a straight You can use the test program below to evaluate your code \u2014 I will in marking it, though I may add to the set of test cases given below \u2014 or you can write and use your own test program. # isstraight_test.py # This program tests the function isStraight on several sample hands # of cards. from a6p2name import isStraight #from a6p3name import isStraight #from a6p4name import isStraight # TEST_HANDS is a list containing the hands of cards to use in testing # the function isStraight, and the correct result for each hand. # Note that not all hands have five cards, and some are straights, # while some are not. TEST_HANDS = [ [[ 1, 2, 3, 4, 5 ], True], [[ 5, 4, 3, 2, 1 ], True], [[ 14, 0, 28, 42, 4 ], True], [[ 1, 2, 3, 4, 5, 6 ], True], [[ 5 ], True], [[ 1, 2, 2, 4, 5 ], False], [[ 1, 2, 2, 5, 5 ], False], [[ 1, 3, 5, 7, 9 ], False] ] print 'Testing isStraight ... ' # Loop through the list of TEST_HANDS, to test each sample hand. for test in TEST_HANDS: # If the function isStraight does not return the correct # result... if isStraight(test[0]) != test[1]: # ... display an error message print('isStraight fails on', test[0]) print('Done.') print() Logistics Use the following naming scheme for your program files: a assignment# p problem#yourname .py . So your first attempt at problem 1 on this assignment will be named a6p1bob.py and your solution for problem 2 will be named a6p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Assignment 6"},{"location":"06_Functions/90_Assignment_6/#assignment-6","text":"","title":"Assignment 6"},{"location":"06_Functions/90_Assignment_6/#problems","text":"Insert the necessary function definitions into the code below so that it will work properly (i.e. as shown in the sample runs below it). Notes: 0 is a one-digit, even, unsigned number. You may not make any changes to the code below, i.e. your functions have to fit the code, you are not allowed to modify the code to fit your functions. # a6p1name.py # Just some practice writing little functions. # Insert the necessary functions here. line(60, '=') print('Function practice') line(60, '-') num = int(input('Give me an integer value: ')) print('Your number contains', ndigits(num), end = ' ') print('digits, is', even_or_odd(num), end = '') if ispos(num): print(', and is positive.') else: print(', but is not positive.') line(60, '-') ============================================================ Function practice ------------------------------------------------------------ Give me an integer value: 78931 Your number contains 5 digits, is odd and is positive. ------------------------------------------------------------ ============================================================ Function practice ------------------------------------------------------------ Give me an integer value: -122 Your number contains 3 digits, is even but is not positive. ------------------------------------------------------------ Hint : There are several ways of tackling the ndigits function. You can find the number of digits by counting how many times you can divide a number by 10 before you get 0, e.g. 7 can be divided by 10 once, while 732 can be divided 3 times. You can use the logarithm of the number to the base 10. You can convert the number to a string and then use len() to see how long the string is. The next three problems all involve writing functions to determine if a list of card numbers represents a straight. A straight is a hand in which the cards\u2019 face values form a sequence, e.g. 3, 4, 5, 6, 7 and 6, 4, 7, 3, 5 are both straights (even though the numbers in the second case are not in order), but 3, 4, 5, 7, 8 and 4, 5, 6, 5, 7 are not (the first, because 6 is missing, and the second because of the duplicate 5s). Note that the cards do not have to be in the same suit, e.g. the hand containing 2\u2663, 3\u2666, 4\u2663, 5\u2660 and 6\u2665 is a straight. There are numerous computational approaches that can be taken to decide if a list of card numbers is a straight or not. Each of the following problems describes one of them and provides pseudocode for it. Your job is to faithfully translate each pseudocode description into a Python function . (Hint: You will notice that all three approaches contain the operation \"replace the card numbers in the copy with numbers representing their face values\". To avoid rewriting, that would make a good function, no?) One approach to seeing if the cards in the list are a straight is to sort them in ascending order and then see if each one is one larger than the previous one. That is we take 6, 4, 7, 3, 5 and sort it to get 3, 4, 5 ,6, 7, and then we make sure the second entry (4) is one larger than the first (3), and that the third entry (5) is one larger than the second (4), and so on. If they all are it's a straight, but if we find neighbouring values that are the same, or that are more than 1 apart it's not a straight. Pseudocode: def isStraight(hand): '''Return True if the cards in hand are a straight, and False otherwise.''' make a copy of hand (so we don't change it) and work with the copy from now on replace the card numbers in the copy with numbers representing their face values (e.g. 1 for Ace, 2 for Two, ... and 13 for King) sort the copy in ascending numerical order Check that each value is one larger than the previous value: assume the cards are a straight by setting a flag to True for each value in the copy starting with the second value and going to the last value if this value if not one greater than the previous value set the flag to False if the flag is still True it's a straight otherwise it's not Our second approach begins the same way as the first, i.e. by replacing card numbers by face values and sorting them, but then we compare the sorted list to a test list with the same starting value. What test list? Suppose I tell you I have a five card straight starting from a face value of 3. You could say \"Oh you have a 3, a 4, a 5, a 6 and a 7.\" The idea here is to build the necessary test list and compare it to the actual list and to see if they match. If they do it's a straight, otherwise it's not. Pseudocode: def isStraight(hand): '''Return True if the cards in hand are a straight, and False otherwise.''' make a copy of hand (so we don't change it) and work with the copy from now on replace the card numbers in the copy with numbers representing their face values (e.g. 1 for Ace, 2 for Two, ... and 13 for King) sort the copy in ascending numerical order find the minimum face value in the list build a new list containing the values a straight starting with that minimum value would contain, i.e. a list of consecutive numbers starting with the min value and having the same number of values in it as the hand, e.g. min value = 3 and hand size = 5 implies a test list of [3, 4, 5, 6, 7] (Hint: Use the range command to build the test list.) if the test list equals the sorted copy it's a straight else it's not Our final approach is based on the observation that the cards in a straight must all be different, and that the first and last cards' face values will differ by the length of the hand minus 1, e.g. in a five card hand the face value of the last card will be 5 minus 1 or 4 greater than the first card (as it is for example in [3, 4, 5, 6, 7] where 7 is 4 greater than 3). Of course the hand [3, 3, 5, 7, 7] also has the right range of values but isn't a straight because the face values in it are not unique (see the first condition in the first sentence above \"the cards in a straight must all be different\"). Which leads to the second test in the pseudocode below: def isStraight(hand): '''Return True if the cards in hand are a straight, and False otherwise.''' make a copy of hand (so we don't change it) and work with the copy from now on replace the card numbers in the copy with numbers representing their face values find the minimum face value (Hint: Use the min function.) find the maximum face value (Hint: Can't you guess?) # If the largest and smallest values are the right distance apart # e.g. in a five card hand they 4 apart if max - min equals length of the list - 1 then # and all the values in the list are different # i.e. they all occur exactly once set the counter of unique values to 0 for each value in the list if the number of times it ocurs in the list is 1 (Hint: Use the count method.) add one to the counter of unique values if the count of unique values equals the length of the list it's a straight otherwise it's not else it's not a straight You can use the test program below to evaluate your code \u2014 I will in marking it, though I may add to the set of test cases given below \u2014 or you can write and use your own test program. # isstraight_test.py # This program tests the function isStraight on several sample hands # of cards. from a6p2name import isStraight #from a6p3name import isStraight #from a6p4name import isStraight # TEST_HANDS is a list containing the hands of cards to use in testing # the function isStraight, and the correct result for each hand. # Note that not all hands have five cards, and some are straights, # while some are not. TEST_HANDS = [ [[ 1, 2, 3, 4, 5 ], True], [[ 5, 4, 3, 2, 1 ], True], [[ 14, 0, 28, 42, 4 ], True], [[ 1, 2, 3, 4, 5, 6 ], True], [[ 5 ], True], [[ 1, 2, 2, 4, 5 ], False], [[ 1, 2, 2, 5, 5 ], False], [[ 1, 3, 5, 7, 9 ], False] ] print 'Testing isStraight ... ' # Loop through the list of TEST_HANDS, to test each sample hand. for test in TEST_HANDS: # If the function isStraight does not return the correct # result... if isStraight(test[0]) != test[1]: # ... display an error message print('isStraight fails on', test[0]) print('Done.') print()","title":"Problems"},{"location":"06_Functions/90_Assignment_6/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem#yourname .py . So your first attempt at problem 1 on this assignment will be named a6p1bob.py and your solution for problem 2 will be named a6p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Logistics"},{"location":"07_Dictionaries/","text":"Introduction: Dictionaries? \ud83d\udcd6 Congratulations on making it past the halfway point in the course! \ud83d\udcaa This week we consider dictionaries. Not the books of definitions that might be the first thing to come to your mind, but rather Python dictionaries which are a more convenient kind of list, where the index doesn't have to be a number, but can be other Python types as well. So where lists had to look like, card[1] = 48 student[48] = 'Topper, Tim' dictionaries can look like, people['Topper'] = 'Topper, Tim' wisdom[True] = 'Not everything that counts can be counted.' That's really the only new thing this week, but dictionaries can be used in lots of ways. In particular lists and dictionaries can be combined in interesting ways, so the resources provide several examples you will want to read and_work your way through. Dictionaries Dictionary \"derivation\" Think back Counting letters The limits of ingenuity... ... call for greater ingenuity ... ... which calls for even greater ingenuity Summary What can you do with a dictionary? Example: Word Frequencies Pseudocode Python Refinements Example: Scrabble Scoring Pseudocode Python code Example: Book Database Pseudocode Translated into Python Example: A list of dictionaries Problem 1 Pseudocode Python code Problem 2 Pseudocode Python Code","title":"Introduction: Dictionaries? \ud83d\udcd6"},{"location":"07_Dictionaries/#introduction-dictionaries","text":"Congratulations on making it past the halfway point in the course! \ud83d\udcaa This week we consider dictionaries. Not the books of definitions that might be the first thing to come to your mind, but rather Python dictionaries which are a more convenient kind of list, where the index doesn't have to be a number, but can be other Python types as well. So where lists had to look like, card[1] = 48 student[48] = 'Topper, Tim' dictionaries can look like, people['Topper'] = 'Topper, Tim' wisdom[True] = 'Not everything that counts can be counted.' That's really the only new thing this week, but dictionaries can be used in lots of ways. In particular lists and dictionaries can be combined in interesting ways, so the resources provide several examples you will want to read and_work your way through. Dictionaries Dictionary \"derivation\" Think back Counting letters The limits of ingenuity... ... call for greater ingenuity ... ... which calls for even greater ingenuity Summary What can you do with a dictionary? Example: Word Frequencies Pseudocode Python Refinements Example: Scrabble Scoring Pseudocode Python code Example: Book Database Pseudocode Translated into Python Example: A list of dictionaries Problem 1 Pseudocode Python code Problem 2 Pseudocode Python Code","title":"Introduction: Dictionaries? \ud83d\udcd6"},{"location":"07_Dictionaries/01_Dictionaries/","text":"Dictionaries In use dictionaries 1 look like lists that can be indexed by strings. For example where a list can be indexed by numbers like 1 and 5, e.g. lst[1] , lst[5] a dictionary can be indexed by strings like 'Tim' or 'Apt 101', e.g. data['Tim'] and data['Apt 101'] . In modern implementations they manage to do that almost as fast as lists can access their contents. That may not seem surprising to you, but it is an impressive achievement. To give you an appreciation for why it is surprising, and a deeper understanding of how dictionaries are implemented, we'll go through a modest derivation of the mechanisms underlying typical dictionary implementations. Dictionary : Python, Smalltalk, Objective-C, .NET. Hash or hash table : C, C++, Perl, Ruby, Visual Basic, Common Lisp. Collection : Visual Basic, Visual Foxpro. Map : C++, Java. Associative array : Javascript, AWK. To be precise hashes and hash tables are one way of implementing a dictionary and so refer to a lower level of abstraction than the term dictionary. Aside: Known aliases. The data structures known as dictionaries in Python go by many names. These include: \u21a9","title":"Dictionaries"},{"location":"07_Dictionaries/01_Dictionaries/#dictionaries","text":"In use dictionaries 1 look like lists that can be indexed by strings. For example where a list can be indexed by numbers like 1 and 5, e.g. lst[1] , lst[5] a dictionary can be indexed by strings like 'Tim' or 'Apt 101', e.g. data['Tim'] and data['Apt 101'] . In modern implementations they manage to do that almost as fast as lists can access their contents. That may not seem surprising to you, but it is an impressive achievement. To give you an appreciation for why it is surprising, and a deeper understanding of how dictionaries are implemented, we'll go through a modest derivation of the mechanisms underlying typical dictionary implementations. Dictionary : Python, Smalltalk, Objective-C, .NET. Hash or hash table : C, C++, Perl, Ruby, Visual Basic, Common Lisp. Collection : Visual Basic, Visual Foxpro. Map : C++, Java. Associative array : Javascript, AWK. To be precise hashes and hash tables are one way of implementing a dictionary and so refer to a lower level of abstraction than the term dictionary. Aside: Known aliases. The data structures known as dictionaries in Python go by many names. These include: \u21a9","title":"Dictionaries"},{"location":"07_Dictionaries/02_Dictionary_derivation/","text":"Dictionary \"derivation\" Think back Earlier we saw that we could use a list as an array of counters, e.g. to calculate dice odds. The trick there was to map the outcomes of rolling a pair of fair dice, i.e. 2, 3, 4, ..., 11, 12, onto the entries in a list. Since lists are numbered from 0, we did that by subtracting 2 from each dice outcome. This mapped outcomes to counters as follows, Dice outcome Counter 2 \u2192 counters[0] 3 \u2192 counters[1] 4 \u2192 counters[2] ... ... ... 11 \u2192 counters[9] 12 \u2192 counters[10] This is a nice little trick and programmers used similar ones to map all sorts of types onto list indexes so they could count them (or store information associated with them). Counting letters For example if you want to count letters you need to map the letters of the alphabet onto counters like this, Letter Counter 'a' \u2192 counters[0] 'b' \u2192 counters[1] 'c' \u2192 counters[2] ... ... ... 'y' \u2192 counters[24] 'z' \u2192 counters[25] This was done by taking advantage of the properties by which characters are stored in memory. Since the days of teletypes characters had to be represented digitally and so there was an encoding for them. The most common for a long time was ASCII . This specified the binary encoding for the common keyboard characters and control codes as shown e.g. in this table . You can see the control codes teletypes required in the first 32 positions, followed by some special characters and digits, the capital letters, some more special characters, the lower case alphabet, and finally a few more special characters. Thankfully for the tricks below the letters were kept in sequence without intervening special characters. Most languages provide functions to get the ASCII value of a character. In Python this function is ord , (for ord *inal position) >>> ord('a') 97 >>> Its inverse which returns a character corresponding to an ASCII code is chr , >>> chr(97) 'a' >>> Using ord we can implement the mapping above by subtracting 97 (or more readably ord('a') ) from the ordinal values of the characters, test_str ='astringalingding' counters = 26*[0] # Initialize list of counters to be 26 0s. for ch in test_str: # Calculate index of counter for this letter in counters. index = ord(ch) - ord('a') # Increment appropriate counter. counters[index] = counters[index] + 1 for index in range(26): # Display letter corresponding to this index and its count. print(chr(ord('a')+index), counters[index]) Try it, and examine the output. Note how fragile the code is, e.g. insert a space into test_str , or a capital letter. (Don't worry you'll get to make it more robust on the assignment.) The limits of ingenuity... Both these tricks we have seen for mapping sequences onto lists are ingenious but programmers' ingenuity hit a temporary stumbling block when they wanted to count the occurrences of words. At first it seems straightforward. We just need to map words onto counters something like this, word Counter 'cat' \u2192 counters[0] 'dog' \u2192 counters[1] 'pie' \u2192 counters[2] ... ... ... But there are problems. First our mappings from dice outcomes and letters to counters were based on the fact that they were both short sequences. The list of possible words is not short: the English language alone boasts roughly a million words and this is without counting proper names like the names of people and places. We can hardly initialize a list of a million counters each time we need to count the occurrences of words in some paragraph. Second, it's not easy to see how to map 'cat' onto 0 and 'pie' onto 2. In our first two examples we were able to do so using simple arithmetic to deal with an offset between the two sequences first by subtracting 2 and then by subtracting 97. Here simple arithmetic will not suffice. ... call for greater ingenuity ... Programmers tried numerous arithmetic tricks to map words onto indices. For example we could try adding together the ASCII codes for the letters in the words so 'cat' becomes ord('c') + ord('a') + ord('t') = 99 + 97 + 116 = 312 while 'dog' becomes ord('d') + ord('o') + ord('g') = 100 + 111 + 103 = 314. This works nicely for 'cat' and 'dog', but 'dog' and 'god' end up having the same code (as do all acronyms) which won't do. To distinguish 'dog' and 'god' we have to take account of the order of the letters. One way to do this draws its inspiration from numbers. After all 574 and 475 are made from the same digits but we don't confuse them because the position of the numbers matters: 574 means \"5 hundreds, 7 tens, and 4 ones\" whereas 475 means \"4 hundreds, 7 tens and 5 ones\". We can adapt this positional scheme to code our strings. If 574 means (5 \u00d7 100) + (7 \u00d7 10) + (4 \u00d7 1) or (5 \u00d7 10^2) + (7 \u00d7 10^1) + (4 \u00d7 10^0) then by analogy cat should mean (3 \u00d7 262) + (1 \u00d7 261) + (20 \u00d7 260) \u2014 because c, a and t are the 3rd, 1st and 20th letters of the alphabet. Here's a function that calculates this kind of a string index, def string_index( s ): index = 0 for i in range(len(s)): index = index + (ord(s[-i]) - ord('a') + 1) * 26**i return index print(string_index('cat')) print(string_index('dictionary')) (Note the use of the negative index in s[-i] to access the letters of the word from the back to the front, and - ord('a') + 1 to get the letter's position in the alphabet). This gives us unique numbers for words, but they get large quickly. 'cat's index is a modest 1199, but 'dictionary's is 49,655,615,398,718 which makes us long to deal with a mere million counters (that's 49 trillion ). ... which calls for even greater ingenuity Ingenuity knows few bounds so there are fixes of course. We can reduce large numbers to small ones by, for example, using modulo, %. If we want to limit ourselves to a list with 1,000 counters we can just use %1000 and our numbers will all be scaled into the range 0-999. Of course we may have collisions between indices whose last three digits are the same if we do that, but we can watch for that situation and handle it. We might also run out of counters if we have more than 1,000 unique words, but we can watch for that too and enlarge the list of counters if and when it happens. Are there risks of errors? Yes. Are there performance costs? Yes again (testing for collisions takes time; resizing a list takes more time). In all it took programmers a couple of decades of sustained development effort to iron out the major problems. In fact it remains an ongoing area of development in which no best solution is known. But the libraries of major languages contain robust efficient code for doing just this, and that code lies behind the implementation of dictionaries/hash tables/collections/mappings. The string_index function above is called a hashing function. A hash is a unique identifier. In Python most objects can be hashed, not just strings. In fact you can see the internal hash for an object just by calling the built-in hash function, >>> hash('cat') -7283039196165750486 >>> hash('dicitonary') -2899658674586044407 Summary A dictionary works by using a hashing function to get a unique numerical identifier (hash) for an object, and then using that hash to locate the data associated with the object (typically in a list). As long as the hashing function can be computed quickly, and is unique, dictionaries can be almost as fast as lists and yet allow for readable, meaningful indexes. ASCII is being slowly superseded by Unicode because the latter can handle all the characters in all human languages rather than just the few that appear on North American keyboards. Python 3 for example uses Unicode exclusively for its strings. Most other languages are still some ways from providing robust Unicode processing.","title":"Dictionary \"derivation\""},{"location":"07_Dictionaries/02_Dictionary_derivation/#dictionary-derivation","text":"","title":"Dictionary \"derivation\""},{"location":"07_Dictionaries/02_Dictionary_derivation/#think-back","text":"Earlier we saw that we could use a list as an array of counters, e.g. to calculate dice odds. The trick there was to map the outcomes of rolling a pair of fair dice, i.e. 2, 3, 4, ..., 11, 12, onto the entries in a list. Since lists are numbered from 0, we did that by subtracting 2 from each dice outcome. This mapped outcomes to counters as follows, Dice outcome Counter 2 \u2192 counters[0] 3 \u2192 counters[1] 4 \u2192 counters[2] ... ... ... 11 \u2192 counters[9] 12 \u2192 counters[10] This is a nice little trick and programmers used similar ones to map all sorts of types onto list indexes so they could count them (or store information associated with them).","title":"Think back"},{"location":"07_Dictionaries/02_Dictionary_derivation/#counting-letters","text":"For example if you want to count letters you need to map the letters of the alphabet onto counters like this, Letter Counter 'a' \u2192 counters[0] 'b' \u2192 counters[1] 'c' \u2192 counters[2] ... ... ... 'y' \u2192 counters[24] 'z' \u2192 counters[25] This was done by taking advantage of the properties by which characters are stored in memory. Since the days of teletypes characters had to be represented digitally and so there was an encoding for them. The most common for a long time was ASCII . This specified the binary encoding for the common keyboard characters and control codes as shown e.g. in this table . You can see the control codes teletypes required in the first 32 positions, followed by some special characters and digits, the capital letters, some more special characters, the lower case alphabet, and finally a few more special characters. Thankfully for the tricks below the letters were kept in sequence without intervening special characters. Most languages provide functions to get the ASCII value of a character. In Python this function is ord , (for ord *inal position) >>> ord('a') 97 >>> Its inverse which returns a character corresponding to an ASCII code is chr , >>> chr(97) 'a' >>> Using ord we can implement the mapping above by subtracting 97 (or more readably ord('a') ) from the ordinal values of the characters, test_str ='astringalingding' counters = 26*[0] # Initialize list of counters to be 26 0s. for ch in test_str: # Calculate index of counter for this letter in counters. index = ord(ch) - ord('a') # Increment appropriate counter. counters[index] = counters[index] + 1 for index in range(26): # Display letter corresponding to this index and its count. print(chr(ord('a')+index), counters[index]) Try it, and examine the output. Note how fragile the code is, e.g. insert a space into test_str , or a capital letter. (Don't worry you'll get to make it more robust on the assignment.)","title":"Counting letters"},{"location":"07_Dictionaries/02_Dictionary_derivation/#the-limits-of-ingenuity","text":"Both these tricks we have seen for mapping sequences onto lists are ingenious but programmers' ingenuity hit a temporary stumbling block when they wanted to count the occurrences of words. At first it seems straightforward. We just need to map words onto counters something like this, word Counter 'cat' \u2192 counters[0] 'dog' \u2192 counters[1] 'pie' \u2192 counters[2] ... ... ... But there are problems. First our mappings from dice outcomes and letters to counters were based on the fact that they were both short sequences. The list of possible words is not short: the English language alone boasts roughly a million words and this is without counting proper names like the names of people and places. We can hardly initialize a list of a million counters each time we need to count the occurrences of words in some paragraph. Second, it's not easy to see how to map 'cat' onto 0 and 'pie' onto 2. In our first two examples we were able to do so using simple arithmetic to deal with an offset between the two sequences first by subtracting 2 and then by subtracting 97. Here simple arithmetic will not suffice.","title":"The limits of ingenuity..."},{"location":"07_Dictionaries/02_Dictionary_derivation/#call-for-greater-ingenuity","text":"Programmers tried numerous arithmetic tricks to map words onto indices. For example we could try adding together the ASCII codes for the letters in the words so 'cat' becomes ord('c') + ord('a') + ord('t') = 99 + 97 + 116 = 312 while 'dog' becomes ord('d') + ord('o') + ord('g') = 100 + 111 + 103 = 314. This works nicely for 'cat' and 'dog', but 'dog' and 'god' end up having the same code (as do all acronyms) which won't do. To distinguish 'dog' and 'god' we have to take account of the order of the letters. One way to do this draws its inspiration from numbers. After all 574 and 475 are made from the same digits but we don't confuse them because the position of the numbers matters: 574 means \"5 hundreds, 7 tens, and 4 ones\" whereas 475 means \"4 hundreds, 7 tens and 5 ones\". We can adapt this positional scheme to code our strings. If 574 means (5 \u00d7 100) + (7 \u00d7 10) + (4 \u00d7 1) or (5 \u00d7 10^2) + (7 \u00d7 10^1) + (4 \u00d7 10^0) then by analogy cat should mean (3 \u00d7 262) + (1 \u00d7 261) + (20 \u00d7 260) \u2014 because c, a and t are the 3rd, 1st and 20th letters of the alphabet. Here's a function that calculates this kind of a string index, def string_index( s ): index = 0 for i in range(len(s)): index = index + (ord(s[-i]) - ord('a') + 1) * 26**i return index print(string_index('cat')) print(string_index('dictionary')) (Note the use of the negative index in s[-i] to access the letters of the word from the back to the front, and - ord('a') + 1 to get the letter's position in the alphabet). This gives us unique numbers for words, but they get large quickly. 'cat's index is a modest 1199, but 'dictionary's is 49,655,615,398,718 which makes us long to deal with a mere million counters (that's 49 trillion ).","title":"... call for greater ingenuity ..."},{"location":"07_Dictionaries/02_Dictionary_derivation/#which-calls-for-even-greater-ingenuity","text":"Ingenuity knows few bounds so there are fixes of course. We can reduce large numbers to small ones by, for example, using modulo, %. If we want to limit ourselves to a list with 1,000 counters we can just use %1000 and our numbers will all be scaled into the range 0-999. Of course we may have collisions between indices whose last three digits are the same if we do that, but we can watch for that situation and handle it. We might also run out of counters if we have more than 1,000 unique words, but we can watch for that too and enlarge the list of counters if and when it happens. Are there risks of errors? Yes. Are there performance costs? Yes again (testing for collisions takes time; resizing a list takes more time). In all it took programmers a couple of decades of sustained development effort to iron out the major problems. In fact it remains an ongoing area of development in which no best solution is known. But the libraries of major languages contain robust efficient code for doing just this, and that code lies behind the implementation of dictionaries/hash tables/collections/mappings. The string_index function above is called a hashing function. A hash is a unique identifier. In Python most objects can be hashed, not just strings. In fact you can see the internal hash for an object just by calling the built-in hash function, >>> hash('cat') -7283039196165750486 >>> hash('dicitonary') -2899658674586044407","title":"... which calls for even greater ingenuity"},{"location":"07_Dictionaries/02_Dictionary_derivation/#summary","text":"A dictionary works by using a hashing function to get a unique numerical identifier (hash) for an object, and then using that hash to locate the data associated with the object (typically in a list). As long as the hashing function can be computed quickly, and is unique, dictionaries can be almost as fast as lists and yet allow for readable, meaningful indexes. ASCII is being slowly superseded by Unicode because the latter can handle all the characters in all human languages rather than just the few that appear on North American keyboards. Python 3 for example uses Unicode exclusively for its strings. Most other languages are still some ways from providing robust Unicode processing.","title":"Summary"},{"location":"07_Dictionaries/03_What_can_you_do_with_a_dictionary/","text":"What can you do with a dictionary? The full list of methods is in Section 5.5 of the Python Library Reference . Here's an idea of how you might use and combine these methods to carry out common operations. Create a dictionary, Using a dictionary literal*, e.g. d = { 'Tim' : 775, 'Brian' : 869 } we can visualize the dictionary that is created like this, Access an element, print(d['Tim']) The general pattern here is dictionary_name [ key ] = value . So to modify a value, d['Tim'] = 820 and to insert a new value, d['Doug'] = 870 Check to see if there is already an entry with a particular key, 'Brian' in d will return True 'Jill' in d will return False Delete an entry in the dictionary (both the key and its associated value), del( d['Brian'] ) Remove an entry, but get the value, d.pop('Tim') removes the key value pair 'Tim':820 from the dictionary but returns 820 Find out how many key-value pairs are in the dictionary, len( d ) Get a list of all the keys in the dictionary, >>> d.keys() dict_keys(['Tim', 'Doug']) >>> (Note the square brackets and commas: d.keys returns a dict_keys object. You have to cast it explicitly to use it as a list.) >>> list(d.keys()) ['Tim', 'Doug'] >>> You don't have to cast it to a list to iterate through it with a for loop. This is often used for iterating through the entries in the dictionary, e.g. for key in d.keys(): print(key, ':', d[key]) produces the output, >>> Tim : 820 Doug : 870 >>> This can also be shortened to, for key in d: print(key, ':', d[key]) Get a dict_values object of all the values that occur in a dictionary, >>> d.values() dict_values([820, 870]) >>> To make a dict_values object a list cast it using list(), >>> list(d.values()) [820, 870] >>> Delete all the entries in the dictionary, >>> d.clear() >>> d {} >>> Note that the name d still exists; it just references (points at) an empty dictionary. Finally note that the keys don't have to be strings they can be any immutable type , and the values can be any Python object, e.g. >>> d['Tim'] = 775 >>> d[3] = ['a', 'small', 'list'] >>> d[(0,1)] = 'X' >>> d {(0, 1): 'X', 'Tim': 775, 3: ['a', 'small', 'list']} >>> for key in d: print(key, ':', d[key]) (0, 1) : X Tim : 775 3 : ['a', 'small', 'list'] >>> Literals are how to write out values. 4 is an integer literal, 4.1 is a floating point literal, 'Tim' is a string literal, [0, 'Hi'] is a list literal (notice the square brackets), (0, 1) is a tuple literal (notice the round parentheses), and { 'Tim' : 775, 'Brian' : 869 } is a dictionary literal (notice the curly brackets).","title":"What can you do with a dictionary?"},{"location":"07_Dictionaries/03_What_can_you_do_with_a_dictionary/#what-can-you-do-with-a-dictionary","text":"The full list of methods is in Section 5.5 of the Python Library Reference . Here's an idea of how you might use and combine these methods to carry out common operations. Create a dictionary, Using a dictionary literal*, e.g. d = { 'Tim' : 775, 'Brian' : 869 } we can visualize the dictionary that is created like this, Access an element, print(d['Tim']) The general pattern here is dictionary_name [ key ] = value . So to modify a value, d['Tim'] = 820 and to insert a new value, d['Doug'] = 870 Check to see if there is already an entry with a particular key, 'Brian' in d will return True 'Jill' in d will return False Delete an entry in the dictionary (both the key and its associated value), del( d['Brian'] ) Remove an entry, but get the value, d.pop('Tim') removes the key value pair 'Tim':820 from the dictionary but returns 820 Find out how many key-value pairs are in the dictionary, len( d ) Get a list of all the keys in the dictionary, >>> d.keys() dict_keys(['Tim', 'Doug']) >>> (Note the square brackets and commas: d.keys returns a dict_keys object. You have to cast it explicitly to use it as a list.) >>> list(d.keys()) ['Tim', 'Doug'] >>> You don't have to cast it to a list to iterate through it with a for loop. This is often used for iterating through the entries in the dictionary, e.g. for key in d.keys(): print(key, ':', d[key]) produces the output, >>> Tim : 820 Doug : 870 >>> This can also be shortened to, for key in d: print(key, ':', d[key]) Get a dict_values object of all the values that occur in a dictionary, >>> d.values() dict_values([820, 870]) >>> To make a dict_values object a list cast it using list(), >>> list(d.values()) [820, 870] >>> Delete all the entries in the dictionary, >>> d.clear() >>> d {} >>> Note that the name d still exists; it just references (points at) an empty dictionary. Finally note that the keys don't have to be strings they can be any immutable type , and the values can be any Python object, e.g. >>> d['Tim'] = 775 >>> d[3] = ['a', 'small', 'list'] >>> d[(0,1)] = 'X' >>> d {(0, 1): 'X', 'Tim': 775, 3: ['a', 'small', 'list']} >>> for key in d: print(key, ':', d[key]) (0, 1) : X Tim : 775 3 : ['a', 'small', 'list'] >>> Literals are how to write out values. 4 is an integer literal, 4.1 is a floating point literal, 'Tim' is a string literal, [0, 'Hi'] is a list literal (notice the square brackets), (0, 1) is a tuple literal (notice the round parentheses), and { 'Tim' : 775, 'Brian' : 869 } is a dictionary literal (notice the curly brackets).","title":"What can you do with a dictionary?"},{"location":"07_Dictionaries/04_Example_word_frequencies/","text":"Example: Word Frequencies Now that we have seen dictionary syntax let's put it to work and solve the problem of counting the frequencies of the words in a string. The input will be a string, and the desired output is a display of each word and the number of times it occurred in the string. We'll use a dictionary for our counters where each key-value pair in the dictionary will consist of a word and the number of times it occurred. Pseudocode The pseudocode description might be, get the string break the string into a list of words initialize a dictionary of counters loop through the list of words if the word is in the dictionary increment its counter by 1 otherwise set its counter to 1 loop through the entries in the dictionary for each entry display the key (the word) and the value (the count) Python A straight translation into Python gives, # WordFrequencies.py # Get the string: test_string = '''The programmer, who needs clarity, who must talk all day to a machine that demands declarations, hunkers down into a low-grade annoyance. It is here that the stereotype of the programmer, sitting in a dim room, growling from behind Coke cans, has its origins. The disorder of the desk, the floor; the yellow Post-It notes everywhere; the whiteboards covered with scrawl: all this is the outward manifestation of the messiness of human thought. The messiness cannot go into the program; it piles up around the programmer. ~ Ellen Ullman ''' # Break the string into a list of words: words = test_string.split() # Initialize a dictionary of counters: word_counts = {} # Loop through the list of words: for word in words: # If the word is in the dictionary: if word in word_counts: # Increment its counter by 1: word_counts[word] = word_counts[word] + 1 # Otherwise: else: # Set its counter to 1: word_counts[word] = 1 # Loop through the entries in the dictionary: for word in word_counts: # Display the key value pair: print(word, ':', word_counts[word]) Refinements When you run it and examine the output you will see that while this is a useful core there are some erroneous entries in the output. Among them: The : 3 floor; : 1 annoyance. : 1 the : 10 ~ : 1 The problems here are that, 'The' and 'the' are the same word and so their counts should be combined. The trailing punctuation on 'floor;' and 'annoyance.' should be removed since it is not part of the word, and could mislead counts since 'floor;' and 'floor,' would be separate entries. '\\~' is not a word at all and so should not be counted. Application of some string methods can fix some of these problems, We can use the lower method to convert strings to all lower case. We can use strip to remove trailing (and leading) punctuation characters. We can use isalpha to test that the string is all letters (and thus eliminate '\\~'). The body of the loop then becomes, for word in words: w = word.lower() w = w.strip('.,;:\\'\"?!()') # Notice the \\ to escape the ' inside the string if w.isalpha(): if w in word_counts: word_counts[w] = word_counts[w] + 1 else: word_counts[w] = 1 Of course isalpha is too blunt an instrument since we now lose the hyphenated words, but we could deal with that too (perhaps by writing our own little function to check that a string contains only letters and hyphens!), though it is a matter of details we will not pursue.","title":"Example: Word Frequencies"},{"location":"07_Dictionaries/04_Example_word_frequencies/#example-word-frequencies","text":"Now that we have seen dictionary syntax let's put it to work and solve the problem of counting the frequencies of the words in a string. The input will be a string, and the desired output is a display of each word and the number of times it occurred in the string. We'll use a dictionary for our counters where each key-value pair in the dictionary will consist of a word and the number of times it occurred.","title":"Example: Word Frequencies"},{"location":"07_Dictionaries/04_Example_word_frequencies/#pseudocode","text":"The pseudocode description might be, get the string break the string into a list of words initialize a dictionary of counters loop through the list of words if the word is in the dictionary increment its counter by 1 otherwise set its counter to 1 loop through the entries in the dictionary for each entry display the key (the word) and the value (the count)","title":"Pseudocode"},{"location":"07_Dictionaries/04_Example_word_frequencies/#python","text":"A straight translation into Python gives, # WordFrequencies.py # Get the string: test_string = '''The programmer, who needs clarity, who must talk all day to a machine that demands declarations, hunkers down into a low-grade annoyance. It is here that the stereotype of the programmer, sitting in a dim room, growling from behind Coke cans, has its origins. The disorder of the desk, the floor; the yellow Post-It notes everywhere; the whiteboards covered with scrawl: all this is the outward manifestation of the messiness of human thought. The messiness cannot go into the program; it piles up around the programmer. ~ Ellen Ullman ''' # Break the string into a list of words: words = test_string.split() # Initialize a dictionary of counters: word_counts = {} # Loop through the list of words: for word in words: # If the word is in the dictionary: if word in word_counts: # Increment its counter by 1: word_counts[word] = word_counts[word] + 1 # Otherwise: else: # Set its counter to 1: word_counts[word] = 1 # Loop through the entries in the dictionary: for word in word_counts: # Display the key value pair: print(word, ':', word_counts[word])","title":"Python"},{"location":"07_Dictionaries/04_Example_word_frequencies/#refinements","text":"When you run it and examine the output you will see that while this is a useful core there are some erroneous entries in the output. Among them: The : 3 floor; : 1 annoyance. : 1 the : 10 ~ : 1 The problems here are that, 'The' and 'the' are the same word and so their counts should be combined. The trailing punctuation on 'floor;' and 'annoyance.' should be removed since it is not part of the word, and could mislead counts since 'floor;' and 'floor,' would be separate entries. '\\~' is not a word at all and so should not be counted. Application of some string methods can fix some of these problems, We can use the lower method to convert strings to all lower case. We can use strip to remove trailing (and leading) punctuation characters. We can use isalpha to test that the string is all letters (and thus eliminate '\\~'). The body of the loop then becomes, for word in words: w = word.lower() w = w.strip('.,;:\\'\"?!()') # Notice the \\ to escape the ' inside the string if w.isalpha(): if w in word_counts: word_counts[w] = word_counts[w] + 1 else: word_counts[w] = 1 Of course isalpha is too blunt an instrument since we now lose the hyphenated words, but we could deal with that too (perhaps by writing our own little function to check that a string contains only letters and hyphens!), though it is a matter of details we will not pursue.","title":"Refinements"},{"location":"07_Dictionaries/05_Example_Scrabble_scoring/","text":"Example: Scrabble Scoring Dictionaries aren't only useful for counting. In fact they are more frequently used to look up information by key value. We'll consider a couple of examples of this starting with a small one. Players in the board game Scrabble score points by building words out of letters. The value of a word depends on the letters it is built from. (It also depends on where they are placed on the board, but we'll ignore that issue \u2014 at least for now!). The value of each letter is shown below. Write a function that is passed a word and returns the total Scrabble-value of the word. A=1 B=3 C=3 D=2 E=1 F=4 G=2 H=4 I=1 J=8 K=5 L=1 M=3 N=1 O=1 P=3 Q=10 R=1 S=1 T=1 U=1 V=4 W=4 X=8 Y=4 Z=1 Pseudocode def ScrabbleValue( s ): Initialize the total value to 0 Loop through the word a letter at a time Look up the letter's value Increment the total value by this letter's value Return the total value Python code # ScrabbleScoring.py LETTER_VALUES = {'A':1, 'B':3, 'C':3, 'D':2, 'E':1, 'F':4, 'G':2, 'H':4, 'I':1, 'J':8, 'K':5, 'L':1, 'M':3, 'N':1, 'O':1, 'P':3, 'Q':10, 'R':1, 'S':1, 'T':1, 'U':1, 'V':4, 'W':4, 'X':8, 'Y':4, 'Z':1} def scrabble_value(s): total_value = 0 for letter in s: total_value = total_value + LETTER_VALUES[letter] return total_value if __name__ == '__main__': print('The value of the word HERE is', scrabble_value('HERE')) Note: The documentation and testing are both minimal. I included what I did as placeholders to remind you that they are part of complete programs.","title":"Example: Scrabble Scoring"},{"location":"07_Dictionaries/05_Example_Scrabble_scoring/#example-scrabble-scoring","text":"Dictionaries aren't only useful for counting. In fact they are more frequently used to look up information by key value. We'll consider a couple of examples of this starting with a small one. Players in the board game Scrabble score points by building words out of letters. The value of a word depends on the letters it is built from. (It also depends on where they are placed on the board, but we'll ignore that issue \u2014 at least for now!). The value of each letter is shown below. Write a function that is passed a word and returns the total Scrabble-value of the word. A=1 B=3 C=3 D=2 E=1 F=4 G=2 H=4 I=1 J=8 K=5 L=1 M=3 N=1 O=1 P=3 Q=10 R=1 S=1 T=1 U=1 V=4 W=4 X=8 Y=4 Z=1","title":"Example: Scrabble Scoring"},{"location":"07_Dictionaries/05_Example_Scrabble_scoring/#pseudocode","text":"def ScrabbleValue( s ): Initialize the total value to 0 Loop through the word a letter at a time Look up the letter's value Increment the total value by this letter's value Return the total value","title":"Pseudocode"},{"location":"07_Dictionaries/05_Example_Scrabble_scoring/#python-code","text":"# ScrabbleScoring.py LETTER_VALUES = {'A':1, 'B':3, 'C':3, 'D':2, 'E':1, 'F':4, 'G':2, 'H':4, 'I':1, 'J':8, 'K':5, 'L':1, 'M':3, 'N':1, 'O':1, 'P':3, 'Q':10, 'R':1, 'S':1, 'T':1, 'U':1, 'V':4, 'W':4, 'X':8, 'Y':4, 'Z':1} def scrabble_value(s): total_value = 0 for letter in s: total_value = total_value + LETTER_VALUES[letter] return total_value if __name__ == '__main__': print('The value of the word HERE is', scrabble_value('HERE')) Note: The documentation and testing are both minimal. I included what I did as placeholders to remind you that they are part of complete programs.","title":"Python code"},{"location":"07_Dictionaries/06_Example_Book_database/","text":"Example: Book Database In this example we see that the items stored in the dictionary don't have to be numerical (as they were in the previous two examples). This time we have a small database of book information stored in a dictionary (notice the curly brackets?), books = { \"The C Programming Language\": ['Brian W. Kernighan', 'Dennis M. Ritchie'], \"Harry Potter and the Philosopher's Stone\" : ['J. K. Rowling'], \"The AWK programming language\" : ['Alfred V. Aho', 'Brian W. Kernighan', 'Peter J. Weinberger'], \"The practice of programming\": ['Brian W. Kernighan', 'Rob Pike'], \"The cat in the hat\": ['Dr. Seuss'], \"The UNIX Programming Environment\": ['Brian W. Kernighan', 'Rob Pike'] } Hopefully you can tell by looking at it that the keys are book titles, and the values are book authors. Since books can have multiple authors, lists (notice the square brackets?) are used for these values even when there is a single author. Suppose we wish to write a function to list the titles of the books by a given author. Pseudocode def search_by_author( database, author ): Initialize book_list (the list of books by this author) For each key-value pair in the database If the value contains author Add the key to the book_list Return book_list Translated into Python # BooksDict.py def search_by_author(database, author): book_list = [] for key in database: if author in database[key]: book_list.append( key ) return book_list if __name__ == '__main__': books = { \"Harry Potter and the Philosopher's Stone\" : ['J. K. Rowling'], \"The cat in the hat\": ['Dr. Seuss'], \"The C Programming Language\": ['Brian W. Kernighan', 'Dennis M. Ritchie'], \"The UNIX Programming Environment\": ['Brian W. Kernighan', 'Rob Pike'], \"The AWK programming language\" : ['Alfred V. Aho', 'Brian W. Kernighan', 'Peter J. Weinberger'], \"The practice of programming\": ['Brian W. Kernighan', 'Rob Pike'] } print('J. K. Rowling wrote:', search_by_author(books, 'J. K. Rowling')) print('Brian W. Kernighan wrote:',search_by_author(books, 'Brian W. Kernighan')) print('Tim Topper wrote', search_by_author(books, 'Tim Topper')) which produces as output, >>> J. K. Rowling wrote: [\"Harry Potter and the Philosopher's Stone\"] Brian W. Kernighan wrote: ['The UNIX Programming Environment', 'The practice of programming', 'The AWK programming language', 'The C Programming Language'] Tim Topper wrote: [] >>>","title":"Example: Book Database"},{"location":"07_Dictionaries/06_Example_Book_database/#example-book-database","text":"In this example we see that the items stored in the dictionary don't have to be numerical (as they were in the previous two examples). This time we have a small database of book information stored in a dictionary (notice the curly brackets?), books = { \"The C Programming Language\": ['Brian W. Kernighan', 'Dennis M. Ritchie'], \"Harry Potter and the Philosopher's Stone\" : ['J. K. Rowling'], \"The AWK programming language\" : ['Alfred V. Aho', 'Brian W. Kernighan', 'Peter J. Weinberger'], \"The practice of programming\": ['Brian W. Kernighan', 'Rob Pike'], \"The cat in the hat\": ['Dr. Seuss'], \"The UNIX Programming Environment\": ['Brian W. Kernighan', 'Rob Pike'] } Hopefully you can tell by looking at it that the keys are book titles, and the values are book authors. Since books can have multiple authors, lists (notice the square brackets?) are used for these values even when there is a single author. Suppose we wish to write a function to list the titles of the books by a given author.","title":"Example: Book Database"},{"location":"07_Dictionaries/06_Example_Book_database/#pseudocode","text":"def search_by_author( database, author ): Initialize book_list (the list of books by this author) For each key-value pair in the database If the value contains author Add the key to the book_list Return book_list","title":"Pseudocode"},{"location":"07_Dictionaries/06_Example_Book_database/#translated-into-python","text":"# BooksDict.py def search_by_author(database, author): book_list = [] for key in database: if author in database[key]: book_list.append( key ) return book_list if __name__ == '__main__': books = { \"Harry Potter and the Philosopher's Stone\" : ['J. K. Rowling'], \"The cat in the hat\": ['Dr. Seuss'], \"The C Programming Language\": ['Brian W. Kernighan', 'Dennis M. Ritchie'], \"The UNIX Programming Environment\": ['Brian W. Kernighan', 'Rob Pike'], \"The AWK programming language\" : ['Alfred V. Aho', 'Brian W. Kernighan', 'Peter J. Weinberger'], \"The practice of programming\": ['Brian W. Kernighan', 'Rob Pike'] } print('J. K. Rowling wrote:', search_by_author(books, 'J. K. Rowling')) print('Brian W. Kernighan wrote:',search_by_author(books, 'Brian W. Kernighan')) print('Tim Topper wrote', search_by_author(books, 'Tim Topper')) which produces as output, >>> J. K. Rowling wrote: [\"Harry Potter and the Philosopher's Stone\"] Brian W. Kernighan wrote: ['The UNIX Programming Environment', 'The practice of programming', 'The AWK programming language', 'The C Programming Language'] Tim Topper wrote: [] >>>","title":"Translated into Python"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/","text":"Example: A list of dictionaries Hopefully the last example reminded you that the values in a dictionary can be of any Python type. In the same way that other types can occur inside dictionaries, dictionaries can occur inside other Python data structures. In fact much of the power of programming comes from the freedom with which we can combine its elements. In Part I of the course we saw the many ways that control structures can be combined. Similarly here in Part II we will see that the same applies to data structures. Accordingly our next exhibit is a list of dictionaries. List because the outermost brackets are square, of dictionaries because the inner brackets are curly. data = [ {'id':4721, 'sex':'F', 'age':31}, {'id':1828, 'sex':'M', 'age':56}, {'id':7816, 'sex':'M', 'age':72}, #. . . lots more records . . . {'id':3286, 'sex':'M', 'age':29}, {'id':5063, 'sex':'F', 'age':22} ] Problem 1 How could we display the entry of the oldest individual? Pseudocode We have to start somewhere so let's begin with the first entry and set it to be the oldest record (after all it's the oldest we have seen so far!) Consider each item in the database from the second to the end If the age of this entry is older than our current oldest Update our oldest record Display the oldest record Python code # 70_list_of_dicts.py data = [ {'id':4721, 'sex':'F', 'age':31}, {'id':1828, 'sex':'M', 'age':56}, {'id':7816, 'sex':'M', 'age':72}, #. . . lots more records . . . {'id':3286, 'sex':'M', 'age':29}, {'id':5063, 'sex':'F', 'age':22} ] oldest = data[0] for entry in data[1:]: if entry['age'] > oldest['age']: oldest = entry print('The oldest person is:', oldest) The output of this is, >>> The oldest person is: {'age': 72, 'id': 7816, 'sex': 'M'} >>> Notice that the order of the key-value pairs in the output does not match that in the input. This is generally the case with dictionaries. The output order matches the internal storage order of the pairs, not the input order. (For thought: what should the output be when there are two equally old people, e.g. in this case what if there were two 72 year olds?) Problem 2 How could we output the number of male and female records? Pseudocode Set counter of males to 0 Set counter of females to 0 Consider each item in the database If the value for the key 'sex' is 'M' Increment the counter of males Elif the value of the key 'sex' is 'F' Increment the counter of females Display the male and female counters Python Code nmales = 0 nfemales = 0 for entry in data: if entry['sex'] == 'M': nmales = nmales + 1 elif entry['sex'] == 'F': nfemales = nfemales + 1 print('There are', nmales, 'males and', nfemales, 'females.') Notes: You may be wondering why I used elif and another test rather than just an else . This makes the code easy to modify for people who don't identify as either gender. The n prefix on the counts is a common (but optional) naming practice. It indicates the name represents a count. Why n and not c for count? Probably because n is commonly used for counts in math courses.","title":"Example: A list of dictionaries"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/#example-a-list-of-dictionaries","text":"Hopefully the last example reminded you that the values in a dictionary can be of any Python type. In the same way that other types can occur inside dictionaries, dictionaries can occur inside other Python data structures. In fact much of the power of programming comes from the freedom with which we can combine its elements. In Part I of the course we saw the many ways that control structures can be combined. Similarly here in Part II we will see that the same applies to data structures. Accordingly our next exhibit is a list of dictionaries. List because the outermost brackets are square, of dictionaries because the inner brackets are curly. data = [ {'id':4721, 'sex':'F', 'age':31}, {'id':1828, 'sex':'M', 'age':56}, {'id':7816, 'sex':'M', 'age':72}, #. . . lots more records . . . {'id':3286, 'sex':'M', 'age':29}, {'id':5063, 'sex':'F', 'age':22} ]","title":"Example: A list of dictionaries"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/#problem-1","text":"How could we display the entry of the oldest individual?","title":"Problem 1"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/#pseudocode","text":"We have to start somewhere so let's begin with the first entry and set it to be the oldest record (after all it's the oldest we have seen so far!) Consider each item in the database from the second to the end If the age of this entry is older than our current oldest Update our oldest record Display the oldest record","title":"Pseudocode"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/#python-code","text":"# 70_list_of_dicts.py data = [ {'id':4721, 'sex':'F', 'age':31}, {'id':1828, 'sex':'M', 'age':56}, {'id':7816, 'sex':'M', 'age':72}, #. . . lots more records . . . {'id':3286, 'sex':'M', 'age':29}, {'id':5063, 'sex':'F', 'age':22} ] oldest = data[0] for entry in data[1:]: if entry['age'] > oldest['age']: oldest = entry print('The oldest person is:', oldest) The output of this is, >>> The oldest person is: {'age': 72, 'id': 7816, 'sex': 'M'} >>> Notice that the order of the key-value pairs in the output does not match that in the input. This is generally the case with dictionaries. The output order matches the internal storage order of the pairs, not the input order. (For thought: what should the output be when there are two equally old people, e.g. in this case what if there were two 72 year olds?)","title":"Python code"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/#problem-2","text":"How could we output the number of male and female records?","title":"Problem 2"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/#pseudocode_1","text":"Set counter of males to 0 Set counter of females to 0 Consider each item in the database If the value for the key 'sex' is 'M' Increment the counter of males Elif the value of the key 'sex' is 'F' Increment the counter of females Display the male and female counters","title":"Pseudocode"},{"location":"07_Dictionaries/07_Example_A_list_of_dictionaries/#python-code_1","text":"nmales = 0 nfemales = 0 for entry in data: if entry['sex'] == 'M': nmales = nmales + 1 elif entry['sex'] == 'F': nfemales = nfemales + 1 print('There are', nmales, 'males and', nfemales, 'females.') Notes: You may be wondering why I used elif and another test rather than just an else . This makes the code easy to modify for people who don't identify as either gender. The n prefix on the counts is a common (but optional) naming practice. It indicates the name represents a count. Why n and not c for count? Probably because n is commonly used for counts in math courses.","title":"Python Code"},{"location":"07_Dictionaries/90_Assignment_7/","text":"Assignment 7 Problems Every letter counts First up a problem to give you a little practice working with the collection types (lists and dictionaries). Write the following implementations of the function letter_frequency that takes a string and returns a collection type showing how often each letter of the alphabet occurs in the string. a. The first version ( letter_frequencyA ) should return a list with 26 integer elements representing the frequency of occurrence of each letter of the alphabet in order from a to z. b. The second version ( letter_frequencyB ) should return a list of 26 lists, each of which contains a letter and its associated count. c. The third version ( letter_frequencyC ) should return a dictionary that uses the letters as keys and whose values are the letters' counts. Make sure to use a dictionary specific solution! The program that will call these functions is letter_frequency.py . Your job is to replace the pass statements with function bodies that implement the functionality specified above. Studying the embedded tests should answer any other questions you have about the functions' operations. Anagrams An anagram is produced by rearranging the letters of one word or phrase to produce another word or phrase, e.g. \"cat\" and \"act\" are anagrams, as are \"scare\", \"races\", \"acres\" and \"cares\". Write two functions called anagramsA and anagramsB each of which returns True if the two strings it is passed are anagrams of each other and False otherwise. anagramsA should be based on the observation that if two strings are anagrams they each have the same numbers of each letter in them. This means that their letter frequency counts will be identical. anagramsB should be based on the observation that anagrams are strings that could be rearranged to be the same. One easy way to rearrange things is to use Python's built-in sort methods, so you could test to see if two strings are anagrams by sorting them and comparing the sorted versions. Win 32 Network Resource Anlayzer Many of the Win32 Network Resource enumeration tools return a list of dictionaries: [ {'name':'YVB127','comment':'Rm A2507','type':WKSTATION}, {'name':'YVB143','comment':'Rm T1010','type':SERVER}, ... ] Write the following functions to work with the import 'ed file net_res.py : a. count_summary() should return a dictionary where the machine type is the key and the count of machines of that type is the value. b. list_by_type(type) should be passed a type, e.g. SERVER and return a list of the rooms containing machines of that type. c. max_count() should return the name of the room, e.g. 'Rm A2507', that contains the most computers. Embed your functions in a module with an if __name__ ... block that runs them and displays their output. It should import the file net_res.py . Topography No dictionaries required for this one. It just gives you some more practice working with lists of lists. Suppose you are given some map elevation data stored as a list of lists, e.g. data = [ [20, 54, 50, 64, 60, 63, 60, 48, 20, 20], [20, 56, 72, 76, 72, 20, 52, 62, 53, 20], [20, 52, 62, 81, 67, 23, 48, 67, 52, 20], [20, 54, 54, 82, 72, 22, 42, 64, 50, 20], [20, 53, 49, 87, 69, 47, 48, 49, 21, 20], [20, 20, 62, 71, 61, 36, 28, 31, 22, 20], [20, 20, 20, 20, 20, 22, 21, 28, 24, 20], [20, 20, 20, 20, 20, 20, 20, 20, 20, 20], [20, 20, 20, 20, 20, 20, 20, 20, 20, 20], [20, 20, 20, 20, 20, 20, 20, 20, 20, 20] ] Write a function called peaks that is passed a list of lists like this one and returns a list of the coordinates (row, col) of all the peaks in the dataset. A peak is a point that is higher than its eight surrounding neighbours (the values at (2,7) and (4,3) above are the peaks and the values aroung them are their eight neighbours). For the data set above the function should return, [(2, 7), (4, 3)] Logistics Use the following naming scheme for your program files: a assignment# p problem#yourname .py . So your solution to problem 1 on this assignment will be named a7p1bob.py and your solution for problem 2 will be named a7p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Assignment 7"},{"location":"07_Dictionaries/90_Assignment_7/#assignment-7","text":"","title":"Assignment 7"},{"location":"07_Dictionaries/90_Assignment_7/#problems","text":"","title":"Problems"},{"location":"07_Dictionaries/90_Assignment_7/#every-letter-counts","text":"First up a problem to give you a little practice working with the collection types (lists and dictionaries). Write the following implementations of the function letter_frequency that takes a string and returns a collection type showing how often each letter of the alphabet occurs in the string. a. The first version ( letter_frequencyA ) should return a list with 26 integer elements representing the frequency of occurrence of each letter of the alphabet in order from a to z. b. The second version ( letter_frequencyB ) should return a list of 26 lists, each of which contains a letter and its associated count. c. The third version ( letter_frequencyC ) should return a dictionary that uses the letters as keys and whose values are the letters' counts. Make sure to use a dictionary specific solution! The program that will call these functions is letter_frequency.py . Your job is to replace the pass statements with function bodies that implement the functionality specified above. Studying the embedded tests should answer any other questions you have about the functions' operations.","title":"Every letter counts"},{"location":"07_Dictionaries/90_Assignment_7/#anagrams","text":"An anagram is produced by rearranging the letters of one word or phrase to produce another word or phrase, e.g. \"cat\" and \"act\" are anagrams, as are \"scare\", \"races\", \"acres\" and \"cares\". Write two functions called anagramsA and anagramsB each of which returns True if the two strings it is passed are anagrams of each other and False otherwise. anagramsA should be based on the observation that if two strings are anagrams they each have the same numbers of each letter in them. This means that their letter frequency counts will be identical. anagramsB should be based on the observation that anagrams are strings that could be rearranged to be the same. One easy way to rearrange things is to use Python's built-in sort methods, so you could test to see if two strings are anagrams by sorting them and comparing the sorted versions.","title":"Anagrams"},{"location":"07_Dictionaries/90_Assignment_7/#win-32-network-resource-anlayzer","text":"Many of the Win32 Network Resource enumeration tools return a list of dictionaries: [ {'name':'YVB127','comment':'Rm A2507','type':WKSTATION}, {'name':'YVB143','comment':'Rm T1010','type':SERVER}, ... ] Write the following functions to work with the import 'ed file net_res.py : a. count_summary() should return a dictionary where the machine type is the key and the count of machines of that type is the value. b. list_by_type(type) should be passed a type, e.g. SERVER and return a list of the rooms containing machines of that type. c. max_count() should return the name of the room, e.g. 'Rm A2507', that contains the most computers. Embed your functions in a module with an if __name__ ... block that runs them and displays their output. It should import the file net_res.py .","title":"Win 32 Network Resource Anlayzer"},{"location":"07_Dictionaries/90_Assignment_7/#topography","text":"No dictionaries required for this one. It just gives you some more practice working with lists of lists. Suppose you are given some map elevation data stored as a list of lists, e.g. data = [ [20, 54, 50, 64, 60, 63, 60, 48, 20, 20], [20, 56, 72, 76, 72, 20, 52, 62, 53, 20], [20, 52, 62, 81, 67, 23, 48, 67, 52, 20], [20, 54, 54, 82, 72, 22, 42, 64, 50, 20], [20, 53, 49, 87, 69, 47, 48, 49, 21, 20], [20, 20, 62, 71, 61, 36, 28, 31, 22, 20], [20, 20, 20, 20, 20, 22, 21, 28, 24, 20], [20, 20, 20, 20, 20, 20, 20, 20, 20, 20], [20, 20, 20, 20, 20, 20, 20, 20, 20, 20], [20, 20, 20, 20, 20, 20, 20, 20, 20, 20] ] Write a function called peaks that is passed a list of lists like this one and returns a list of the coordinates (row, col) of all the peaks in the dataset. A peak is a point that is higher than its eight surrounding neighbours (the values at (2,7) and (4,3) above are the peaks and the values aroung them are their eight neighbours). For the data set above the function should return, [(2, 7), (4, 3)]","title":"Topography"},{"location":"07_Dictionaries/90_Assignment_7/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem#yourname .py . So your solution to problem 1 on this assignment will be named a7p1bob.py and your solution for problem 2 will be named a7p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Logistics"},{"location":"08_Persistence/","text":"Introduction: Persistence \u221e The topic of this module is persistence, but not of the human variety. In computer science persistence refers to the persistence of our data from one run of a program to the next. Normally all data (variables) are destroyed when a program terminates so the next run starts from scratch, but often times we want to remember the state of our program from one run to the next, or we may want to process data that is already stored on the computer, e.g. in files on disk. We do that by reading and writing data from files. You know where to go to read more! Persistence Text versus Binary Files Reading from text files Example: Searching log files Important note: Files are sequential Is there more? Writing to text files Appending to files Reading numeric data Designing file formats Pickling Shelves A controller for our database The main event loop Assignment 8","title":"Introduction: Persistence \u221e"},{"location":"08_Persistence/#introduction-persistence","text":"The topic of this module is persistence, but not of the human variety. In computer science persistence refers to the persistence of our data from one run of a program to the next. Normally all data (variables) are destroyed when a program terminates so the next run starts from scratch, but often times we want to remember the state of our program from one run to the next, or we may want to process data that is already stored on the computer, e.g. in files on disk. We do that by reading and writing data from files. You know where to go to read more! Persistence Text versus Binary Files Reading from text files Example: Searching log files Important note: Files are sequential Is there more? Writing to text files Appending to files Reading numeric data Designing file formats Pickling Shelves A controller for our database The main event loop Assignment 8","title":"Introduction: Persistence \u221e"},{"location":"08_Persistence/01_Persistence/","text":"Persistence So far each run of one of our programs has been independent from the rest. Each began with a blank slate of memory working only with values input during that run of the program, and all its results were lost when the program ended. This is typical of calculation type programs in which some one-time value is calculated, but there are many other types of programs that either work on existing data, or need to store their results. For example most office applications work on long-lived documents. You may use a word processor to open the existing copy of your resume, update it and then save the new version. Game programs may wish to save the state of a game so it can be resumed later, or to record and store a high score. What these situations require is the ability to move data out of RAM, which is volatile, often reused after a program terminates and always lost when a computer is turned off, to a longer lasting, stable storage medium, i.e. to move the data from memory to disk. The technical term for this is data persistence. There are several choices for the persistence medium Local text files Local binary files Local or remote database servers Remote storage, e.g. across the internet In this module we will consider the first two options.","title":"Persistence"},{"location":"08_Persistence/01_Persistence/#persistence","text":"So far each run of one of our programs has been independent from the rest. Each began with a blank slate of memory working only with values input during that run of the program, and all its results were lost when the program ended. This is typical of calculation type programs in which some one-time value is calculated, but there are many other types of programs that either work on existing data, or need to store their results. For example most office applications work on long-lived documents. You may use a word processor to open the existing copy of your resume, update it and then save the new version. Game programs may wish to save the state of a game so it can be resumed later, or to record and store a high score. What these situations require is the ability to move data out of RAM, which is volatile, often reused after a program terminates and always lost when a computer is turned off, to a longer lasting, stable storage medium, i.e. to move the data from memory to disk. The technical term for this is data persistence. There are several choices for the persistence medium Local text files Local binary files Local or remote database servers Remote storage, e.g. across the internet In this module we will consider the first two options.","title":"Persistence"},{"location":"08_Persistence/02_Text_versus_binary_files/","text":"Text versus Binary Files Files on disk are always just sequences of bytes so how can there be two types, text and binary? The difference between text and binary files is not a physical difference on disk, but a difference in the way those bytes are_interpreted_ Consider storing the two dimensional coordinate (12, 31) to disk. Storing it as text would be in essence to print it to a file (instead of the screen). We can visualize the file contents to be, ------------------------- | 1 | 2 | , | 3 | 1 | EOF | ------------------------- where EOF is the character used to mark the end of a file. (The actual character used for the end of file marker is operating system dependent.) Of course what is actually written to disk are the ASCII values of those characters, so what is on disk is, 49 50 44 51 49 26 To be even more precise the values will be stored in binary so the disk contents will be, 00110001 00110010 00101100 00110011 00110001 00011010 Thank goodness the computer can read it! What about storing it in a binary file? In this case we will write the binary representations of the numbers 12 and 31 to disk in sequence. The number of bytes used to do this on disk varies from 1 to 8, but using typical four byte representations we would write the following to disk: 00000000 00000000 00000000 00001100 00000000 00000000 00000000 00011111 00011010 As you can see both files have binary representations on disk so why do we call the first text and only the second binary? Because to be meaningful each should be interpreted differently. We call the first a text file because its bits should be interpreted as giving the ASCII values of text characters. We call the second binary because its bits should be read in four bytes at a time and interpreted as integer values. Notice that it doesn't say this inside the files. That knowledge has to be built into the suite of programs that create and manipulate the files. Note that either representation could be read in as either text, i.e. a sequence of bytes corresponding to ASCII codes of characters, or binary, i.e. a pair of 4-byte wide integers, but that in each case the wrong interpretation produces nonsense. So knowing the correct interpretation is crucial. In everyday computing you can often tell which interpretation is correct by displaying some of the file to a terminal, or opening it in a 'pure' text editor, e.g. the IDLE editor. Here's a dump of a small Python program to a terminal, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat s2bin.py # s2bin.py # Converts from a string to its binary representation. HEXBIN ={\"0\":\"0000\", \"1\":\"0001\", \"2\":\"0010\", \"3\":\"0011\", \"4\":\"0100\", \"5\":\"0101\", \"6\":\"0110\", \"7\":\"0111\", \"8\":\"1000\", \"9\":\"1001\", \"A\":\"1010\", \"B\":\"1011\", \"C\":\"1100\", \"D\":\"1101\", \"E\":\"1110\", \"F\":\"1111\"} s = '112,31' for c in s: n = ord(c) print() \"\".join([HEXBIN[i] for i in '%X'%n]) ) ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ And here's a partial dump of an MS Word document, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat MSWordFile.doc DI\u25c4\u00e0\u00a1\u00b1\u2192\u00e1 > \u2665 _\u00ff \u2660 \u263a * \u25ba , \u263a _\u00ff\u00ff\u00ff ) \u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ec\u00a5A %` \u2666 d\u2195\u00bf \u25ba \u2660 / \u266b bjbjN\u00e0N\u00e0 \u2666 \u25ac .\u25ba ,S\u263a ,S\u263a / \u00ff\u00ff \u00ff\u00ff \u00ff\u00ff \u263c \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00b6 ,\u2665 \u00fc\u2665 \u00fc \u2665 \u00fc\u2665 \u00fc\u2665 \u2640 \u2666 \u2640 ,\u2665 \u2640\u2660 o \u2666 \u2666 \u2666 \u2666 \u2666\u00fb \u2666 \u00fb\u2666 \u00fb\u2666 <\u2663 \u263b ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 $ \u2666 h\u263b l \u00aa \u00b1\u2663 \u00a7 \u263c\u2665 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u263c\u2665 \u263c\u2665 \u2666 \u2666 U \u00c6\u2663 \u25ac #\u2663 #\u2663 #\u2663 \u00fb\u2666 \u263c\u2665 \u2666 \u263c\u2665 \u2666 <\u2663 #\u2663 \u00fb \u2666 <\u2663 #\u2663 #\u2663 \u263c\u2665 \u263c\u2665 # \u2663 \u2666 \u00b6\u2666 \u2640 `l\"._A\u00c9\u263a \u00fc\u2665 \u2663 #\u2663 <\u2663 \u00dc\u2663 0 \u2640\u2660 #\u2663 \u25ac \u2663 \u25ac #\u2663 \u25ac \u263c\u2665 #\u2663 h \u00fb\u2666 \u00fb\u2666 #\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u00b1\u2663 \u2193\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u2640\u2660 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 ,\u2665 ,\u2665 ,\u2665 D \u00fc\u2665 ,\u2665 ,\u2665 ,\u2665 \u00fc \u2665 ,\u2665 ,\u2665 ,\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00ff \u00ff\u00ff\u00ff \u263b \u2640\u263a T his is a very simple one line word document. \u2660 \u266b \u00a7 - . / o\u00e9oYoOo \u00b6 As you can see it is easy to tell which file is a text file and which binary (though if you look toward the bottom of the dump of the word file you can see some text content).","title":"Text versus Binary Files"},{"location":"08_Persistence/02_Text_versus_binary_files/#text-versus-binary-files","text":"Files on disk are always just sequences of bytes so how can there be two types, text and binary? The difference between text and binary files is not a physical difference on disk, but a difference in the way those bytes are_interpreted_ Consider storing the two dimensional coordinate (12, 31) to disk. Storing it as text would be in essence to print it to a file (instead of the screen). We can visualize the file contents to be, ------------------------- | 1 | 2 | , | 3 | 1 | EOF | ------------------------- where EOF is the character used to mark the end of a file. (The actual character used for the end of file marker is operating system dependent.) Of course what is actually written to disk are the ASCII values of those characters, so what is on disk is, 49 50 44 51 49 26 To be even more precise the values will be stored in binary so the disk contents will be, 00110001 00110010 00101100 00110011 00110001 00011010 Thank goodness the computer can read it! What about storing it in a binary file? In this case we will write the binary representations of the numbers 12 and 31 to disk in sequence. The number of bytes used to do this on disk varies from 1 to 8, but using typical four byte representations we would write the following to disk: 00000000 00000000 00000000 00001100 00000000 00000000 00000000 00011111 00011010 As you can see both files have binary representations on disk so why do we call the first text and only the second binary? Because to be meaningful each should be interpreted differently. We call the first a text file because its bits should be interpreted as giving the ASCII values of text characters. We call the second binary because its bits should be read in four bytes at a time and interpreted as integer values. Notice that it doesn't say this inside the files. That knowledge has to be built into the suite of programs that create and manipulate the files. Note that either representation could be read in as either text, i.e. a sequence of bytes corresponding to ASCII codes of characters, or binary, i.e. a pair of 4-byte wide integers, but that in each case the wrong interpretation produces nonsense. So knowing the correct interpretation is crucial. In everyday computing you can often tell which interpretation is correct by displaying some of the file to a terminal, or opening it in a 'pure' text editor, e.g. the IDLE editor. Here's a dump of a small Python program to a terminal, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat s2bin.py # s2bin.py # Converts from a string to its binary representation. HEXBIN ={\"0\":\"0000\", \"1\":\"0001\", \"2\":\"0010\", \"3\":\"0011\", \"4\":\"0100\", \"5\":\"0101\", \"6\":\"0110\", \"7\":\"0111\", \"8\":\"1000\", \"9\":\"1001\", \"A\":\"1010\", \"B\":\"1011\", \"C\":\"1100\", \"D\":\"1101\", \"E\":\"1110\", \"F\":\"1111\"} s = '112,31' for c in s: n = ord(c) print() \"\".join([HEXBIN[i] for i in '%X'%n]) ) ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ And here's a partial dump of an MS Word document, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat MSWordFile.doc DI\u25c4\u00e0\u00a1\u00b1\u2192\u00e1 > \u2665 _\u00ff \u2660 \u263a * \u25ba , \u263a _\u00ff\u00ff\u00ff ) \u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ec\u00a5A %` \u2666 d\u2195\u00bf \u25ba \u2660 / \u266b bjbjN\u00e0N\u00e0 \u2666 \u25ac .\u25ba ,S\u263a ,S\u263a / \u00ff\u00ff \u00ff\u00ff \u00ff\u00ff \u263c \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00b6 ,\u2665 \u00fc\u2665 \u00fc \u2665 \u00fc\u2665 \u00fc\u2665 \u2640 \u2666 \u2640 ,\u2665 \u2640\u2660 o \u2666 \u2666 \u2666 \u2666 \u2666\u00fb \u2666 \u00fb\u2666 \u00fb\u2666 <\u2663 \u263b ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 $ \u2666 h\u263b l \u00aa \u00b1\u2663 \u00a7 \u263c\u2665 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u263c\u2665 \u263c\u2665 \u2666 \u2666 U \u00c6\u2663 \u25ac #\u2663 #\u2663 #\u2663 \u00fb\u2666 \u263c\u2665 \u2666 \u263c\u2665 \u2666 <\u2663 #\u2663 \u00fb \u2666 <\u2663 #\u2663 #\u2663 \u263c\u2665 \u263c\u2665 # \u2663 \u2666 \u00b6\u2666 \u2640 `l\"._A\u00c9\u263a \u00fc\u2665 \u2663 #\u2663 <\u2663 \u00dc\u2663 0 \u2640\u2660 #\u2663 \u25ac \u2663 \u25ac #\u2663 \u25ac \u263c\u2665 #\u2663 h \u00fb\u2666 \u00fb\u2666 #\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u00b1\u2663 \u2193\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u2640\u2660 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 ,\u2665 ,\u2665 ,\u2665 D \u00fc\u2665 ,\u2665 ,\u2665 ,\u2665 \u00fc \u2665 ,\u2665 ,\u2665 ,\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00ff \u00ff\u00ff\u00ff \u263b \u2640\u263a T his is a very simple one line word document. \u2660 \u266b \u00a7 - . / o\u00e9oYoOo \u00b6 As you can see it is easy to tell which file is a text file and which binary (though if you look toward the bottom of the dump of the word file you can see some text content).","title":"Text versus Binary Files"},{"location":"08_Persistence/03_Reading_from_text_files/","text":"Reading from text files Here's how to read data from a text file. To begin with use IDLE to create a small test text file: We can visualize this on disk as, T h e f i r s t l i n e . \\n L i n e 2 . \\n T h e t h i r d a n d l a s t l i n e . \\n EOF The only new item here are the \\n characters These denote newline characters which like EOF characters vary between operating sytems. (Don't worry the Python you installed was compiled to know what they are on your system). There are three common ways of reading a text file like this in: One line at a time, processing lines as we go, The whole file into a string, The whole file into a list of strings, one entry per line. When possible, option 1. is preferred since it is the most memory efficient because it holds only a bit of the file (one line) in memory at any given time. Here's the Python code for each of these options. One line at a time: # file_read_1.py f = open('text_file.txt', 'r') # Open the file. for line in f: # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. f.close() # Close the file. or with a while loop... # file_read_1.py f = open('text_file.txt', 'r') # Open the file. line = f.readline() # Get the first line. while line != \"\": # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. line = f.readline() f.close() # Close the file. Notes: The arguments to the open function are the name of the file to open, and the mode in which to open it. Here the r stands for read . As you can see by the for statement, iteration over file objects is defined just as it is for lists. The default iteration is to grab one line each time. You should always close files when you are finished reading from them. The file object will be garbage collected eventually anyway and the file closed at that time, but closing ASAP reduces memory consumption and allows other processes to access the file sooner. Output: >>> The first line. Line 2. The third and last line. >>> The whole file into a string: # file_read_2.py f = open('text_file.txt', 'r') s = f.read() print('s is', len(s), 'characters long.') print(s) f.close() The read method of the file object f reads the entire file including newline characters into memory. >>> s is 49 characters long. The first line. Line 2. The third and last line. >>> Note that the file looks the same as before when displayed because the IDLE shell interprets the newline characters embedded in it as instructions to start new lines. read() can also take an integer argument specifying how many bytes to read from the file. Its default behaviour is to read all of them. The whole file into a list of strings, # file_read_3.py f = open('text_file.txt', 'r') lines = f.readlines() print(lines) f.close() Output: >>> ['The first line.\\n', 'Line 2.\\n', 'The third and last line.\\n'] >>> Note that the newline character is included. If you don't want it you need to strip it yourself.","title":"Reading from text files"},{"location":"08_Persistence/03_Reading_from_text_files/#reading-from-text-files","text":"Here's how to read data from a text file. To begin with use IDLE to create a small test text file: We can visualize this on disk as, T h e f i r s t l i n e . \\n L i n e 2 . \\n T h e t h i r d a n d l a s t l i n e . \\n EOF The only new item here are the \\n characters These denote newline characters which like EOF characters vary between operating sytems. (Don't worry the Python you installed was compiled to know what they are on your system). There are three common ways of reading a text file like this in: One line at a time, processing lines as we go, The whole file into a string, The whole file into a list of strings, one entry per line. When possible, option 1. is preferred since it is the most memory efficient because it holds only a bit of the file (one line) in memory at any given time. Here's the Python code for each of these options.","title":"Reading from text files"},{"location":"08_Persistence/03_Reading_from_text_files/#one-line-at-a-time","text":"# file_read_1.py f = open('text_file.txt', 'r') # Open the file. for line in f: # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. f.close() # Close the file. or with a while loop... # file_read_1.py f = open('text_file.txt', 'r') # Open the file. line = f.readline() # Get the first line. while line != \"\": # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. line = f.readline() f.close() # Close the file. Notes: The arguments to the open function are the name of the file to open, and the mode in which to open it. Here the r stands for read . As you can see by the for statement, iteration over file objects is defined just as it is for lists. The default iteration is to grab one line each time. You should always close files when you are finished reading from them. The file object will be garbage collected eventually anyway and the file closed at that time, but closing ASAP reduces memory consumption and allows other processes to access the file sooner. Output: >>> The first line. Line 2. The third and last line. >>>","title":"One line at a time:"},{"location":"08_Persistence/03_Reading_from_text_files/#the-whole-file-into-a-string","text":"# file_read_2.py f = open('text_file.txt', 'r') s = f.read() print('s is', len(s), 'characters long.') print(s) f.close() The read method of the file object f reads the entire file including newline characters into memory. >>> s is 49 characters long. The first line. Line 2. The third and last line. >>> Note that the file looks the same as before when displayed because the IDLE shell interprets the newline characters embedded in it as instructions to start new lines. read() can also take an integer argument specifying how many bytes to read from the file. Its default behaviour is to read all of them.","title":"The whole file into a string:"},{"location":"08_Persistence/03_Reading_from_text_files/#the-whole-file-into-a-list-of-strings","text":"# file_read_3.py f = open('text_file.txt', 'r') lines = f.readlines() print(lines) f.close() Output: >>> ['The first line.\\n', 'Line 2.\\n', 'The third and last line.\\n'] >>> Note that the newline character is included. If you don't want it you need to strip it yourself.","title":"The whole file into a list of strings,"},{"location":"08_Persistence/04_Example_searching_log_files/","text":"Example: Searching log files Suppose as part of a security audit we want to display all the lines from our web server log file containing the IP address 199.247.232.110. The file name is access.log.1 and the first ten lines of the file look like this, 66.235.124.20 - - [12/Apr/2009:07:29:25 -0700] \"GET /Math130.F05/index.html HTTP/1.1\" 200 34928 \"-\" \"Mozilla/5.0 (compatible; Ask Jeeves/Teoma; +http://about.ask.com/en/docs/about/webmasters.shtml)\" 72.30.142.250 - - [12/Apr/2009:07:51:05 -0700] \"GET /Math130.F07/BayesProblems.html HTTP/1.0\" 200 2812 \"-\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 72.30.142.250 - - [12/Apr/2009:07:51:09 -0700] \"GET /Math130.F07/130.css HTTP/1.0\" 304 - \"http://ttopper.yukoncollege.yk.ca/Math130.F07/BayesProblems.html\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 216.126.125.105 - - [12/Apr/2009:08:36:00 -0700] \"GET /NCIT210.W09/05_ListsAndStrings/PlayingCards.html HTTP/1.1\" 200 20753 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 216.126.125.105 - - [12/Apr/2009:08:36:22 -0700] \"GET /NCIT210.W09/07_Dictionaries/07_Assignment.html HTTP/1.1\" 200 5817 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-27.jpg HTTP/1.1\" 200 24136 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-25.jpg HTTP/1.1\" 200 67164 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" The file is quite large, 100s of megabytes in size, so we'd rather not read it all into memory if we can avoid it so we'll use a line at a time approach. Our pseudocode looks like this, Get the name of the log file Get the name of the IP address to scan for Open the file for reading For each line in the file If the line contains the IP address Display the line and in Python we get, # ip_extractor.py fname = input('What file do you want to scan? ') ip = input('What IP address do you want to scan for? ') f = open(fname, 'r') for line in f: if line.find(ip) != -1: print(line) which produces the output, >>> What file do you want to scan? access.log.1 Waht IP address do you want to scan for? 199.247.232.110 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" ...","title":"Example: Searching log files"},{"location":"08_Persistence/04_Example_searching_log_files/#example-searching-log-files","text":"Suppose as part of a security audit we want to display all the lines from our web server log file containing the IP address 199.247.232.110. The file name is access.log.1 and the first ten lines of the file look like this, 66.235.124.20 - - [12/Apr/2009:07:29:25 -0700] \"GET /Math130.F05/index.html HTTP/1.1\" 200 34928 \"-\" \"Mozilla/5.0 (compatible; Ask Jeeves/Teoma; +http://about.ask.com/en/docs/about/webmasters.shtml)\" 72.30.142.250 - - [12/Apr/2009:07:51:05 -0700] \"GET /Math130.F07/BayesProblems.html HTTP/1.0\" 200 2812 \"-\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 72.30.142.250 - - [12/Apr/2009:07:51:09 -0700] \"GET /Math130.F07/130.css HTTP/1.0\" 304 - \"http://ttopper.yukoncollege.yk.ca/Math130.F07/BayesProblems.html\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 216.126.125.105 - - [12/Apr/2009:08:36:00 -0700] \"GET /NCIT210.W09/05_ListsAndStrings/PlayingCards.html HTTP/1.1\" 200 20753 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 216.126.125.105 - - [12/Apr/2009:08:36:22 -0700] \"GET /NCIT210.W09/07_Dictionaries/07_Assignment.html HTTP/1.1\" 200 5817 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-27.jpg HTTP/1.1\" 200 24136 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-25.jpg HTTP/1.1\" 200 67164 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" The file is quite large, 100s of megabytes in size, so we'd rather not read it all into memory if we can avoid it so we'll use a line at a time approach. Our pseudocode looks like this, Get the name of the log file Get the name of the IP address to scan for Open the file for reading For each line in the file If the line contains the IP address Display the line and in Python we get, # ip_extractor.py fname = input('What file do you want to scan? ') ip = input('What IP address do you want to scan for? ') f = open(fname, 'r') for line in f: if line.find(ip) != -1: print(line) which produces the output, >>> What file do you want to scan? access.log.1 Waht IP address do you want to scan for? 199.247.232.110 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" ...","title":"Example: Searching log files"},{"location":"08_Persistence/05_Important_note_Files_are_sequential/","text":"Important note: Files are sequential One thing that is not illustrated by the examples so far is that files are sequential. They evolved from physical tape devices that only went forward, or all the way back to the beginning of the file, so you are always moving forward through a file as you read from it. Thus after doing a .read() from a file you are at the end of it and doing another .read() will not reread it, e.g. >>> f = open('text_file.txt','r') >>> s = f.read() >>> s 'The first line.\\nLine 2.\\nThe third and last line.\\n' >>> p = f.read() >>> p '' >>> f.close() >>> Note that it is not an error to try and read from the end of a file (notice that there's no error message above), you just don't get anything because there is nothing more to get (see how p is a null string above?).","title":"Important note: Files are sequential"},{"location":"08_Persistence/05_Important_note_Files_are_sequential/#important-note-files-are-sequential","text":"One thing that is not illustrated by the examples so far is that files are sequential. They evolved from physical tape devices that only went forward, or all the way back to the beginning of the file, so you are always moving forward through a file as you read from it. Thus after doing a .read() from a file you are at the end of it and doing another .read() will not reread it, e.g. >>> f = open('text_file.txt','r') >>> s = f.read() >>> s 'The first line.\\nLine 2.\\nThe third and last line.\\n' >>> p = f.read() >>> p '' >>> f.close() >>> Note that it is not an error to try and read from the end of a file (notice that there's no error message above), you just don't get anything because there is nothing more to get (see how p is a null string above?).","title":"Important note: Files are sequential"},{"location":"08_Persistence/06_Is_there_more/","text":"Is there more? Of course there is: you can tell where you are in a text file by using its tell method, i.e. f.tell() , you can seek to a particular location in a file using f.seek( offset ) , tell if a file is open by checking its closed attribute. There is always more...but this is enough for now 1 . >>> dir(f) ['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines'] >>> If it is not enough for you, you can read more online or explore via the Python Shell, e.g. \u21a9","title":"Is there more?"},{"location":"08_Persistence/06_Is_there_more/#is-there-more","text":"Of course there is: you can tell where you are in a text file by using its tell method, i.e. f.tell() , you can seek to a particular location in a file using f.seek( offset ) , tell if a file is open by checking its closed attribute. There is always more...but this is enough for now 1 . >>> dir(f) ['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines'] >>> If it is not enough for you, you can read more online or explore via the Python Shell, e.g. \u21a9","title":"Is there more?"},{"location":"08_Persistence/07_Writing_to_text_files/","text":"Writing to text files The mechanics of writing to text files are very straightforward. Suppose we need to store a list of coordinates to a text file, e.g. coords = [[12, 31], [75, 19], [28, 51]] Writing them to a file could be done by code like this, # write_coords.py coords = [[12, 31], [75, 19], [28, 51]] fname = input('Name of file to create? ') f = open(fname, 'w') for coord in coords: f.write(str(coord[0]) + ' ' + str(coord[1]) + '\\n') f.close() The pattern is similar to reading from a file: We open the file, but with a mode of w for w rite. Note the wording of the prompt 'Name of file to create? ' Opening a file for writing deletes an existing file of the same name if one exists! In production code it is critical to either know you can clobber existing files, or to check whether a file name has already been used, and then prompt the user for another name if existing files shouldn't be clobbered. We direct output to the file using the file object's write method. This method wants a string argument so we need to format our coordinates accordingly ( f.write(coord[0] )) would throw an error). Note that we also have to add the newline character ourselves. When we are done we close the file. The resulting file looks like this if you open it in a text editor, e.g. IDLE, 12 31 75 19 28 51","title":"Writing to text files"},{"location":"08_Persistence/07_Writing_to_text_files/#writing-to-text-files","text":"The mechanics of writing to text files are very straightforward. Suppose we need to store a list of coordinates to a text file, e.g. coords = [[12, 31], [75, 19], [28, 51]] Writing them to a file could be done by code like this, # write_coords.py coords = [[12, 31], [75, 19], [28, 51]] fname = input('Name of file to create? ') f = open(fname, 'w') for coord in coords: f.write(str(coord[0]) + ' ' + str(coord[1]) + '\\n') f.close() The pattern is similar to reading from a file: We open the file, but with a mode of w for w rite. Note the wording of the prompt 'Name of file to create? ' Opening a file for writing deletes an existing file of the same name if one exists! In production code it is critical to either know you can clobber existing files, or to check whether a file name has already been used, and then prompt the user for another name if existing files shouldn't be clobbered. We direct output to the file using the file object's write method. This method wants a string argument so we need to format our coordinates accordingly ( f.write(coord[0] )) would throw an error). Note that we also have to add the newline character ourselves. When we are done we close the file. The resulting file looks like this if you open it in a text editor, e.g. IDLE, 12 31 75 19 28 51","title":"Writing to text files"},{"location":"08_Persistence/08_Appending_to_files/","text":"Appending to files If opening a file to write to it destroys an existing file by that name you might be wondering how log files work. After all they just grow as new events occur and are added to the log of events that have occurred in the past. The answer is that there is one more mode, a for a ppend which allows you to open a file to append things to it, i.e. the existing file data is not destroyed, and the insertion point is placed at the end of the file so further writes add to the existing file content.","title":"Appending to files"},{"location":"08_Persistence/08_Appending_to_files/#appending-to-files","text":"If opening a file to write to it destroys an existing file by that name you might be wondering how log files work. After all they just grow as new events occur and are added to the log of events that have occurred in the past. The answer is that there is one more mode, a for a ppend which allows you to open a file to append things to it, i.e. the existing file data is not destroyed, and the insertion point is placed at the end of the file so further writes add to the existing file content.","title":"Appending to files"},{"location":"08_Persistence/09_Reading_numeric_data/","text":"Reading numeric data In the examples so far we have read string data, but what if we wanted to read numerical data, e.g. to read our coordinates back in and reconstitute the list coords ? Pseudocode, Open the file Initialize coords to an empty list Read it a line at a time Split the line into parts at blanks Convert each part into an integer value Append the integer values to the list coords In Python, # read_coords.py coords = [] fname = input('Name of file to read from? ') f = open(fname, 'r') for line in f: (x_string, y_string) = line.split() coords.append([int(x_string),int(y_string)]) f.close() print('coords =', coords) A sample run: >>> Name of file to read from? test.dat coords = [[12, 31], [75, 19], [28, 51]] >>>","title":"Reading numeric data"},{"location":"08_Persistence/09_Reading_numeric_data/#reading-numeric-data","text":"In the examples so far we have read string data, but what if we wanted to read numerical data, e.g. to read our coordinates back in and reconstitute the list coords ? Pseudocode, Open the file Initialize coords to an empty list Read it a line at a time Split the line into parts at blanks Convert each part into an integer value Append the integer values to the list coords In Python, # read_coords.py coords = [] fname = input('Name of file to read from? ') f = open(fname, 'r') for line in f: (x_string, y_string) = line.split() coords.append([int(x_string),int(y_string)]) f.close() print('coords =', coords) A sample run: >>> Name of file to read from? test.dat coords = [[12, 31], [75, 19], [28, 51]] >>>","title":"Reading numeric data"},{"location":"08_Persistence/10_Designing_file_formats/","text":"Designing file formats In the previous example we stored our coordinates \"one pair to a line separated by white space\". That description specifies a file format. Of course it's not the only file format possible. We could have put all the data onto one line, or separated items with commas instead of spaces, or... The limits to what we could design are just the limits of our ingenuity. The differences of one versus many lines, and commas versus spaces are just cosmetic, but sometimes quite different approaches can be taken to storing some data. One accessible problem that affords different alternatives is the problem of storing the state of the universe in Conway's Game of Life. You can read about this \"game\" on Wikipedia and play it online here (among many others). The universe in Conway's game of life is a grid of cells each of which can be in one of two states: alive or dead. A natural way to represent it in Python would be as a list of lists of cells (like a very large tic-tac-toe board): universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] Option 1 One way to write this to a text file would be to write lines of space-separated 0s and 1s to the file: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 The size of this file would be 136 bytes because we have one byte for the 0 or 1 for each cell, 1 byte for the space to separate them, and 1 byte for the line end marking the end of each row of the universe, i.e. 1 \u00d7 8 \u00d7 8 + 1 \u00d7 8 \u00d7 8 + 1 \u00d7 8 = 136 bytes. Generalizing this, an n \u00d7 n universe would require 2 n 2 + n bytes. Option 2 Using text graphics the universe might be displayed onscreen using blanks to represent dead cells and asterisks to represent live cells like this: * * *** This suggests a second approach: we could save the state of the universe by taking a \"snapshot\" of it and writing that snapshot to the file. Our file would look just like the universe, and would use somewhat less storage because this time we use one byte (to store either a blank character or an asterisk character) for each cell, and one byte for the newline at the end of each row. Thus for an n \u00d7 n universe we would require n 2 + n bytes or roughly half as much storage (for medium and large values of n ). For our 8 \u00d7 8 universe this approach uses 72 bytes. Option 3 You will have noticed when playing the online games of life (you did play them didn't you?) that the universe is usually \"sparse\", that is there are usually relatively few live cells among a great many dead ones. This is a consequence of Conway's rules: cells die easily of overcrowding, so if an area becomes densely populated the cells in it quickly die off keeping overall densities low. This suggests that we may be wasting space storing all those dead cells. Instead we should just store the locations of live cells. Our file format for the universe above would then be: 8 8 2 3 3 4 4 2 4 3 4 4 where each row after the first one records the location of one live cell in row col form, i.e. the first number gives the row of the cell and the second gives its column. What about the 8s in the first row? With this representation the file does not directly convey the size of the universe as it did in the first two options so we must explicitly state the size of the universe; it's the job of the first line of data to give the height and width of the universe. The storage requirement of this option depends not on the size of the universe, but on the number of live cells in it. For a universe less than 11 \u00d7 11 in size it uses 4 bytes per live cell (1 for row, 1 for separating space, 1 for col and 1 for line end), plus another 4 for the universe size. Generalizing: 4 n + 4 bytes where n gives the number of live cells. (Note that the memory storage is affected by the size of the universe just not solely determined by it. This is because more bytes are required to represent the row and column coordinates the larger the universe is. In a 1,000 \u00d7 1,000 universe most coordinates will be 3 digit numbers, e.g. (148, 763) so most lines will be 8 bytes long and the formula will become 8 n + 8 bytes). How does this compare with the first two options? For this specific example it uses 24 bytes. As long as the universe is sparse it will be more efficient, but for a crowded universe it will be less efficient. We can calculate the point at which it ceases to become more efficient by finding the number of live cells at which the storage for the two schemes is equal. Assuming a 1,000 \u00d7 1,000 universe, Option 1 will require 2,001,000 bytes, Option 2 will require 1,001,000 bytes, and Option 3's requirements will vary with the number of live cells: % live cells Storage in bytes 0 8 5 400,008 10 800,008 15 1,200,008 20 1,600,008 25 2,000,008 You can see that for this size of universe the break even point is around 12.5% live cells. Option 4 There are numerous other options, but one that often occurs to students is that since cells are either dead or alive their state could be stored using a single bit rather than an entire byte. This would reduce the storage requirements by a factor of 8 in the first two options. It is indeed possible to do this helped along by Python's binary operators which allow us to manipulate the bits inside bytes, but these are not a focus of the course so we will just nod at this possibility as we move on by. (There are also fussy end conditions to deal with when the universe is not a multiple of 8 in size because then our information does not exactly fill bytes). Why no code? Because it's part of the assignment! \ud83e\udee3","title":"Designing file formats"},{"location":"08_Persistence/10_Designing_file_formats/#designing-file-formats","text":"In the previous example we stored our coordinates \"one pair to a line separated by white space\". That description specifies a file format. Of course it's not the only file format possible. We could have put all the data onto one line, or separated items with commas instead of spaces, or... The limits to what we could design are just the limits of our ingenuity. The differences of one versus many lines, and commas versus spaces are just cosmetic, but sometimes quite different approaches can be taken to storing some data. One accessible problem that affords different alternatives is the problem of storing the state of the universe in Conway's Game of Life. You can read about this \"game\" on Wikipedia and play it online here (among many others). The universe in Conway's game of life is a grid of cells each of which can be in one of two states: alive or dead. A natural way to represent it in Python would be as a list of lists of cells (like a very large tic-tac-toe board): universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ]","title":"Designing file formats"},{"location":"08_Persistence/10_Designing_file_formats/#option-1","text":"One way to write this to a text file would be to write lines of space-separated 0s and 1s to the file: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 The size of this file would be 136 bytes because we have one byte for the 0 or 1 for each cell, 1 byte for the space to separate them, and 1 byte for the line end marking the end of each row of the universe, i.e. 1 \u00d7 8 \u00d7 8 + 1 \u00d7 8 \u00d7 8 + 1 \u00d7 8 = 136 bytes. Generalizing this, an n \u00d7 n universe would require 2 n 2 + n bytes.","title":"Option 1"},{"location":"08_Persistence/10_Designing_file_formats/#option-2","text":"Using text graphics the universe might be displayed onscreen using blanks to represent dead cells and asterisks to represent live cells like this: * * *** This suggests a second approach: we could save the state of the universe by taking a \"snapshot\" of it and writing that snapshot to the file. Our file would look just like the universe, and would use somewhat less storage because this time we use one byte (to store either a blank character or an asterisk character) for each cell, and one byte for the newline at the end of each row. Thus for an n \u00d7 n universe we would require n 2 + n bytes or roughly half as much storage (for medium and large values of n ). For our 8 \u00d7 8 universe this approach uses 72 bytes.","title":"Option 2"},{"location":"08_Persistence/10_Designing_file_formats/#option-3","text":"You will have noticed when playing the online games of life (you did play them didn't you?) that the universe is usually \"sparse\", that is there are usually relatively few live cells among a great many dead ones. This is a consequence of Conway's rules: cells die easily of overcrowding, so if an area becomes densely populated the cells in it quickly die off keeping overall densities low. This suggests that we may be wasting space storing all those dead cells. Instead we should just store the locations of live cells. Our file format for the universe above would then be: 8 8 2 3 3 4 4 2 4 3 4 4 where each row after the first one records the location of one live cell in row col form, i.e. the first number gives the row of the cell and the second gives its column. What about the 8s in the first row? With this representation the file does not directly convey the size of the universe as it did in the first two options so we must explicitly state the size of the universe; it's the job of the first line of data to give the height and width of the universe. The storage requirement of this option depends not on the size of the universe, but on the number of live cells in it. For a universe less than 11 \u00d7 11 in size it uses 4 bytes per live cell (1 for row, 1 for separating space, 1 for col and 1 for line end), plus another 4 for the universe size. Generalizing: 4 n + 4 bytes where n gives the number of live cells. (Note that the memory storage is affected by the size of the universe just not solely determined by it. This is because more bytes are required to represent the row and column coordinates the larger the universe is. In a 1,000 \u00d7 1,000 universe most coordinates will be 3 digit numbers, e.g. (148, 763) so most lines will be 8 bytes long and the formula will become 8 n + 8 bytes). How does this compare with the first two options? For this specific example it uses 24 bytes. As long as the universe is sparse it will be more efficient, but for a crowded universe it will be less efficient. We can calculate the point at which it ceases to become more efficient by finding the number of live cells at which the storage for the two schemes is equal. Assuming a 1,000 \u00d7 1,000 universe, Option 1 will require 2,001,000 bytes, Option 2 will require 1,001,000 bytes, and Option 3's requirements will vary with the number of live cells: % live cells Storage in bytes 0 8 5 400,008 10 800,008 15 1,200,008 20 1,600,008 25 2,000,008 You can see that for this size of universe the break even point is around 12.5% live cells.","title":"Option 3"},{"location":"08_Persistence/10_Designing_file_formats/#option-4","text":"There are numerous other options, but one that often occurs to students is that since cells are either dead or alive their state could be stored using a single bit rather than an entire byte. This would reduce the storage requirements by a factor of 8 in the first two options. It is indeed possible to do this helped along by Python's binary operators which allow us to manipulate the bits inside bytes, but these are not a focus of the course so we will just nod at this possibility as we move on by. (There are also fussy end conditions to deal with when the universe is not a multiple of 8 in size because then our information does not exactly fill bytes).","title":"Option 4"},{"location":"08_Persistence/10_Designing_file_formats/#why-no-code","text":"Because it's part of the assignment! \ud83e\udee3","title":"Why no code?"},{"location":"08_Persistence/11_Pickling/","text":"Pickling Recall this bit of code from writing coordinates to a file, for coord in coords: f.write(str(coord[0])+' '+str(coord[1])+'\\n') It's straightforward enough, but it feels like busywork converting numbers to strings and bundling the strings together into lines. In fact it feels like such straightforward busywork that our intuitions suggest it could be automated, and in fact Python provides a module that automatically converts its built-in types to strings that can be stored in text files. The module is whimsically called pickle (because it preserves the objects the way pickling preserves foods). Its use is straightforward: # life.py universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] import pickle f = open( 'pickled_universe.txt', 'wb') # we use wb to indicate we are writing bytes pickle.dump(universe, f) f.close() f = open('pickled_universe.txt', 'rb') # we use rb to indicate we are reading bytes u = pickle.load(f) f.close() print(u) Output: >>> [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] >>> Almost any Python object can be pickled (among the exceptions are odd ducks like sockets for network connections and file handles). Given how compact it is why would we not just always use it? The answer is that we will often use it, but not without thinking first. One reason we will sometimes avoid it is that the pickled representation is neither particularly compact nor particularly readable. pickled_universe.txt above looks like this, (lp0 (lp1 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp2 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp3 I0 aI0 aI0 aI1 ... and is 383 bytes in size. That makes it 2 to 3 times as large as our hand-rolled solutions in Options 1 and 2. A more subtle reason is that it can be inefficient for some data types. One common situation is to want to store a dictionary of objects to disk. The dictionary can be pickled, but then to access any individual element of the dictionary the entire dictionary must be read into memory and unpickled before the element can be accessed. If the dictionary is large this can represent a significant amount of processing time and memory. Because this use case is so common Python provides the shelve module in its standard library. A shelve is like a dictionary that is stored on disk.","title":"Pickling"},{"location":"08_Persistence/11_Pickling/#pickling","text":"Recall this bit of code from writing coordinates to a file, for coord in coords: f.write(str(coord[0])+' '+str(coord[1])+'\\n') It's straightforward enough, but it feels like busywork converting numbers to strings and bundling the strings together into lines. In fact it feels like such straightforward busywork that our intuitions suggest it could be automated, and in fact Python provides a module that automatically converts its built-in types to strings that can be stored in text files. The module is whimsically called pickle (because it preserves the objects the way pickling preserves foods). Its use is straightforward: # life.py universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] import pickle f = open( 'pickled_universe.txt', 'wb') # we use wb to indicate we are writing bytes pickle.dump(universe, f) f.close() f = open('pickled_universe.txt', 'rb') # we use rb to indicate we are reading bytes u = pickle.load(f) f.close() print(u) Output: >>> [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] >>> Almost any Python object can be pickled (among the exceptions are odd ducks like sockets for network connections and file handles). Given how compact it is why would we not just always use it? The answer is that we will often use it, but not without thinking first. One reason we will sometimes avoid it is that the pickled representation is neither particularly compact nor particularly readable. pickled_universe.txt above looks like this, (lp0 (lp1 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp2 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp3 I0 aI0 aI0 aI1 ... and is 383 bytes in size. That makes it 2 to 3 times as large as our hand-rolled solutions in Options 1 and 2. A more subtle reason is that it can be inefficient for some data types. One common situation is to want to store a dictionary of objects to disk. The dictionary can be pickled, but then to access any individual element of the dictionary the entire dictionary must be read into memory and unpickled before the element can be accessed. If the dictionary is large this can represent a significant amount of processing time and memory. Because this use case is so common Python provides the shelve module in its standard library. A shelve is like a dictionary that is stored on disk.","title":"Pickling"},{"location":"08_Persistence/12_Shelves/","text":"Shelves A shelve ( Official documentation ) is like a dictionary that is stored on disk. (The name continues the canning theme begun with pickle ). The dictionary values can be any object that can be pickled. Retrieval is fast because the dictionary keys are hashed for fast retrieval. Here is an example that stores quotations into a shelve on disk. The comments should make it self-explanatory. # shelve_test.py import shelve # First here are a couple of quotes to work with. b = ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] k = ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] # Now let's create an in-RAM dictionary with the quotes in it. quotes = {} # Add the quotes to the dictionary keyed by last name. quotes['Kernighan'] = k quotes['Beck'] = b # Now let's display what we have: print('Here\\'s the dictionary:') print(quotes) print() print('Here it is again by looping through it:') for person in quotes.keys(): print(quotes[person]) print() # Now let's create a shelve and put the quotes in it. # Like a file we open it, but unlike with a file # opening a shelve is non-destructive so you can reopen it as often # as you want. quotefile = shelve.open('quotes') # Notice how the access syntax mirrors the dictionary syntax above. quotefile['Kernighan'] = k quotefile['Beck'] = b quotefile.close() # The quotes should be stored on-disk now. # Let's reopen the shelve and display the quotes. quotefile = shelve.open('quotes') print('Here\\'s the content of the shelve:') # Notice how similar this is to working with the in-memory dictionary above. for key in quotefile: print(key, ':', quotefile[key]) quotefile.close() The example shows how to store and retrieve data with the shelve, but what about deleting a stored item? Just use del dictionary[key] or in the specific example above we could use del quotefile['Beck'] to remove the Kent Beck quote. A small gotcha Brian Kernighan is a very smart guy and has said many memorable things. What if we add a second quote by him to the shelve? Well if we use the same key, i.e. his last name Kernighan , it will replace the existing quote. What to do? One view is that last name was not a good choice for the key because it is not unique to the items being stored, i.e. two items can have the same key. Another is that it is a fine key, but the values in the dictionary should be a list of the quotes by Brian Kernighan not a single list element giving one quote, i.e. the entry should be a list of lists. In either case we probably want to be able to tell if we already have any quotes by him already and we can do that using the shelve's in method, if 'Kernighan' in quotefile: # deal with it... A bigger Gotcha: Shelves update on assignment not mutation WTH!? \" Shelves update on assignment not mutation. \" Shelves are mostly very easy to use, but there is one common gotcha to be aware of when you use them and that is that shelves update on assignment not mutation . There have I said it enough times? Now I'll explain it. The problem: Surprise! Consider the following transcript carefully, >>> s = shelve.open('test_shelve') >>> s['bob'] = 42 >>> s['liz']=[31] >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 42 liz : [31] >>> s['bob'] = 43 >>> s['liz'][0] = 30 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [31] The thing to notice here is that s['bob'] was changed (from 42 to 43 ), but that s['liz'] was not (it's still just [31] ). WTH? The reason is that s['bob'] was assigned to , but s['liz'] was only mutated , that is the contents of the list s['liz'] were changed, but s['liz'] itself still refers to the same list object. That object's contents may have changed but Python has no (easy and efficient) way of noticing that. So s['bob'] was assigned to and therefore updated but s['liz'] was only mutated and so was not updated, just like the phrase says: \"Shelves update on assignment not mutation\". How can we force s['liz'] to be updated? Solution 1 Open the shelve with the option writeback=True , >>> s = shelve.open('test_shelve', writeback=True) >>> s['liz'][0] = 1 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [1] But listen to the official documentation: If the optional writeback parameter is set to True, all entries accessed are cached in memory, and written back at close time; this can make it handier to mutate mutable entries in the persistent dictionary, but, if many entries are accessed, it can consume vast amounts of memory for the cache, and it can make the close operation very slow since all accessed entries are written back (there is no way to determine which accessed entries are mutable, nor which ones were actually mutated). * Solution 2 Mutate the object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. In other words use a temporary name to force an assignment to the keyed name happen: >>> s = shelve.open('test_shelve') >>> tmp = s['liz'] >>> tmp[0] = 2 >>> s['liz'] = tmp >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [2] Summary Fact : Shelves update on assignment, not mutation . Implication : This means that changes to shelve members that contain mutable types, e.g. lists and dictionaries, are not automatically updated to disk. Solution 1 : Open the shelve with the option writeback set to True . Drawback : If the shelve is open for long a large number of cached shelve objects will accumulate and need to be written to the shelve file when it is closed. Solution 2 : Mutate the shelve object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. Drawback : It takes some care to do this consistently. Conclusion: Use Solution 2.","title":"Shelves"},{"location":"08_Persistence/12_Shelves/#shelves","text":"A shelve ( Official documentation ) is like a dictionary that is stored on disk. (The name continues the canning theme begun with pickle ). The dictionary values can be any object that can be pickled. Retrieval is fast because the dictionary keys are hashed for fast retrieval. Here is an example that stores quotations into a shelve on disk. The comments should make it self-explanatory. # shelve_test.py import shelve # First here are a couple of quotes to work with. b = ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] k = ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] # Now let's create an in-RAM dictionary with the quotes in it. quotes = {} # Add the quotes to the dictionary keyed by last name. quotes['Kernighan'] = k quotes['Beck'] = b # Now let's display what we have: print('Here\\'s the dictionary:') print(quotes) print() print('Here it is again by looping through it:') for person in quotes.keys(): print(quotes[person]) print() # Now let's create a shelve and put the quotes in it. # Like a file we open it, but unlike with a file # opening a shelve is non-destructive so you can reopen it as often # as you want. quotefile = shelve.open('quotes') # Notice how the access syntax mirrors the dictionary syntax above. quotefile['Kernighan'] = k quotefile['Beck'] = b quotefile.close() # The quotes should be stored on-disk now. # Let's reopen the shelve and display the quotes. quotefile = shelve.open('quotes') print('Here\\'s the content of the shelve:') # Notice how similar this is to working with the in-memory dictionary above. for key in quotefile: print(key, ':', quotefile[key]) quotefile.close() The example shows how to store and retrieve data with the shelve, but what about deleting a stored item? Just use del dictionary[key] or in the specific example above we could use del quotefile['Beck'] to remove the Kent Beck quote.","title":"Shelves"},{"location":"08_Persistence/12_Shelves/#a-small-gotcha","text":"Brian Kernighan is a very smart guy and has said many memorable things. What if we add a second quote by him to the shelve? Well if we use the same key, i.e. his last name Kernighan , it will replace the existing quote. What to do? One view is that last name was not a good choice for the key because it is not unique to the items being stored, i.e. two items can have the same key. Another is that it is a fine key, but the values in the dictionary should be a list of the quotes by Brian Kernighan not a single list element giving one quote, i.e. the entry should be a list of lists. In either case we probably want to be able to tell if we already have any quotes by him already and we can do that using the shelve's in method, if 'Kernighan' in quotefile: # deal with it...","title":"A small gotcha"},{"location":"08_Persistence/12_Shelves/#a-bigger-gotcha-shelves-update-on-assignment-not-mutation","text":"WTH!? \" Shelves update on assignment not mutation. \" Shelves are mostly very easy to use, but there is one common gotcha to be aware of when you use them and that is that shelves update on assignment not mutation . There have I said it enough times? Now I'll explain it.","title":"A bigger Gotcha: Shelves update on assignment not mutation"},{"location":"08_Persistence/12_Shelves/#the-problem-surprise","text":"Consider the following transcript carefully, >>> s = shelve.open('test_shelve') >>> s['bob'] = 42 >>> s['liz']=[31] >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 42 liz : [31] >>> s['bob'] = 43 >>> s['liz'][0] = 30 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [31] The thing to notice here is that s['bob'] was changed (from 42 to 43 ), but that s['liz'] was not (it's still just [31] ). WTH? The reason is that s['bob'] was assigned to , but s['liz'] was only mutated , that is the contents of the list s['liz'] were changed, but s['liz'] itself still refers to the same list object. That object's contents may have changed but Python has no (easy and efficient) way of noticing that. So s['bob'] was assigned to and therefore updated but s['liz'] was only mutated and so was not updated, just like the phrase says: \"Shelves update on assignment not mutation\". How can we force s['liz'] to be updated?","title":"The problem: Surprise!"},{"location":"08_Persistence/12_Shelves/#solution-1","text":"Open the shelve with the option writeback=True , >>> s = shelve.open('test_shelve', writeback=True) >>> s['liz'][0] = 1 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [1] But listen to the official documentation: If the optional writeback parameter is set to True, all entries accessed are cached in memory, and written back at close time; this can make it handier to mutate mutable entries in the persistent dictionary, but, if many entries are accessed, it can consume vast amounts of memory for the cache, and it can make the close operation very slow since all accessed entries are written back (there is no way to determine which accessed entries are mutable, nor which ones were actually mutated). *","title":"Solution 1"},{"location":"08_Persistence/12_Shelves/#solution-2","text":"Mutate the object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. In other words use a temporary name to force an assignment to the keyed name happen: >>> s = shelve.open('test_shelve') >>> tmp = s['liz'] >>> tmp[0] = 2 >>> s['liz'] = tmp >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [2]","title":"Solution 2"},{"location":"08_Persistence/12_Shelves/#summary","text":"Fact : Shelves update on assignment, not mutation . Implication : This means that changes to shelve members that contain mutable types, e.g. lists and dictionaries, are not automatically updated to disk. Solution 1 : Open the shelve with the option writeback set to True . Drawback : If the shelve is open for long a large number of cached shelve objects will accumulate and need to be written to the shelve file when it is closed. Solution 2 : Mutate the shelve object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. Drawback : It takes some care to do this consistently. Conclusion: Use Solution 2.","title":"Summary"},{"location":"08_Persistence/13_A_controller_for_our_database/","text":"A controller for our database \"Wait a minute! What database?\" Is that your first thought? Because it would be a fair one if you hadn't noticed that once we have a persistent dictionary-like storage, e.g. a shelve, we have a database. And if we have a database we need some way to control it. Control what exactly? The actions that get performed on that database. Those actions are most easily recalled by remembering the acronym CRUD, C reate: We need a way to create a new entry in the database. R etrieve: We need to be able to retrieve an entry in the database. U pdate: We need a way to update an existing entry in the database. D elete: We need a way to delete an entry in the database. Those are really the only things we can do with a database, though the retrieve operation is a little slippery because it's unclear what it means. Does it refer just to accessing an entry whose key you know, or does it also include finding entries that match certain criteria? Because the latter operation, searching, is a very complicated task (basically it's the problem Google is being rewarded for \"solving\"). What we'll do here is to build a little controller 1 that will let us work on our database of quotations. The pseudocode for most controllers is similar 2 , Forever Display the possible actions Get the user's choice of action Execute the code corresponding to the chosen action The Python code for CRUD operations on a shelve of quotes could look like, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) # Forever over = False while not over: # Display the possible actions print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') # Get the user's choice of action choice = input() # Execute the code corresponding to the chosen action if choice == 'c': pass elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': pass elif choice == 'q': over = True else: print('Not a valid choice!') db.close() The code is a fairly straightforward translation of the pseudocode: The Forever loop is implemented with a quit option. The possible actions are displayed using a triple quoted string to display a menu of choices. We get the user's choice via a call to input . We choose the appropriate action using an if-elif-else cascade. The pass statements are new, but they do nothing. Truly. If they do nothing why have them? Because you can't have nothing between an if and an elif or between a pair of elif s, >>> if x > 5: elif x == 5: File \"<pyshell#59>\", line 2 elif x == 5: ^ IndentationError: expected an indented block >>> The job of a pass statement is to have a statement somewhere you don't want one by 1) being a statement, but 2) doing nothing. Most languages provide a \"do nothing\" statement. They were originally included because sometimes the structure that is otherwise the natural choice would have a blank where a statement is required. The solution: create a do nothing statement to avoid having a blank slot. They are used most commonly now during program construction as I have done above. They serve as temporary stand-ins when you are writing a program from the top-down or outside-in, i.e. from the general to the specific, because you can write the overall framework and put these dummy statements in as placeholders until you are ready to write more detailed code. Here's another version with a couple of the actions filled in, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') lastname = author[author.rfind(' ')+1:] db[lastname] = [author, text] elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') for key in db: print(key, ':', db[key]) elif choice == 'q': over = True else: print('Not a valid choice!') db.close() and a sample run, >>> What file of quotes would you like to work with? quotes Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? c Who is the author of the quote? Fred Flintstone What did they say or write? Yaba daba doo! Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Flintstone : ['Fred Flintstone', 'Yaba daba doo!'] Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? q >>> What about the other actions? Check out the assignment :-) Controllers are ubiquitous in computing. If you have a device or server you want to manipulate through software then you need a controller. \u21a9 Which may have you thinking that it should be possible to build a universal controller which with some OOP and an MVC architecture it pretty much is. OOP will be the subject of the remaining four modules of this course. MVC you can either Google or wait to study in CPSC 129. \u21a9","title":"A controller for our database"},{"location":"08_Persistence/13_A_controller_for_our_database/#a-controller-for-our-database","text":"\"Wait a minute! What database?\" Is that your first thought? Because it would be a fair one if you hadn't noticed that once we have a persistent dictionary-like storage, e.g. a shelve, we have a database. And if we have a database we need some way to control it. Control what exactly? The actions that get performed on that database. Those actions are most easily recalled by remembering the acronym CRUD, C reate: We need a way to create a new entry in the database. R etrieve: We need to be able to retrieve an entry in the database. U pdate: We need a way to update an existing entry in the database. D elete: We need a way to delete an entry in the database. Those are really the only things we can do with a database, though the retrieve operation is a little slippery because it's unclear what it means. Does it refer just to accessing an entry whose key you know, or does it also include finding entries that match certain criteria? Because the latter operation, searching, is a very complicated task (basically it's the problem Google is being rewarded for \"solving\"). What we'll do here is to build a little controller 1 that will let us work on our database of quotations. The pseudocode for most controllers is similar 2 , Forever Display the possible actions Get the user's choice of action Execute the code corresponding to the chosen action The Python code for CRUD operations on a shelve of quotes could look like, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) # Forever over = False while not over: # Display the possible actions print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') # Get the user's choice of action choice = input() # Execute the code corresponding to the chosen action if choice == 'c': pass elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': pass elif choice == 'q': over = True else: print('Not a valid choice!') db.close() The code is a fairly straightforward translation of the pseudocode: The Forever loop is implemented with a quit option. The possible actions are displayed using a triple quoted string to display a menu of choices. We get the user's choice via a call to input . We choose the appropriate action using an if-elif-else cascade. The pass statements are new, but they do nothing. Truly. If they do nothing why have them? Because you can't have nothing between an if and an elif or between a pair of elif s, >>> if x > 5: elif x == 5: File \"<pyshell#59>\", line 2 elif x == 5: ^ IndentationError: expected an indented block >>> The job of a pass statement is to have a statement somewhere you don't want one by 1) being a statement, but 2) doing nothing. Most languages provide a \"do nothing\" statement. They were originally included because sometimes the structure that is otherwise the natural choice would have a blank where a statement is required. The solution: create a do nothing statement to avoid having a blank slot. They are used most commonly now during program construction as I have done above. They serve as temporary stand-ins when you are writing a program from the top-down or outside-in, i.e. from the general to the specific, because you can write the overall framework and put these dummy statements in as placeholders until you are ready to write more detailed code. Here's another version with a couple of the actions filled in, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') lastname = author[author.rfind(' ')+1:] db[lastname] = [author, text] elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') for key in db: print(key, ':', db[key]) elif choice == 'q': over = True else: print('Not a valid choice!') db.close() and a sample run, >>> What file of quotes would you like to work with? quotes Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? c Who is the author of the quote? Fred Flintstone What did they say or write? Yaba daba doo! Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Flintstone : ['Fred Flintstone', 'Yaba daba doo!'] Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? q >>> What about the other actions? Check out the assignment :-) Controllers are ubiquitous in computing. If you have a device or server you want to manipulate through software then you need a controller. \u21a9 Which may have you thinking that it should be possible to build a universal controller which with some OOP and an MVC architecture it pretty much is. OOP will be the subject of the remaining four modules of this course. MVC you can either Google or wait to study in CPSC 129. \u21a9","title":"A controller for our database"},{"location":"08_Persistence/14_The_main_event_loop/","text":"The main event loop You've already seen it. Go back to the previous page and look at the controller code. See the main loop that awaits an event from the user to trigger each action? That's a main event loop . It's the most common pattern for interactive (as opposed to batch) programs. They wait for each event or user action, e.g. a keypress or a mouse movement, and then trigger an action based on it. Most office productivity programs (word processors, spreadsheets, etc.) spend almost all of their time waiting for the user to do something and then just follow a clear set of rules to determine what routine to fire as a result. \"The main event loop\" is just jargon, not a deep idea, but it's jargon you should know, and even use, e.g. in interviews.","title":"The main event loop"},{"location":"08_Persistence/14_The_main_event_loop/#the-main-event-loop","text":"You've already seen it. Go back to the previous page and look at the controller code. See the main loop that awaits an event from the user to trigger each action? That's a main event loop . It's the most common pattern for interactive (as opposed to batch) programs. They wait for each event or user action, e.g. a keypress or a mouse movement, and then trigger an action based on it. Most office productivity programs (word processors, spreadsheets, etc.) spend almost all of their time waiting for the user to do something and then just follow a clear set of rules to determine what routine to fire as a result. \"The main event loop\" is just jargon, not a deep idea, but it's jargon you should know, and even use, e.g. in interviews.","title":"The main event loop"},{"location":"08_Persistence/90_Assignment_8/","text":"Assignment 8 Problems Text file practice Write a module containing three functions. When run, the module should prompt the user for a filename and a number of lines (let's refer to it as n ) and then call each function in turn with these parameters. a. The function head should return a list containing the first n lines of the file. b. The function tail should return a list containing the last n lines of the file. c. The function longest should return a list containing the longest n lines of the file. The output of running the module might look like this: Name of file to test with: pooh.txt Number of lines to display: 3 head says the first 3 lines are: The more it snows (Tiddely pom), The more it goes tail says the last 3 lines are: How cold my toes (Tiddely pom), Are growing. longest says the longest 3 lines are: The more it snows The more it goes And nobody knows Since the file could be very long you will not want to read the whole thing into memory as a list of lines... Here is a short file to test with pooh.txt Testing biggest() The last few assignments have provided you with examples of testing harnesses to ensure programs are working correctly. Now it is time for you to design some tests of your own. The file a8_2.py contains six versions of a function named biggest that all claim to return the largest of three values they are passed. Add test cases to the program to determine which ones (if any) work correctly. Based on your test cases identify the situations (if any) in which each version fails, and the reason for the failure, i.e. what the problem is with the code. Enter your answers into the docstrings for each function. CRUD Control Complete the program crud_controller.py , i.e. insert code for the remaining functions, and make sure adding new quotes can't delete existing ones. Rename it a8p3name.py. Super hero name generator Write a function called superhero_name_generator that is passed a string containing someone's full name, e.g. 'Timothy Nicholas Topper' , and returns their superhero name according to the chart below, e.g. my superhero name is Outlandish Psychic Tornado. I've included a tab delimited file with the name mapping, superhero_name_generator.txt . Put your function in a module with an if __name__ == '__main__': section that tests it. Logistics Use the following naming scheme for your program files: a assignment# p problem#yourname .py . So your solution to problem 1 on this assignment will be named a8p1bob.py and your solution for problem 2 will be named a8p2bob.py (adjusted obviously to use your name). Please submit all your .py files to the Moodle dropbox.","title":"Assignment 8"},{"location":"08_Persistence/90_Assignment_8/#assignment-8","text":"","title":"Assignment 8"},{"location":"08_Persistence/90_Assignment_8/#problems","text":"","title":"Problems"},{"location":"08_Persistence/90_Assignment_8/#text-file-practice","text":"Write a module containing three functions. When run, the module should prompt the user for a filename and a number of lines (let's refer to it as n ) and then call each function in turn with these parameters. a. The function head should return a list containing the first n lines of the file. b. The function tail should return a list containing the last n lines of the file. c. The function longest should return a list containing the longest n lines of the file. The output of running the module might look like this: Name of file to test with: pooh.txt Number of lines to display: 3 head says the first 3 lines are: The more it snows (Tiddely pom), The more it goes tail says the last 3 lines are: How cold my toes (Tiddely pom), Are growing. longest says the longest 3 lines are: The more it snows The more it goes And nobody knows Since the file could be very long you will not want to read the whole thing into memory as a list of lines... Here is a short file to test with pooh.txt","title":"Text file practice"},{"location":"08_Persistence/90_Assignment_8/#testing-biggest","text":"The last few assignments have provided you with examples of testing harnesses to ensure programs are working correctly. Now it is time for you to design some tests of your own. The file a8_2.py contains six versions of a function named biggest that all claim to return the largest of three values they are passed. Add test cases to the program to determine which ones (if any) work correctly. Based on your test cases identify the situations (if any) in which each version fails, and the reason for the failure, i.e. what the problem is with the code. Enter your answers into the docstrings for each function.","title":"Testing biggest()"},{"location":"08_Persistence/90_Assignment_8/#crud-control","text":"Complete the program crud_controller.py , i.e. insert code for the remaining functions, and make sure adding new quotes can't delete existing ones. Rename it a8p3name.py.","title":"CRUD Control"},{"location":"08_Persistence/90_Assignment_8/#super-hero-name-generator","text":"Write a function called superhero_name_generator that is passed a string containing someone's full name, e.g. 'Timothy Nicholas Topper' , and returns their superhero name according to the chart below, e.g. my superhero name is Outlandish Psychic Tornado. I've included a tab delimited file with the name mapping, superhero_name_generator.txt . Put your function in a module with an if __name__ == '__main__': section that tests it.","title":"Super hero name generator"},{"location":"08_Persistence/90_Assignment_8/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem#yourname .py . So your solution to problem 1 on this assignment will be named a8p1bob.py and your solution for problem 2 will be named a8p2bob.py (adjusted obviously to use your name). Please submit all your .py files to the Moodle dropbox.","title":"Logistics"},{"location":"09_OOP1_Encapsulation/","text":"Introduction: Object-oriented programming \ud83c\udf81 Welcome to the home stretch of the course. You're two thirds of the way through, and the final module is a light one, so there are only three more modules of substantive content left! These modules cover Object-Oriented Programming or OOP. Don't worry, it's not something brand new and different, just a way of packaging the algorithms and data structures you've been working with into larger chunks called objects . This makes them even easier to reuse and to connect together into larger programs. There is some new notation and jargon, so to help you concentrate on that we'll revisit a programming domain we've already seen, playing cards, and repackage our techniques and data structures for dealing with them into classes and objects. We'll develop a set of playing card classes in this module. Be sure to follow that development carefully, since three of your four assignment problems involve it. (Next week we'll consider a new problem domain that has been students' favourite assignment over the years, the world of the original text adventure game \"Hunt the Wumpus\".) Object-Oriented Programming Encapsulation Inheritance Polymorphism The plan for the next three modules A small example: A dice class Python OOP Syntax Playing Card Classes: The Specification Identifying the necessary classes Identifying the classes' methods Program skeleton 1 An invisible method! (A polymorphic aside) Program Skeleton 2 An invisible class too! Deck methods Hand methods Card Methods Putting all the pieces together Running the whole thing Programming Observation 1. Assignment 9","title":"Introduction: Object-oriented programming \ud83c\udf81"},{"location":"09_OOP1_Encapsulation/#introduction-object-oriented-programming","text":"Welcome to the home stretch of the course. You're two thirds of the way through, and the final module is a light one, so there are only three more modules of substantive content left! These modules cover Object-Oriented Programming or OOP. Don't worry, it's not something brand new and different, just a way of packaging the algorithms and data structures you've been working with into larger chunks called objects . This makes them even easier to reuse and to connect together into larger programs. There is some new notation and jargon, so to help you concentrate on that we'll revisit a programming domain we've already seen, playing cards, and repackage our techniques and data structures for dealing with them into classes and objects. We'll develop a set of playing card classes in this module. Be sure to follow that development carefully, since three of your four assignment problems involve it. (Next week we'll consider a new problem domain that has been students' favourite assignment over the years, the world of the original text adventure game \"Hunt the Wumpus\".) Object-Oriented Programming Encapsulation Inheritance Polymorphism The plan for the next three modules A small example: A dice class Python OOP Syntax Playing Card Classes: The Specification Identifying the necessary classes Identifying the classes' methods Program skeleton 1 An invisible method! (A polymorphic aside) Program Skeleton 2 An invisible class too! Deck methods Hand methods Card Methods Putting all the pieces together Running the whole thing Programming Observation 1. Assignment 9","title":"Introduction: Object-oriented programming \ud83c\udf81"},{"location":"09_OOP1_Encapsulation/01_Object_oriented_programming/","text":"Object-Oriented Programming So far we have been doing procedural, object-based programming . In procedural programming the programmer specifies the procedure to follow to solve a problem. As you have discovered, this procedure consists of a series of step-by-step instructions and must be specified quite precisely. Although some large programs are procedural, e.g. the Linux kernel and the Apache web server, the larger they become the more difficult they are to compose. Large procedural programs tend to become fragile, and it can be difficult to reuse the code in them. Our programming became object-based when our procedures began to operate on objects. Object operations came with their own jargon of objects, methods and messages. For example when we write a_list.append('Tom') we are invoking the append method of the list object a_list . We might also say we are sending the object a_list the message append . Objects package data (e.g. the data inside a_list above) and the code to operate on it (e.g. the append method) together into convenient units that are easy to use, and to reuse . In Object-oriented programming (OOP) we go beyond using pre-existing classes and learn how to create new classes of our own. This gives us the ability to extend the basic types Python provides. Wish Python provided dice and playing_cards in addition to numbers and strings? Just add them to the language by defining new classes for each. Along with this ability comes a new perspective on program building. Rather than focussing on the procedural specification of what has to be done, OOP views the execution of a program as an interaction between objects that send messages to each other. In response to these messages the objects carry out (internal) processing and retain state (store results). The emphasis in object-oriented programming is on the design and coding of these objects. OOP comes with even more impressive jargon than object-based programming. The three key aspects of OOP are encapsulation , inheritance , and polymorphism . The ideas are not as difficult as their forbidding names suggest and this module and the next two are essentially long explanations with examples of these three concepts. To get started though, here are brief explanations of these concepts to introduce them to you and give you a general idea of what they are about.","title":"Object-Oriented Programming"},{"location":"09_OOP1_Encapsulation/01_Object_oriented_programming/#object-oriented-programming","text":"So far we have been doing procedural, object-based programming . In procedural programming the programmer specifies the procedure to follow to solve a problem. As you have discovered, this procedure consists of a series of step-by-step instructions and must be specified quite precisely. Although some large programs are procedural, e.g. the Linux kernel and the Apache web server, the larger they become the more difficult they are to compose. Large procedural programs tend to become fragile, and it can be difficult to reuse the code in them. Our programming became object-based when our procedures began to operate on objects. Object operations came with their own jargon of objects, methods and messages. For example when we write a_list.append('Tom') we are invoking the append method of the list object a_list . We might also say we are sending the object a_list the message append . Objects package data (e.g. the data inside a_list above) and the code to operate on it (e.g. the append method) together into convenient units that are easy to use, and to reuse . In Object-oriented programming (OOP) we go beyond using pre-existing classes and learn how to create new classes of our own. This gives us the ability to extend the basic types Python provides. Wish Python provided dice and playing_cards in addition to numbers and strings? Just add them to the language by defining new classes for each. Along with this ability comes a new perspective on program building. Rather than focussing on the procedural specification of what has to be done, OOP views the execution of a program as an interaction between objects that send messages to each other. In response to these messages the objects carry out (internal) processing and retain state (store results). The emphasis in object-oriented programming is on the design and coding of these objects. OOP comes with even more impressive jargon than object-based programming. The three key aspects of OOP are encapsulation , inheritance , and polymorphism . The ideas are not as difficult as their forbidding names suggest and this module and the next two are essentially long explanations with examples of these three concepts. To get started though, here are brief explanations of these concepts to introduce them to you and give you a general idea of what they are about.","title":"Object-Oriented Programming"},{"location":"09_OOP1_Encapsulation/02_Encapsulation/","text":"Encapsulation The first benefit of OOP is that it allows for encapsulation . This just means that an object encapsulates (or hides) how it operates from the code that invokes it. We have benefitted, for example, by being able to use Python's lists and dictionaries without having to worry about how they are implemented internally. That's because they abstract the behaviour to encapsulate their functionality and hide the implementation details from us. Encapsulation is necessary in OOP so objects can interact with each other without needing to know the details of how each other operates. In fact complete encapsulation allows for an object type to be rewritten and dropped into a working program without any of the other program components needing to be aware of the change. This is not as magical as it might sound. If the next version of Python changes the internal storage of dictionaries we will never know as long as it behaves the same as the current implementation and our programs keep working. As programmers got used to this their attention was drawn to the importance of object interfaces, since as long as the interface, or behaviour, is maintained, the implementation can be changed at will. Some languages, including Python, have features or practices that allow class interfaces to be formally specified. The programmer's focus then is on \"programming to the interface\".","title":"Encapsulation"},{"location":"09_OOP1_Encapsulation/02_Encapsulation/#encapsulation","text":"The first benefit of OOP is that it allows for encapsulation . This just means that an object encapsulates (or hides) how it operates from the code that invokes it. We have benefitted, for example, by being able to use Python's lists and dictionaries without having to worry about how they are implemented internally. That's because they abstract the behaviour to encapsulate their functionality and hide the implementation details from us. Encapsulation is necessary in OOP so objects can interact with each other without needing to know the details of how each other operates. In fact complete encapsulation allows for an object type to be rewritten and dropped into a working program without any of the other program components needing to be aware of the change. This is not as magical as it might sound. If the next version of Python changes the internal storage of dictionaries we will never know as long as it behaves the same as the current implementation and our programs keep working. As programmers got used to this their attention was drawn to the importance of object interfaces, since as long as the interface, or behaviour, is maintained, the implementation can be changed at will. Some languages, including Python, have features or practices that allow class interfaces to be formally specified. The programmer's focus then is on \"programming to the interface\".","title":"Encapsulation"},{"location":"09_OOP1_Encapsulation/03_Inheritance/","text":"Inheritance Experience creating objects soon showed programmers that many objects shared features, e.g. several might have text blocks, or creation dates, or screen positions, and they realized that they could further reduce the amount of new code they had to write if they could reuse existing code by having one type of object inherit behaviour and properties from another. Then if the ancestor's behaviour or properties were updated the descendant would instantly inherit the improvements. This can lead to large hierarchies of object types; some define thousands of object types. To give you a flavour of a type hierarchy here is a medium-sized inheritance hierarchy for a Python-based internet application development platform: Inheritance hierarchies are easiest to read bottom up. For example, if we begin at the lower right the chart above tells us that a FlexTable is a kind of HTMLTable which is in turn a kind of Panel which is a kind of Widget which is a kind of UIObject . What this means is that if we improve our code for UIObject s, then Widget s and Panel s will instantly and transparently inherit these improvements as well without us having to modify their code at all.","title":"Inheritance"},{"location":"09_OOP1_Encapsulation/03_Inheritance/#inheritance","text":"Experience creating objects soon showed programmers that many objects shared features, e.g. several might have text blocks, or creation dates, or screen positions, and they realized that they could further reduce the amount of new code they had to write if they could reuse existing code by having one type of object inherit behaviour and properties from another. Then if the ancestor's behaviour or properties were updated the descendant would instantly inherit the improvements. This can lead to large hierarchies of object types; some define thousands of object types. To give you a flavour of a type hierarchy here is a medium-sized inheritance hierarchy for a Python-based internet application development platform: Inheritance hierarchies are easiest to read bottom up. For example, if we begin at the lower right the chart above tells us that a FlexTable is a kind of HTMLTable which is in turn a kind of Panel which is a kind of Widget which is a kind of UIObject . What this means is that if we improve our code for UIObject s, then Widget s and Panel s will instantly and transparently inherit these improvements as well without us having to modify their code at all.","title":"Inheritance"},{"location":"09_OOP1_Encapsulation/04_Polymorphism/","text":"Polymorphism Programmers noticed another regularity among their objects: often many of them needed to be able to respond to the same message, but by doing somewhat different things. For example we add items to a list, and to a dictionary, and to a menu, etc. In this case we want all these object types to be able to respond to an add message, i.e. to provide an add method. Of course in Python we don't always know what type of object a name refers to, list[3] could be another list, or a menu, or a string, etc. The ability to be able to say list[3].add(thing) and have the language interpreter figure out what to do is polymorphism More technically it is the ability for an operation to trigger different behaviours in different contexts. A concrete example we have seen of this is the behaviour of the + operator: it adds numbers, x = y + 5 appends strings, salutation = 'Mr.' + last_name and_extends_lists, t = [3, 7] + [6, 2] In each case the semantics of the + operator is different because the operation performed depends on the types of the objects it is working with. When fully utilized, polymorphism allows us to add new object types to the Python language. For example if we need to work a lot with invoices we can define an invoice type that can be printed, added to, subtracted from, multiplied by, iterated over etc. This ability to extend the language allows it to be customized to suit any given problem domain and has been a powerful driver for the adoption of object-oriented programming.","title":"Polymorphism"},{"location":"09_OOP1_Encapsulation/04_Polymorphism/#polymorphism","text":"Programmers noticed another regularity among their objects: often many of them needed to be able to respond to the same message, but by doing somewhat different things. For example we add items to a list, and to a dictionary, and to a menu, etc. In this case we want all these object types to be able to respond to an add message, i.e. to provide an add method. Of course in Python we don't always know what type of object a name refers to, list[3] could be another list, or a menu, or a string, etc. The ability to be able to say list[3].add(thing) and have the language interpreter figure out what to do is polymorphism More technically it is the ability for an operation to trigger different behaviours in different contexts. A concrete example we have seen of this is the behaviour of the + operator: it adds numbers, x = y + 5 appends strings, salutation = 'Mr.' + last_name and_extends_lists, t = [3, 7] + [6, 2] In each case the semantics of the + operator is different because the operation performed depends on the types of the objects it is working with. When fully utilized, polymorphism allows us to add new object types to the Python language. For example if we need to work a lot with invoices we can define an invoice type that can be printed, added to, subtracted from, multiplied by, iterated over etc. This ability to extend the language allows it to be customized to suit any given problem domain and has been a powerful driver for the adoption of object-oriented programming.","title":"Polymorphism"},{"location":"09_OOP1_Encapsulation/05_The_plan_for_the_next_three_modules/","text":"The plan for the next three modules The three characteristics of OOP fit closely together, but encapsulation is the most common in day-to-day programming and so is the focus of this unit and the next one. Inheritance and polymorphism both involve fussier, more detailed, syntax and are less commonly encountered, so I have delayed a thorough examination of them until Module 11. Each module is built around a main example: Module 9: Playing cards Module 10: Hunt the Wumpus Module 11: Rational Numbers (Fractions)","title":"The plan for the next three modules"},{"location":"09_OOP1_Encapsulation/05_The_plan_for_the_next_three_modules/#the-plan-for-the-next-three-modules","text":"The three characteristics of OOP fit closely together, but encapsulation is the most common in day-to-day programming and so is the focus of this unit and the next one. Inheritance and polymorphism both involve fussier, more detailed, syntax and are less commonly encountered, so I have delayed a thorough examination of them until Module 11. Each module is built around a main example: Module 9: Playing cards Module 10: Hunt the Wumpus Module 11: Rational Numbers (Fractions)","title":"The plan for the next three modules"},{"location":"09_OOP1_Encapsulation/06_A_small_example_A_dice_class/","text":"A small example: A dice class Before considering an extended example let's consider a small one to see what the syntactical elements are that support OOP in Python. In Python as in most OOP languages (including C++ and Java\u2014but_not_Javascript) the key OOP construct is the class. A class specifies the characteristics of an object type and provides a rubber stamp or template for creating objects of a particular type. Consider for example a die (as in one dice, not death!). A die is quite a simple object. It has a single attribute, its number of sides, and just one method, roll , i.e. the only message you can really send a die is to roll itself and report the result. Like I said, it's a simple object. Here is a complete import able module that defines a Die class and some code to test it (minimally). First the code alone (I have left out the docstrings to avoid obscuring the functional code): # die_class_0.py import random class Die: def __init__(self, n): self.nsides = n def roll(self): spots = random.randint(1,self.nsides) return spots if __name__ == '__main__': d1 = Die(6) red = Die(20) print('Rolling d1 ...',) result = d1.roll() print('result =', result) print('Rolling red and d1 together gets you:', d1.roll() + red.roll()) print(f'The die d1 has {d1.nsides:d} sides.') and then the code with (hopefully helpful) annotations,","title":"A small example: A dice class"},{"location":"09_OOP1_Encapsulation/06_A_small_example_A_dice_class/#a-small-example-a-dice-class","text":"Before considering an extended example let's consider a small one to see what the syntactical elements are that support OOP in Python. In Python as in most OOP languages (including C++ and Java\u2014but_not_Javascript) the key OOP construct is the class. A class specifies the characteristics of an object type and provides a rubber stamp or template for creating objects of a particular type. Consider for example a die (as in one dice, not death!). A die is quite a simple object. It has a single attribute, its number of sides, and just one method, roll , i.e. the only message you can really send a die is to roll itself and report the result. Like I said, it's a simple object. Here is a complete import able module that defines a Die class and some code to test it (minimally). First the code alone (I have left out the docstrings to avoid obscuring the functional code): # die_class_0.py import random class Die: def __init__(self, n): self.nsides = n def roll(self): spots = random.randint(1,self.nsides) return spots if __name__ == '__main__': d1 = Die(6) red = Die(20) print('Rolling d1 ...',) result = d1.roll() print('result =', result) print('Rolling red and d1 together gets you:', d1.roll() + red.roll()) print(f'The die d1 has {d1.nsides:d} sides.') and then the code with (hopefully helpful) annotations,","title":"A small example: A dice class"},{"location":"09_OOP1_Encapsulation/07_Python_OOP_syntax/","text":"Python OOP Syntax class ClassName : def __init__(self, ... ): ... def method1 (self, ... ): ... def method2 (self, ... ): ...","title":"Python OOP Syntax"},{"location":"09_OOP1_Encapsulation/07_Python_OOP_syntax/#python-oop-syntax","text":"class ClassName : def __init__(self, ... ): ... def method1 (self, ... ): ... def method2 (self, ... ): ...","title":"Python OOP Syntax"},{"location":"09_OOP1_Encapsulation/08_Playing_card_classes_The_specification/","text":"Playing Card Classes: The Specification Earlier we developed a series of functions to help write programs involving playing cards. Now we'll take the next step and make our code object-oriented. How shall we go about designing the class(es)? There are many possible answers to this question, but for a smallish domain like this one a good approach is wish fulfillment . That is, we specify the kind of code we wish we could write but can't. In this case I wish I could say things like, Get a deck of cards Shuffle the deck Display the deck Create a hand of cards for roxx Create a hand of cards for chris Deal five cards to roxx Display roxx's cards Deal five cards to chris Display chris' cards How many cards are left in the deck? If roxx has a flush congratulate him Using OOP our Python code can be almost that easy to read, d = Deck() d.shuffle() print('d after shuffling =', d) print('d has', d.cards_left(), 'cards') roxx = Hand() chris = Hand() for card in range(5): roxx.add(d.deal()) print('Your hand of', roxx.size(), 'cards contains:', roxx) chris.add(d.deal(5)) print('Your hand of', chris.size(), 'cards contains:', chris) print('There are', d.cards_left(), 'cards left in the deck.') if roxx.is_flush(): print('roxx rocks!') This code will serve as our specification. We'll know we're done when we've added sufficient code above this that it runs correctly.","title":"Playing Card Classes: The Specification"},{"location":"09_OOP1_Encapsulation/08_Playing_card_classes_The_specification/#playing-card-classes-the-specification","text":"Earlier we developed a series of functions to help write programs involving playing cards. Now we'll take the next step and make our code object-oriented. How shall we go about designing the class(es)? There are many possible answers to this question, but for a smallish domain like this one a good approach is wish fulfillment . That is, we specify the kind of code we wish we could write but can't. In this case I wish I could say things like, Get a deck of cards Shuffle the deck Display the deck Create a hand of cards for roxx Create a hand of cards for chris Deal five cards to roxx Display roxx's cards Deal five cards to chris Display chris' cards How many cards are left in the deck? If roxx has a flush congratulate him Using OOP our Python code can be almost that easy to read, d = Deck() d.shuffle() print('d after shuffling =', d) print('d has', d.cards_left(), 'cards') roxx = Hand() chris = Hand() for card in range(5): roxx.add(d.deal()) print('Your hand of', roxx.size(), 'cards contains:', roxx) chris.add(d.deal(5)) print('Your hand of', chris.size(), 'cards contains:', chris) print('There are', d.cards_left(), 'cards left in the deck.') if roxx.is_flush(): print('roxx rocks!') This code will serve as our specification. We'll know we're done when we've added sufficient code above this that it runs correctly.","title":"Playing Card Classes: The Specification"},{"location":"09_OOP1_Encapsulation/09_Identifying_the_necessary_classes/","text":"Identifying the necessary classes We can learn a lot about what code we have to write by carefully examining our specification code. First let's look for calls to constructors. The form of a constructor is that it uses a class name as a function. We've seen examples of this with Python's built-in classes, e.g. >>> num = int(43.72) >>> num 43 >>> lst = list('Tim') >>> lst ['T', 'i', 'm'] >>> Now we want to look for similar syntax in our specification code, Doing so reveals that two classes are explicitly referred to in our specification, one called Hand and another called Deck .","title":"Identifying the necessary classes"},{"location":"09_OOP1_Encapsulation/09_Identifying_the_necessary_classes/#identifying-the-necessary-classes","text":"We can learn a lot about what code we have to write by carefully examining our specification code. First let's look for calls to constructors. The form of a constructor is that it uses a class name as a function. We've seen examples of this with Python's built-in classes, e.g. >>> num = int(43.72) >>> num 43 >>> lst = list('Tim') >>> lst ['T', 'i', 'm'] >>> Now we want to look for similar syntax in our specification code, Doing so reveals that two classes are explicitly referred to in our specification, one called Hand and another called Deck .","title":"Identifying the necessary classes"},{"location":"09_OOP1_Encapsulation/10_Identifying_the_classes_methods/","text":"Identifying the classes' methods Our next step is to identify the methods these classes must provide. To do so we look for method syntax, that is we look for the pattern object . method () . Note that the parentheses are important. With them we know we are looking at a method, without them it would be an object attribute. The methods prefixed with the Deck object name d indicate that the Deck class must provide the methods shuffle , cards_left , and deal Furthermore if we look closely we can see that deal has an optional parameter that defaults to 1 based on the difference between the usages d.deal() and d.deal(5) . Similarly the methods prefixed with the names of the Hand objects roxx and chris indicate that the Hand class must provide add , size , and is_flush methods.","title":"Identifying the classes' methods"},{"location":"09_OOP1_Encapsulation/10_Identifying_the_classes_methods/#identifying-the-classes-methods","text":"Our next step is to identify the methods these classes must provide. To do so we look for method syntax, that is we look for the pattern object . method () . Note that the parentheses are important. With them we know we are looking at a method, without them it would be an object attribute. The methods prefixed with the Deck object name d indicate that the Deck class must provide the methods shuffle , cards_left , and deal Furthermore if we look closely we can see that deal has an optional parameter that defaults to 1 based on the difference between the usages d.deal() and d.deal(5) . Similarly the methods prefixed with the names of the Hand objects roxx and chris indicate that the Hand class must provide add , size , and is_flush methods.","title":"Identifying the classes' methods"},{"location":"09_OOP1_Encapsulation/11_Program_skeleton_1/","text":"Program skeleton 1 Based on the classes and methods we have identified we can add empty class and method definitions above our specification code. This is sometimes called stubbing out the methods: Notes: Note the use of the pass statement as a placeholder. Remember that the __init__ methods are required and will contain the code necessary to construct an object of each type.","title":"Program skeleton 1"},{"location":"09_OOP1_Encapsulation/11_Program_skeleton_1/#program-skeleton-1","text":"Based on the classes and methods we have identified we can add empty class and method definitions above our specification code. This is sometimes called stubbing out the methods: Notes: Note the use of the pass statement as a placeholder. Remember that the __init__ methods are required and will contain the code necessary to construct an object of each type.","title":"Program skeleton 1"},{"location":"09_OOP1_Encapsulation/12_An_invisible_method_a_polymorphic_aside/","text":"An invisible method! (A polymorphic aside) Our code in playing_cards_1.py is even runnable. Although it doesn't do much, the output is instructive: >>> d after shuffling = <__main__.Deck object at 0x000002C52FF39010> d has None cards Your hand of None cards contains: <__main__.Hand object at 0x000002C52CF18AD0> Your hand of None cards contains: <__main__.Hand object at 0x000002C52FF67950> There are None cards left in the deck. >>> One thing to note is that functions without an explicit return statement, like all of ours here, return the special value None . The more striking thing though is probably those inscrutable strings <__main__.Deck instance at 0x000002C52FF39010> and <__main__.Hand instance at 0x000002C52CF18AD0> . You can tell by where they appear that they are generated by the print statements. Since print doesn't know how to output Deck and Hand objects it tells us what it can, which is the type and memory location of the object it has been asked to print. We can help print out by providing methods that return string representations of our Deck and Hand objects. By convention these methods are called __str__ . When print is called and passed an object name it checks the object's class definition for an __str__ method and if one is defined it calls it and displays the output the method returns. If no __str__ method is found it displays all it can, i.e. the object type and location as it did above. This nicely illustrates the simple sleight of hand that lies behind polymorphism. Until now it seemed that print knew how to print everything, but in fact it knows very little and just delegates the job to each class' __str__ method while giving the impression that it is masterful.","title":"An invisible method! (A polymorphic aside)"},{"location":"09_OOP1_Encapsulation/12_An_invisible_method_a_polymorphic_aside/#an-invisible-method-a-polymorphic-aside","text":"Our code in playing_cards_1.py is even runnable. Although it doesn't do much, the output is instructive: >>> d after shuffling = <__main__.Deck object at 0x000002C52FF39010> d has None cards Your hand of None cards contains: <__main__.Hand object at 0x000002C52CF18AD0> Your hand of None cards contains: <__main__.Hand object at 0x000002C52FF67950> There are None cards left in the deck. >>> One thing to note is that functions without an explicit return statement, like all of ours here, return the special value None . The more striking thing though is probably those inscrutable strings <__main__.Deck instance at 0x000002C52FF39010> and <__main__.Hand instance at 0x000002C52CF18AD0> . You can tell by where they appear that they are generated by the print statements. Since print doesn't know how to output Deck and Hand objects it tells us what it can, which is the type and memory location of the object it has been asked to print. We can help print out by providing methods that return string representations of our Deck and Hand objects. By convention these methods are called __str__ . When print is called and passed an object name it checks the object's class definition for an __str__ method and if one is defined it calls it and displays the output the method returns. If no __str__ method is found it displays all it can, i.e. the object type and location as it did above. This nicely illustrates the simple sleight of hand that lies behind polymorphism. Until now it seemed that print knew how to print everything, but in fact it knows very little and just delegates the job to each class' __str__ method while giving the impression that it is masterful.","title":"An invisible method! (A polymorphic aside)"},{"location":"09_OOP1_Encapsulation/13_Program_skeleton_2/","text":"Program Skeleton 2 Adding in the __str__ methods gives us: which when run produces, >>> d after shuffling = d has None cards Your hand of None cards contains: Your hand of None cards contains: There are None cards left in the deck. >>> Note that we can't use pass in the __str__ methods because they are required to return a string, so instead we return a null string in each one.","title":"Program Skeleton 2"},{"location":"09_OOP1_Encapsulation/13_Program_skeleton_2/#program-skeleton-2","text":"Adding in the __str__ methods gives us: which when run produces, >>> d after shuffling = d has None cards Your hand of None cards contains: Your hand of None cards contains: There are None cards left in the deck. >>> Note that we can't use pass in the __str__ methods because they are required to return a string, so instead we return a null string in each one.","title":"Program Skeleton 2"},{"location":"09_OOP1_Encapsulation/14_An_invisible_class_too/","text":"An invisible class too! Our analysis of the classes required by our specification is sound as far as it goes, but it leaves something out. Deck and Hand are both what are called collection classes . They each collect a group of objects of another type. What then is this other type? Well decks of cards and hands of cards are both made up of cards, so our code will also require a Card class. It is not easy to tell what methods this card class will have to provide since none are explicitly visible, but we'll add an empty Card class to our module now, and add methods to it later as we discover they are necessary in working on our Deck and Hand classes:","title":"An invisible class too!"},{"location":"09_OOP1_Encapsulation/14_An_invisible_class_too/#an-invisible-class-too","text":"Our analysis of the classes required by our specification is sound as far as it goes, but it leaves something out. Deck and Hand are both what are called collection classes . They each collect a group of objects of another type. What then is this other type? Well decks of cards and hands of cards are both made up of cards, so our code will also require a Card class. It is not easy to tell what methods this card class will have to provide since none are explicitly visible, but we'll add an empty Card class to our module now, and add methods to it later as we discover they are necessary in working on our Deck and Hand classes:","title":"An invisible class too!"},{"location":"09_OOP1_Encapsulation/15_Deck_methods/","text":"Deck methods Let's begin filling in our empty class methods. A Deck is an ordered collection of cards so a list is a natural choice of container. Thus a Deck 's sole attribute will be the list of cards. When we initialize a new Deck we need to fill the list with all 52 possible Card s: Notice that to do this we begin with an empty list, then append to that list each one of 52 unique Card objects. The Card objects are created by calling the card constructor Card and passing it an id number, so now we know the Card constructor will take an argument specifying the card to create, i.e. def Card(self, num): The remaining Deck methods are straightforward reworkings of our earlier playing card functions, but now embedded into a class:","title":"Deck methods"},{"location":"09_OOP1_Encapsulation/15_Deck_methods/#deck-methods","text":"Let's begin filling in our empty class methods. A Deck is an ordered collection of cards so a list is a natural choice of container. Thus a Deck 's sole attribute will be the list of cards. When we initialize a new Deck we need to fill the list with all 52 possible Card s: Notice that to do this we begin with an empty list, then append to that list each one of 52 unique Card objects. The Card objects are created by calling the card constructor Card and passing it an id number, so now we know the Card constructor will take an argument specifying the card to create, i.e. def Card(self, num): The remaining Deck methods are straightforward reworkings of our earlier playing card functions, but now embedded into a class:","title":"Deck methods"},{"location":"09_OOP1_Encapsulation/16_Hand_methods/","text":"Hand methods The hand methods are very similar to the Deck ones,","title":"Hand methods"},{"location":"09_OOP1_Encapsulation/16_Hand_methods/#hand-methods","text":"The hand methods are very similar to the Deck ones,","title":"Hand methods"},{"location":"09_OOP1_Encapsulation/17_Card_methods/","text":"Card Methods Looking at the code for our Deck and Hand classes we can see explicit calls to the Card constructor __init__ invoked by Card(cardnum) and the __str__ method invoked via str(card) . The necessary Card class can be written as, Notes: A Card object has a single attribute: its card number. The __str__ method calls on two other Card methods to get the string representations of the card's face value and suit: face_value and suit . The lists FACE_VALUES and SUITS are class variables . All members of the class share access to them. Note that they are accessed by prefixing them with the class name, i.e. we use Card.SUITS not just SUITS .","title":"Card Methods"},{"location":"09_OOP1_Encapsulation/17_Card_methods/#card-methods","text":"Looking at the code for our Deck and Hand classes we can see explicit calls to the Card constructor __init__ invoked by Card(cardnum) and the __str__ method invoked via str(card) . The necessary Card class can be written as, Notes: A Card object has a single attribute: its card number. The __str__ method calls on two other Card methods to get the string representations of the card's face value and suit: face_value and suit . The lists FACE_VALUES and SUITS are class variables . All members of the class share access to them. Note that they are accessed by prefixing them with the class name, i.e. we use Card.SUITS not just SUITS .","title":"Card Methods"},{"location":"09_OOP1_Encapsulation/18_Putting_all_the_pieces_together/","text":"Putting all the pieces together Notes: I've added a __name__ testing if to make this an import able module. The keen-eyed among you will notice the use of the \\n newline character to control spacing.","title":"Putting all the pieces together"},{"location":"09_OOP1_Encapsulation/18_Putting_all_the_pieces_together/#putting-all-the-pieces-together","text":"Notes: I've added a __name__ testing if to make this an import able module. The keen-eyed among you will notice the use of the \\n newline character to control spacing.","title":"Putting all the pieces together"},{"location":"09_OOP1_Encapsulation/19_Running_the_whole_thing/","text":"Running the whole thing Putting all the pieces together and running the resulting module produces the output, >>> d after shuffling = 3 of Hearts, 2 of Spades, 4 of Diamonds, Q of Clubs, 7 of Diamonds, 9 of Hearts, 4 of Spades, 9 of Diamonds, A of Diamonds, A of Clubs, K of Hearts, 2 of Clubs, 5 of Hearts, K of Clubs, T of Spades, 3 of Diamonds, A of Hearts, Q of Hearts, 3 of Clubs, J of Spades, J of Diamonds, J of Hearts, 2 of Diamonds, 9 of Spades, T of Diamonds, 3 of Spades, 7 of Hearts, 8 of Clubs, 8 of Spades, 4 of Clubs, 8 of Diamonds, A of Spades, 6 of Hearts, 8 of Hearts, K of Spades, 4 of Hearts, 6 of Diamonds, Q of Spades, 6 of Spades, T of Clubs, 2 of Hearts, 7 of Clubs, 5 of Clubs, K of Diamonds, 5 of Diamonds, 6 of Clubs, J of Clubs, T of Hearts, 9 of Clubs, 5 of Spades, Q of Diamonds, 7 of Spades, d has 52 cards. Your hand of 5 cards contains: 7 of Spades, Q of Diamonds, 5 of Spades, 9 of Clubs, T of Hearts, Your hand of 5 cards contains: 5 of Clubs, K of Diamonds, 5 of Diamonds, 6 of Clubs, J of Clubs, There are 42 cards left in the deck. >>> Which is what we had hoped for when we first wrote our spec code, indicating that our module is complete.","title":"Running the whole thing"},{"location":"09_OOP1_Encapsulation/19_Running_the_whole_thing/#running-the-whole-thing","text":"Putting all the pieces together and running the resulting module produces the output, >>> d after shuffling = 3 of Hearts, 2 of Spades, 4 of Diamonds, Q of Clubs, 7 of Diamonds, 9 of Hearts, 4 of Spades, 9 of Diamonds, A of Diamonds, A of Clubs, K of Hearts, 2 of Clubs, 5 of Hearts, K of Clubs, T of Spades, 3 of Diamonds, A of Hearts, Q of Hearts, 3 of Clubs, J of Spades, J of Diamonds, J of Hearts, 2 of Diamonds, 9 of Spades, T of Diamonds, 3 of Spades, 7 of Hearts, 8 of Clubs, 8 of Spades, 4 of Clubs, 8 of Diamonds, A of Spades, 6 of Hearts, 8 of Hearts, K of Spades, 4 of Hearts, 6 of Diamonds, Q of Spades, 6 of Spades, T of Clubs, 2 of Hearts, 7 of Clubs, 5 of Clubs, K of Diamonds, 5 of Diamonds, 6 of Clubs, J of Clubs, T of Hearts, 9 of Clubs, 5 of Spades, Q of Diamonds, 7 of Spades, d has 52 cards. Your hand of 5 cards contains: 7 of Spades, Q of Diamonds, 5 of Spades, 9 of Clubs, T of Hearts, Your hand of 5 cards contains: 5 of Clubs, K of Diamonds, 5 of Diamonds, 6 of Clubs, J of Clubs, There are 42 cards left in the deck. >>> Which is what we had hoped for when we first wrote our spec code, indicating that our module is complete.","title":"Running the whole thing"},{"location":"09_OOP1_Encapsulation/20_Programming_observation/","text":"Programming Observation Note how well the technique of working from desired code use backwards to required classes worked.","title":"Programming Observation"},{"location":"09_OOP1_Encapsulation/20_Programming_observation/#programming-observation","text":"Note how well the technique of working from desired code use backwards to required classes worked.","title":"Programming Observation"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/","text":"Assignment 9 Problems A little class of your own Write a Coin class that will enable this code to run, # Your class goes here... if __name__ == '__main__': coin = Coin() print(f'Your first coin is a {coin}.') purse = [coin] print('Adding four more coins to your purse...') for i in range(4): coin = Coin(random.choice([5,10,25,100,200])) purse.append(coin) print('In your purse you now have:') for coin in purse: print('\\ta', coin) total = 0 for coin in purse: total += coin.value print('The total value of the coins in your purse is', total, 'cents.') print('Flipping your coins you get:',end=' ') for coin in purse: print(coin.flip(),end = ' ') and produce this output, >>> Your first coin is a Nickle. Adding four more coins to your purse... In your purse you now have: a Nickle a Loonie a Penny a Dime a Quarter The total value of the coins in your purse is 137 cents. Flipping your coins you get: Tails Tails Tails Heads Tails Of course due to their random selection the exact coins that end up in the purse will vary from run to run, though the first coin created in the test above should always be a Penny, i.e. the default Coin to create is a Penny. Extending a class 1 Extend the code in playing_cards_4.py so we can find out if a five-card poker hand is a flush, i.e. all cards are from the same suit. Here's the specification code to add to the end of the module, if chris.is_flush(): print 'That is a flush!' else: print 'Sorry, no flush.' Extending a class 2 Sometimes during the course of a card game we might want or need to verify that the deck is not corrupted, for example that it does not have any extra Aces in it. Extend the code in playing_cards_4.py so we can check that a deck is fair. Here's the specification code to add to the end of the module, if d.is_fair(): print 'The deck is fair.' else: print 'Uh oh, this deck is unfair.' Include the tests you used to determine that your method was working correctly in the code you submit. An alternative playing card representation Many OO programmers would look at the playing card classes developed in this module and shout, \"Wait a minute! Actual physical playing cards have two attributes, their suit and their face value. That means your Card objects should have two attributes too that match the physical attributes, not this sketchy card number thing that encodes the values of the actual attributes in an opaque way.\" And you know, they might be right. Modify the module playing_cards_4.py to use Card objects with a pair of attributes. Name the attributes suit and face_value . Hint 1 : You shouldn't change anything after the if __name__ == '__main__': statement. Remember that one of the goals of encapsulation is to be able drop in a new class implementation for an older one without having to rewrite any code that uses it. Hint 2 : You don't have to rewrite that much of the code above the if either. Think carefully about what needs to change. Logistics Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So problem 1 on this assignment will be named a9p1bob.py and your solution for problem will be named a9p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Assignment 9"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/#assignment-9","text":"","title":"Assignment 9"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/#problems","text":"","title":"Problems"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/#a-little-class-of-your-own","text":"Write a Coin class that will enable this code to run, # Your class goes here... if __name__ == '__main__': coin = Coin() print(f'Your first coin is a {coin}.') purse = [coin] print('Adding four more coins to your purse...') for i in range(4): coin = Coin(random.choice([5,10,25,100,200])) purse.append(coin) print('In your purse you now have:') for coin in purse: print('\\ta', coin) total = 0 for coin in purse: total += coin.value print('The total value of the coins in your purse is', total, 'cents.') print('Flipping your coins you get:',end=' ') for coin in purse: print(coin.flip(),end = ' ') and produce this output, >>> Your first coin is a Nickle. Adding four more coins to your purse... In your purse you now have: a Nickle a Loonie a Penny a Dime a Quarter The total value of the coins in your purse is 137 cents. Flipping your coins you get: Tails Tails Tails Heads Tails Of course due to their random selection the exact coins that end up in the purse will vary from run to run, though the first coin created in the test above should always be a Penny, i.e. the default Coin to create is a Penny.","title":"A little class of your own"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/#extending-a-class-1","text":"Extend the code in playing_cards_4.py so we can find out if a five-card poker hand is a flush, i.e. all cards are from the same suit. Here's the specification code to add to the end of the module, if chris.is_flush(): print 'That is a flush!' else: print 'Sorry, no flush.'","title":"Extending a class 1"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/#extending-a-class-2","text":"Sometimes during the course of a card game we might want or need to verify that the deck is not corrupted, for example that it does not have any extra Aces in it. Extend the code in playing_cards_4.py so we can check that a deck is fair. Here's the specification code to add to the end of the module, if d.is_fair(): print 'The deck is fair.' else: print 'Uh oh, this deck is unfair.' Include the tests you used to determine that your method was working correctly in the code you submit.","title":"Extending a class 2"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/#an-alternative-playing-card-representation","text":"Many OO programmers would look at the playing card classes developed in this module and shout, \"Wait a minute! Actual physical playing cards have two attributes, their suit and their face value. That means your Card objects should have two attributes too that match the physical attributes, not this sketchy card number thing that encodes the values of the actual attributes in an opaque way.\" And you know, they might be right. Modify the module playing_cards_4.py to use Card objects with a pair of attributes. Name the attributes suit and face_value . Hint 1 : You shouldn't change anything after the if __name__ == '__main__': statement. Remember that one of the goals of encapsulation is to be able drop in a new class implementation for an older one without having to rewrite any code that uses it. Hint 2 : You don't have to rewrite that much of the code above the if either. Think carefully about what needs to change.","title":"An alternative playing card representation"},{"location":"09_OOP1_Encapsulation/90_Assignment_9/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So problem 1 on this assignment will be named a9p1bob.py and your solution for problem will be named a9p2bob.py (adjusted obviously to use your name) . Please submit all your .py files to the Moodle dropbox.","title":"Logistics"},{"location":"10_OOD/","text":"Introduction: Hunt the Wumpus! \ud83d\ude08 As you now know, OOP consists of encapsulation, inheritance and polymorphism. Last week focused on the syntax needed to support encapsulation. This week we'll continue with encapsulation, but lift our eyes up from the syntax details, to consider design issues. Specifically Object Oriented Design principles that guide us in choosing the classes needed to support programming in a particular problem domain. In last week's OOP example of playing cards it was pretty obvious what the objects we had to represent were, and the interactions between those objects was fairly limited. This week we'll look at a problem domain with more objects, and more communication and connections between objects. The problem is to implement the venerable text adventure game Hunt the Wumpus . Most of the development is done as an extended case study in the week's notes, and the week's assignment will be to complete that development, and then add enhancements. (While the case study is of a game, the methods are applicable to any domain.) The code is not subtle or tricky, but there is a lot of it to wrap your head around, so if you haven't begun studying it yet now is the time! In the past this has been many students' favourite assignment, and I hope you'll enjoy it too. Object-Oriented Design (OOD) Preamble to Hunt the Wumpus About Hunt the Wumpus OO Analysis Object Attributes and Methods The Cave System Object(s) Main Routine Pseudocode class Cave_System Aside: Iterative Design class Room class Pit class Bat class Wumpus class Player Putting the pieces together New code: Initializing the bats New code (pointing to a missing class): shoot and Arrow s New code: show_cheats() New code: Display status and warnings Memory diagram Bug: Fixing (mostly) snatch Aside: Data structure maintenance Two more (small) problems How'd we do?","title":"Introduction: Hunt the Wumpus! \ud83d\ude08"},{"location":"10_OOD/#introduction-hunt-the-wumpus","text":"As you now know, OOP consists of encapsulation, inheritance and polymorphism. Last week focused on the syntax needed to support encapsulation. This week we'll continue with encapsulation, but lift our eyes up from the syntax details, to consider design issues. Specifically Object Oriented Design principles that guide us in choosing the classes needed to support programming in a particular problem domain. In last week's OOP example of playing cards it was pretty obvious what the objects we had to represent were, and the interactions between those objects was fairly limited. This week we'll look at a problem domain with more objects, and more communication and connections between objects. The problem is to implement the venerable text adventure game Hunt the Wumpus . Most of the development is done as an extended case study in the week's notes, and the week's assignment will be to complete that development, and then add enhancements. (While the case study is of a game, the methods are applicable to any domain.) The code is not subtle or tricky, but there is a lot of it to wrap your head around, so if you haven't begun studying it yet now is the time! In the past this has been many students' favourite assignment, and I hope you'll enjoy it too. Object-Oriented Design (OOD) Preamble to Hunt the Wumpus About Hunt the Wumpus OO Analysis Object Attributes and Methods The Cave System Object(s) Main Routine Pseudocode class Cave_System Aside: Iterative Design class Room class Pit class Bat class Wumpus class Player Putting the pieces together New code: Initializing the bats New code (pointing to a missing class): shoot and Arrow s New code: show_cheats() New code: Display status and warnings Memory diagram Bug: Fixing (mostly) snatch Aside: Data structure maintenance Two more (small) problems How'd we do?","title":"Introduction: Hunt the Wumpus! \ud83d\ude08"},{"location":"10_OOD/01_Object_oriented_design_OOD/","text":"Object-Oriented Design (OOD) (The last of the long modules!) The previous module concentrated on the new syntax and programming style required to write object oriented code. A bigger question we will turn to now is how to design OO code. Our simple OO design process 1 will be to, Analyze the problem domain into a set of objects, and classify the objects by type. Write a class to represent each type of object. Instantiate classes to create individual objects. Write the \"main\" program that specifies the pattern of communication among the objects. Analysis The critical step here is the first one. While there is considerable craft in completing the remaining steps, decomposing your problem domain into the right set of objects is crucial. In our playing card example it was fairly obvious what the objects would need to be, and there was relatively little communication between them. This is not typical \u2014 in most non-trivial problems there are usually several equally plausible decompositions which would each lead to quite different programs. How then to begin? The easiest case is where the problem domain you are modelling consists of physical objects that you can see. For example looking at one system you might see packages, boxes, pallets, trucks and warehouses while looking at another you might see a gearbox, drive shaft and axle. Next best is when your system does not consist of physical objects, but the objects leave physical traces behind, for example bills, purchase orders and invoices, or laws, regulations and policies. Hardest is when it is not clear what the objects are. For example we know the climate is made of gaseous molecules, but there are far too many of them for us to model it at that level. That means we must use some abstractions at a higher level that we hope capture what is going on at the molecular level, and often\u2014as in the case of climate modelling\u2014it is not clear what the appropriate abstractions are. Classes Once you have identified the types of objects you need to model, you use the Python language features from the last module to write a class for each type of object. This means identifying each object type's attributes (or state) and methods (or behaviour). Two questions helpful in identifying objects' attributes are: What qualities does this type of object have? For example does it have a weight? A colour? A size? An owner? A position? What type of information can it store ? For example a date of receipt? A list of contributors? Two questions helpful in identifying objects' methods are: What can this type of object do , i.e. what kinds of messages does it have to respond to? Can it move? Can it cancel? Can it record? Can it trigger? What questions can it answer about itself? Can it report its size? Its position? Its colour? You will notice that the attributes correspond to adjectives and nouns describing the objects, while the methods correspond to verbs. This distinction is often helpful when analyzing written system descriptions. Instantiation This simply means creating the objects your program requires, and consists of calls to the class constructors. We've already done this, for example in the last module, d = Deck() ... roxx = Hand() chris = Hand() Writing the \"main\" program The last step to complete the program is to write the main routine which specifies the pattern of communication between the objects in the system. We are just scratching the surface of a large and active area of programming practice here. Much has been written about methodologies for object oriented design, and there is a thriving industry of consultants who ~~preach~~ teach one methodology or another. Through the 1990s these methodologies became larger and larger until they begat a backlash movement that argued for smaller more agile processes. An exemplar of large-scale design is the Rational Unified Process (RUP). This methodology incorporates not only an extensive OO design process, it embeds it in a complete software development framework. The Silesia page on Agile Software Development provides pointers to some of the lighter-weight alternatives. \u21a9","title":"Object-Oriented Design (OOD)"},{"location":"10_OOD/01_Object_oriented_design_OOD/#object-oriented-design-ood","text":"(The last of the long modules!) The previous module concentrated on the new syntax and programming style required to write object oriented code. A bigger question we will turn to now is how to design OO code. Our simple OO design process 1 will be to, Analyze the problem domain into a set of objects, and classify the objects by type. Write a class to represent each type of object. Instantiate classes to create individual objects. Write the \"main\" program that specifies the pattern of communication among the objects.","title":"Object-Oriented Design (OOD)"},{"location":"10_OOD/01_Object_oriented_design_OOD/#analysis","text":"The critical step here is the first one. While there is considerable craft in completing the remaining steps, decomposing your problem domain into the right set of objects is crucial. In our playing card example it was fairly obvious what the objects would need to be, and there was relatively little communication between them. This is not typical \u2014 in most non-trivial problems there are usually several equally plausible decompositions which would each lead to quite different programs. How then to begin? The easiest case is where the problem domain you are modelling consists of physical objects that you can see. For example looking at one system you might see packages, boxes, pallets, trucks and warehouses while looking at another you might see a gearbox, drive shaft and axle. Next best is when your system does not consist of physical objects, but the objects leave physical traces behind, for example bills, purchase orders and invoices, or laws, regulations and policies. Hardest is when it is not clear what the objects are. For example we know the climate is made of gaseous molecules, but there are far too many of them for us to model it at that level. That means we must use some abstractions at a higher level that we hope capture what is going on at the molecular level, and often\u2014as in the case of climate modelling\u2014it is not clear what the appropriate abstractions are.","title":"Analysis"},{"location":"10_OOD/01_Object_oriented_design_OOD/#classes","text":"Once you have identified the types of objects you need to model, you use the Python language features from the last module to write a class for each type of object. This means identifying each object type's attributes (or state) and methods (or behaviour). Two questions helpful in identifying objects' attributes are: What qualities does this type of object have? For example does it have a weight? A colour? A size? An owner? A position? What type of information can it store ? For example a date of receipt? A list of contributors? Two questions helpful in identifying objects' methods are: What can this type of object do , i.e. what kinds of messages does it have to respond to? Can it move? Can it cancel? Can it record? Can it trigger? What questions can it answer about itself? Can it report its size? Its position? Its colour? You will notice that the attributes correspond to adjectives and nouns describing the objects, while the methods correspond to verbs. This distinction is often helpful when analyzing written system descriptions.","title":"Classes"},{"location":"10_OOD/01_Object_oriented_design_OOD/#instantiation","text":"This simply means creating the objects your program requires, and consists of calls to the class constructors. We've already done this, for example in the last module, d = Deck() ... roxx = Hand() chris = Hand()","title":"Instantiation"},{"location":"10_OOD/01_Object_oriented_design_OOD/#writing-the-main-program","text":"The last step to complete the program is to write the main routine which specifies the pattern of communication between the objects in the system. We are just scratching the surface of a large and active area of programming practice here. Much has been written about methodologies for object oriented design, and there is a thriving industry of consultants who ~~preach~~ teach one methodology or another. Through the 1990s these methodologies became larger and larger until they begat a backlash movement that argued for smaller more agile processes. An exemplar of large-scale design is the Rational Unified Process (RUP). This methodology incorporates not only an extensive OO design process, it embeds it in a complete software development framework. The Silesia page on Agile Software Development provides pointers to some of the lighter-weight alternatives. \u21a9","title":"Writing the \"main\" program"},{"location":"10_OOD/02_Preamble_to_hunt_the_wumpus/","text":"Preamble to Hunt the Wumpus In our playing card example it was fairly obvious what the objects would need to be, and there was relatively little communication between them. This is not typical. In most non-trivial problems there are usually several equally plausible decompositions which would each lead to quite different looking programs. Furthermore the pattern of communication can be quite complicated and depend on subtle conditions. In this module we will consider a problem with more objects and a less obvious analysis than the playing cards, and with considerably more communication between objects. Our problem will be to implement the game Hunt the Wumpus .","title":"Preamble to Hunt the Wumpus"},{"location":"10_OOD/02_Preamble_to_hunt_the_wumpus/#preamble-to-hunt-the-wumpus","text":"In our playing card example it was fairly obvious what the objects would need to be, and there was relatively little communication between them. This is not typical. In most non-trivial problems there are usually several equally plausible decompositions which would each lead to quite different looking programs. Furthermore the pattern of communication can be quite complicated and depend on subtle conditions. In this module we will consider a problem with more objects and a less obvious analysis than the playing cards, and with considerably more communication between objects. Our problem will be to implement the game Hunt the Wumpus .","title":"Preamble to Hunt the Wumpus"},{"location":"10_OOD/03_About_hunt_the_wumpus/","text":"About Hunt the Wumpus Hunt the Wumpus was one of the first interactive computer games. It is often cited as the first Interactive Fiction game, and sometimes as the first game written for a microprocessor (as opposed to a minicomputer or mainframe). As usual Wikipedia has a fine background article about it. There are several online implementations of the game so you can try it out before we begin building our own version. The original version was written in 1970 in BASIC, but it has since been translated into many other languages ( including Python ). For interest, here's the original BASIC source code \u2014 users would type this in (!) in order to play the game. I hope you realized from its age that this is a text-based game and not a graphical first person shooter. If not, this short game transcript should make it clear, and also demonstrate the game and explain the rules: Welcome to \"Hunt the Wumpus\" The wumpus lives in a cave of 20 rooms. Each room has 3 tunnels to other rooms. (Look at a dodecahedron to see how this works. If you don't know what a dodecahedron is, ask someone.) Hazards: Bottomless pits - Two rooms have bottomless pits in them. If you go there, you fall into the pit (& lose)! Super bats - Two other rooms have super bats. If you go there, a bat grabs you and takes you to some other room at random (which may be troublesome). Wumpus: The wumpus is not bothered by hazards. (He has sucker feet and is Too big for a bat to lift.) Usually he is asleep. Two things wake him up: Your shooting an arrow, or your entering his room. If the wumpus wakes, he moves (p=.75) one room or stays still (p=.25). After that, if he is where you are, he eats you up and you lose! You: Each turn you may move or shoot a crooked arrow. Moving: You can move one room (Through one tunnel). Arrows: You have 5 arrows. You lose when you run out. Each arrow can go from 1 to 3 rooms. You aim by telling the computer the rooms to which you want the arrow to go. If the arrow can't go that way (if no tunnel) it moves at random to the next room. If the arrow hits the wumpus, you win. If the arrow hits you, you lose. Warnings: When you are one room away from a wumpus or hazard, the computer says: Wumpus: \"I smell a wumpus!\" Bat : \"Bats nearby!\" Pit : \"I feel a draft!\" You are in room 12. There are tunnels to rooms 11, 13, and 19. I feel a draft! Shoot, move, or quit (s/m/q)? m To which room (11, 13, or 19)? 13 AEEEIIIIII! You fell into a pit! I won't make you ask by email about the dodecahedron :-) A dodecahedron looks like this: In our game the vertices (the corners or points) correspond to the locations of the rooms, and the edges (or ridgelines) correspond to the tunnels that connect caves. You can see that each cave is connected to three others. For our purposes it is easier to work with a \"squashed\" version (imagine someone steps on the 3-D picture above and squashes it flat):","title":"About Hunt the Wumpus"},{"location":"10_OOD/03_About_hunt_the_wumpus/#about-hunt-the-wumpus","text":"Hunt the Wumpus was one of the first interactive computer games. It is often cited as the first Interactive Fiction game, and sometimes as the first game written for a microprocessor (as opposed to a minicomputer or mainframe). As usual Wikipedia has a fine background article about it. There are several online implementations of the game so you can try it out before we begin building our own version. The original version was written in 1970 in BASIC, but it has since been translated into many other languages ( including Python ). For interest, here's the original BASIC source code \u2014 users would type this in (!) in order to play the game. I hope you realized from its age that this is a text-based game and not a graphical first person shooter. If not, this short game transcript should make it clear, and also demonstrate the game and explain the rules: Welcome to \"Hunt the Wumpus\" The wumpus lives in a cave of 20 rooms. Each room has 3 tunnels to other rooms. (Look at a dodecahedron to see how this works. If you don't know what a dodecahedron is, ask someone.) Hazards: Bottomless pits - Two rooms have bottomless pits in them. If you go there, you fall into the pit (& lose)! Super bats - Two other rooms have super bats. If you go there, a bat grabs you and takes you to some other room at random (which may be troublesome). Wumpus: The wumpus is not bothered by hazards. (He has sucker feet and is Too big for a bat to lift.) Usually he is asleep. Two things wake him up: Your shooting an arrow, or your entering his room. If the wumpus wakes, he moves (p=.75) one room or stays still (p=.25). After that, if he is where you are, he eats you up and you lose! You: Each turn you may move or shoot a crooked arrow. Moving: You can move one room (Through one tunnel). Arrows: You have 5 arrows. You lose when you run out. Each arrow can go from 1 to 3 rooms. You aim by telling the computer the rooms to which you want the arrow to go. If the arrow can't go that way (if no tunnel) it moves at random to the next room. If the arrow hits the wumpus, you win. If the arrow hits you, you lose. Warnings: When you are one room away from a wumpus or hazard, the computer says: Wumpus: \"I smell a wumpus!\" Bat : \"Bats nearby!\" Pit : \"I feel a draft!\" You are in room 12. There are tunnels to rooms 11, 13, and 19. I feel a draft! Shoot, move, or quit (s/m/q)? m To which room (11, 13, or 19)? 13 AEEEIIIIII! You fell into a pit! I won't make you ask by email about the dodecahedron :-) A dodecahedron looks like this: In our game the vertices (the corners or points) correspond to the locations of the rooms, and the edges (or ridgelines) correspond to the tunnels that connect caves. You can see that each cave is connected to three others. For our purposes it is easier to work with a \"squashed\" version (imagine someone steps on the 3-D picture above and squashes it flat):","title":"About Hunt the Wumpus"},{"location":"10_OOD/04_OO_analysis/","text":"OO Analysis The OO analysis isn't too tricky in this problem because we have a pretty good informal specification: the description of the game and its rules that is displayed at the start of the game. Remembering that objects often correspond to nouns in the problem domain, let's read over the game description and highlight the objects (nouns) it discusses: Welcome to \"Hunt the Wumpus\" The wumpus lives in a cave of 20 rooms . Each room has 3 tunnels to other rooms. (Look at a dodecahedron to see how this works. If you don't know what a dodecahedron is, ask someone.) Hazards: Bottomless pits - Two rooms have bottomless pits in them. If you go there, you fall into the pit (& lose)! Super bats - Two other rooms have super bats. If you go there, a bat grabs you and takes you to some other room at random (which may be troublesome). Wumpus: The wumpus is not bothered by hazards. (He has sucker feet and is Too big for a bat to lift.) Usually he is asleep. Two things wake him up: Your shooting an arrow , or your entering his room. If the wumpus wakes, he moves (p=.75) one room or stays still (p=.25). After that, if he is where you are, he eats you up and you lose! You: Each turn you may move or shoot a crooked arrow. Moving: You can move one room (Through one tunnel). Arrows: You have 5 arrows. You lose when you run out. Each arrow can go from 1 to 3 rooms. You aim by telling the computer the rooms to which you want the arrow to go. If the arrow can't go that way (if no tunnel) it moves at random to the next room. If the arrow hits the wumpus, you win. If the arrow hits you, you lose. Warnings: When you are one room away from a wumpus or hazard, the computer says: Wumpus: \"I smell a wumpus!\" Bat : \"Bats nearby!\" Pit : \"I feel a draft!\" You are in room 12. There are tunnels to rooms 11, 13, and 19. I feel a draft! Shoot, move, or quit (s/m/q)? m To which room (11, 13, or 19)? 13 AEEEIIIIII! You fell into a pit! The types of objects we have then are: a wumpus; a cave system of rooms connected by tunnels; pits; you, i.e. the player, bats; and arrows. And from the rules we can tell what behaviours the objects will have. The Wumpus mostly sleeps (as he digests the villagers he ate last night!), but does wake when disturbed, and then has behaviour with a random component to it. Bats grab players and fly them somewhere else. You move from room to room and shoot arrows. And so on.","title":"OO Analysis"},{"location":"10_OOD/04_OO_analysis/#oo-analysis","text":"The OO analysis isn't too tricky in this problem because we have a pretty good informal specification: the description of the game and its rules that is displayed at the start of the game. Remembering that objects often correspond to nouns in the problem domain, let's read over the game description and highlight the objects (nouns) it discusses: Welcome to \"Hunt the Wumpus\" The wumpus lives in a cave of 20 rooms . Each room has 3 tunnels to other rooms. (Look at a dodecahedron to see how this works. If you don't know what a dodecahedron is, ask someone.) Hazards: Bottomless pits - Two rooms have bottomless pits in them. If you go there, you fall into the pit (& lose)! Super bats - Two other rooms have super bats. If you go there, a bat grabs you and takes you to some other room at random (which may be troublesome). Wumpus: The wumpus is not bothered by hazards. (He has sucker feet and is Too big for a bat to lift.) Usually he is asleep. Two things wake him up: Your shooting an arrow , or your entering his room. If the wumpus wakes, he moves (p=.75) one room or stays still (p=.25). After that, if he is where you are, he eats you up and you lose! You: Each turn you may move or shoot a crooked arrow. Moving: You can move one room (Through one tunnel). Arrows: You have 5 arrows. You lose when you run out. Each arrow can go from 1 to 3 rooms. You aim by telling the computer the rooms to which you want the arrow to go. If the arrow can't go that way (if no tunnel) it moves at random to the next room. If the arrow hits the wumpus, you win. If the arrow hits you, you lose. Warnings: When you are one room away from a wumpus or hazard, the computer says: Wumpus: \"I smell a wumpus!\" Bat : \"Bats nearby!\" Pit : \"I feel a draft!\" You are in room 12. There are tunnels to rooms 11, 13, and 19. I feel a draft! Shoot, move, or quit (s/m/q)? m To which room (11, 13, or 19)? 13 AEEEIIIIII! You fell into a pit! The types of objects we have then are: a wumpus; a cave system of rooms connected by tunnels; pits; you, i.e. the player, bats; and arrows. And from the rules we can tell what behaviours the objects will have. The Wumpus mostly sleeps (as he digests the villagers he ate last night!), but does wake when disturbed, and then has behaviour with a random component to it. Bats grab players and fly them somewhere else. You move from room to room and shoot arrows. And so on.","title":"OO Analysis"},{"location":"10_OOD/05_Object_attributes_and_methods/","text":"Object Attributes and Methods Keeping the objects we've identified in mind we can re-read the game description looking for verbs and adjectives to reveal the objects' attributes and methods. Player Attributes: At any instant the player has a location in the cave system and a number of arrows left. Methods: The player is able to move from room to room, and to shoot arrows. Bat Attributes: Like the player(s) each bat has a location in the cave system. Methods: A Bat's only action is to snatch the player and carry him or her away. Pit Attributes: Like Players and Bats, Pits have a location . Methods: Pits can swallow players who stumble into them. Wumpus Attributes: Location , 'nuff said. Methods: All the wumpus does is wake up and either run off or eat a player. Arrows Attributes: A path they will try and follow. Methods: An Arrow flies from room to room along the specified path. So much for the simple objects.","title":"Object Attributes and Methods"},{"location":"10_OOD/05_Object_attributes_and_methods/#object-attributes-and-methods","text":"Keeping the objects we've identified in mind we can re-read the game description looking for verbs and adjectives to reveal the objects' attributes and methods. Player Attributes: At any instant the player has a location in the cave system and a number of arrows left. Methods: The player is able to move from room to room, and to shoot arrows. Bat Attributes: Like the player(s) each bat has a location in the cave system. Methods: A Bat's only action is to snatch the player and carry him or her away. Pit Attributes: Like Players and Bats, Pits have a location . Methods: Pits can swallow players who stumble into them. Wumpus Attributes: Location , 'nuff said. Methods: All the wumpus does is wake up and either run off or eat a player. Arrows Attributes: A path they will try and follow. Methods: An Arrow flies from room to room along the specified path. So much for the simple objects.","title":"Object Attributes and Methods"},{"location":"10_OOD/06_The_cave_system_objects/","text":"The Cave System Object(s) The cave system is the lynchpin of this system of objects because all the simple objects are situated in and/or move through it. It is also the most complex of the objects because it is a compound object : the cave system consists of multiple rooms connected by multiple tunnels. This means that it will have to be a container type of some sort. Attributes: 20 caves ; the pattern of connections between caves. Methods: Should be able to tell us where you can go from here (i.e. what rooms are connected to this one); if a room has a bat ; if a room has a pit ; if the player is in a room. The cave system contains 20 Room objects which as objects have their own attributes and methods: Attributes: 3 tunnels , possibly a bat , possibly a pit , possibly a wumpus . Methods: Should be able to tell us if it has a bat , has a pit , or has a wumpus .","title":"The Cave System Object(s)"},{"location":"10_OOD/06_The_cave_system_objects/#the-cave-system-objects","text":"The cave system is the lynchpin of this system of objects because all the simple objects are situated in and/or move through it. It is also the most complex of the objects because it is a compound object : the cave system consists of multiple rooms connected by multiple tunnels. This means that it will have to be a container type of some sort. Attributes: 20 caves ; the pattern of connections between caves. Methods: Should be able to tell us where you can go from here (i.e. what rooms are connected to this one); if a room has a bat ; if a room has a pit ; if the player is in a room. The cave system contains 20 Room objects which as objects have their own attributes and methods: Attributes: 3 tunnels , possibly a bat , possibly a pit , possibly a wumpus . Methods: Should be able to tell us if it has a bat , has a pit , or has a wumpus .","title":"The Cave System Object(s)"},{"location":"10_OOD/07_Main_routine_pseudocode/","text":"Main Routine Pseudocode Let's use the class, attribute and method names we've identified so far and try to write the main routine of our program. Doing so should reveal any missing objects, or missing attributes or methods of objects. First we'll say what we want to do as plainly as we can in English. While the game isn't over Display the game state Display the menu of possible actions Get the user's choice of action If the action is move Display the choices (connected rooms) Get the user's choice Move the player If the room has a bat Have the bat snatch the player Otherwise if the room has a pit Have the pit swallow the player Otherwise if the room has a Wumpus Wake the Wumpus up Otherwise if the action is shoot Get the path for the arrow to follow from the user Tell the arrow to fly that path Otherwise if the action is quit Quit the game There's one subtlety here that may escape your notice at first glance and that is the significance of the ordering of the three possibilities in reaction to a movement. This pseudocode says that if there is both a bat and a pit in the room the player moves to, the bat will snatch the player before they can fall into the pit, making a bat snatch a good thing in this circumstance! Likewise if there is a pit and a Wumpus the player will fall into the pit before the Wumpus is woken up. The instructions we are basing this on do not say what should happen in these cases, so I have made some arbitrary but reasonable (I think!) decisions. Now let's try to match these English phrases with our object methods and attributes, and introduce some Python where the equivalent Python commands are obvious (e.g. the main while loop control is something we've seen before): 1 while not game_over: 2 print(cave_system) 3 print(player.location) 4 action = input('Shoot, move or quit (s/m/q)? ') 5 if action == 'm': 6 print('Choose from: ', cave_system.rooms[player.location].tunnels) 7 room_choice = int(input('Your choice? ')) 8 player.move(room_choice) 9 new_room = cave_system.rooms[player.location] # Note simplifying alias. 10 if new_room.has_bat(): 11 new_room.bat.snatch() 12 elif new_room.has_pit(): 13 new_room.pit.swallow() 14 game_over = True 15 elif new_room.has_wumpus(): 16 game_over = room.wumpus.wake_up() 17 elif action == 's': 18 player.shoot() 19 elif action == 'q': 20 game_over = True Take some time to study this code. There are numerous things to note: \u2192 line 3 Displaying the player's location attribute (see the dot notation?) \u2192 line 6 cave_system.rooms[player.location] .tunnels is a relatively complex expression for us, so let's deconstruct it carefully. - cave_system.rooms is the rooms attribute of cave_system - the square brackets of cave_system.rooms[] indicate that the rooms attribute is a list of room s - we use the player's location attribute, player.location , to access the current room - we display the tunnels leading from the current room by printing the tunnels attribute of the current room \u2192 line 8 player.move(room_choice) calls the player's move method with room_choice as a parameter (or equivalently, sends the player object the message to move to room_choice ) \u2192 line 9 the player is now in room cave_systems.rooms[player.location] but that is a mouthful to say or type so we will introduce a simplifying alias for it and refer to it as new_room . Note that new_room is exactly cave_systems.rooms[player.location] because it is a reference to that object. \u2192 line 10 we call new_room 's has_bat method to find out if the room contains a bat . \u2192 line 11 we call the bat in new_room 's snatch method (or equivalently, send the bat object in new_room the message to snatch ). \u2192 line 12-15 similarly to lines 10 and 11 \u2192 line 16 we don't just tell the Wumpus to wake_up , we ask it to report back to us if the game is over. We need to do this because the game may or may not end depending on what the wumpus does, whereas in line 13 we know the game ends when the player falls in a pit. This is why the swallow method does not report back: its outcome is a foregone conclusion. \u2192 line 18 to keep things short I just called the player's shoot method here. It may in fact be better to get the arrow's desired path here, like we did for the movement destination, than inside the shoot method. That didn't reveal any objects, attributes or methods we had missed, which gives me enough confidence that we have a reasonable object model to continue developing our objects. Next we'll flesh out the class definitions and then return to our main line code.","title":"Main Routine Pseudocode"},{"location":"10_OOD/07_Main_routine_pseudocode/#main-routine-pseudocode","text":"Let's use the class, attribute and method names we've identified so far and try to write the main routine of our program. Doing so should reveal any missing objects, or missing attributes or methods of objects. First we'll say what we want to do as plainly as we can in English. While the game isn't over Display the game state Display the menu of possible actions Get the user's choice of action If the action is move Display the choices (connected rooms) Get the user's choice Move the player If the room has a bat Have the bat snatch the player Otherwise if the room has a pit Have the pit swallow the player Otherwise if the room has a Wumpus Wake the Wumpus up Otherwise if the action is shoot Get the path for the arrow to follow from the user Tell the arrow to fly that path Otherwise if the action is quit Quit the game There's one subtlety here that may escape your notice at first glance and that is the significance of the ordering of the three possibilities in reaction to a movement. This pseudocode says that if there is both a bat and a pit in the room the player moves to, the bat will snatch the player before they can fall into the pit, making a bat snatch a good thing in this circumstance! Likewise if there is a pit and a Wumpus the player will fall into the pit before the Wumpus is woken up. The instructions we are basing this on do not say what should happen in these cases, so I have made some arbitrary but reasonable (I think!) decisions. Now let's try to match these English phrases with our object methods and attributes, and introduce some Python where the equivalent Python commands are obvious (e.g. the main while loop control is something we've seen before): 1 while not game_over: 2 print(cave_system) 3 print(player.location) 4 action = input('Shoot, move or quit (s/m/q)? ') 5 if action == 'm': 6 print('Choose from: ', cave_system.rooms[player.location].tunnels) 7 room_choice = int(input('Your choice? ')) 8 player.move(room_choice) 9 new_room = cave_system.rooms[player.location] # Note simplifying alias. 10 if new_room.has_bat(): 11 new_room.bat.snatch() 12 elif new_room.has_pit(): 13 new_room.pit.swallow() 14 game_over = True 15 elif new_room.has_wumpus(): 16 game_over = room.wumpus.wake_up() 17 elif action == 's': 18 player.shoot() 19 elif action == 'q': 20 game_over = True Take some time to study this code. There are numerous things to note: \u2192 line 3 Displaying the player's location attribute (see the dot notation?) \u2192 line 6 cave_system.rooms[player.location] .tunnels is a relatively complex expression for us, so let's deconstruct it carefully. - cave_system.rooms is the rooms attribute of cave_system - the square brackets of cave_system.rooms[] indicate that the rooms attribute is a list of room s - we use the player's location attribute, player.location , to access the current room - we display the tunnels leading from the current room by printing the tunnels attribute of the current room \u2192 line 8 player.move(room_choice) calls the player's move method with room_choice as a parameter (or equivalently, sends the player object the message to move to room_choice ) \u2192 line 9 the player is now in room cave_systems.rooms[player.location] but that is a mouthful to say or type so we will introduce a simplifying alias for it and refer to it as new_room . Note that new_room is exactly cave_systems.rooms[player.location] because it is a reference to that object. \u2192 line 10 we call new_room 's has_bat method to find out if the room contains a bat . \u2192 line 11 we call the bat in new_room 's snatch method (or equivalently, send the bat object in new_room the message to snatch ). \u2192 line 12-15 similarly to lines 10 and 11 \u2192 line 16 we don't just tell the Wumpus to wake_up , we ask it to report back to us if the game is over. We need to do this because the game may or may not end depending on what the wumpus does, whereas in line 13 we know the game ends when the player falls in a pit. This is why the swallow method does not report back: its outcome is a foregone conclusion. \u2192 line 18 to keep things short I just called the player's shoot method here. It may in fact be better to get the arrow's desired path here, like we did for the movement destination, than inside the shoot method. That didn't reveal any objects, attributes or methods we had missed, which gives me enough confidence that we have a reasonable object model to continue developing our objects. Next we'll flesh out the class definitions and then return to our main line code.","title":"Main Routine Pseudocode"},{"location":"10_OOD/08_Class_cave_system/","text":"class Cave_System Generally I like to write my classes from simplest to most complicated, but that's not always possible. In this case for instance, because all our other objects need to refer to the cave system we have to begin with its class definition. Recall that in our first pass at the cave system object we said it consists of multiple rooms connected by multiple tunnels. This means that it will have to be a container type of some sort. Attributes: 20 caves ; the pattern of connections between caves. Methods: Should be able to tell us where you can go from here /what rooms are connected to this one; if a room has a bat ; if a room has a pit ; if the player is in a room. Looking at our pseudocode it looks like I was right about the container type, notice the square brackets in lines 6 and 9 which indicate a list: 6 print('Choose from: ', cave_system.rooms[player.location].tunnels) ... 9 new_room = cave_system.rooms[player.location] # Note simplifying alias. Those show us that Cave_System s have a rooms attribute that is a list. Based on its name, rooms is a list of the Room objects in the cave system. Now how to represent the pattern of connections between rooms? One simple way would be for each Room to know what other Room s it is connected to, and that seems like a reasonable thing for a Room object to know so we'll make it an attribute of Room objects. Looking at line 6 above you can see that that's how it's written: the Room s in the Cave_System 's rooms attribute have an attribute tunnels that presumably lists the rooms the tunnels connect this room to. So far so good, but I didn't do as well in my initial guess about the cave system's methods. My initial guess was that a cave system \"should be able to tell us where you can go from here /what rooms are connected to this one; if a room has a bat ; if a room has a pit ; if the player is in a room.\" But, if you look at the pseudocode where these questions are actually asked you can see that they are asked of Room objects not of the cave system as a whole: 10 if new_room.has_bat(): ... 12 elif new_room.has_pit(): ... 15 elif new_room.has_wumpus(): ... This means that these methods properly belong to Room objects not Cave_System s so we'll move them there. What methods do cave systems have then? Almost none, but there is one slightly non-obvious one. Try spotting it... Did you spot it in this line? 2 print(cave_system) There's no explicit method call there, i.e. no parentheses, but remember that for an object to be printable it has to provide an __str__ method so there is an implicit call to cave_system.__str__ in this line. Thus a Cave_System 's only method (beyond __init__ ) will be __str__ . In sum this class doesn't have that much in it. It has to initialize a list of Room objects and provide an __str__ method. Here's its code, Note that the constructor is passed a list of tunnel connections between rooms, and a map of the system. We can tell that tunnels is a list because of the way it is used with square brackets in the sixth line: tunnels[i] . We can tell system_map will need to be a string containing a printable map of the system because it is returned by __str__ and that method has to return a string. To make this more concrete here's the code to create a Cave_System object corresponding to our squashed dodecahedron cave system: TUNNELS = [[1,7,19], [0,2,14], [1,3,6], [2,4,13], [3,5,11], [4,6,9], [2,5,7], [0,6,8], [7,9,18], [5,8,10], [9,11,17], [4,10,12], [11,13,16], [3,12,14], [1,13,15], [14,16,19], [12,15,17], [10,16,18], [8,17,19], [0,15,18] ] MAP = ''' 19 - - - - - - - - - - - - - - - - 15 / \\ / \\ / \\ - - - - 1 - - - - / \\ / \\ / | \\ / \\ / \\ / | \\ / \\ | 0 2 14 | | / / \\ \\ | | / / \\ \\ | | / / \\ \\ | | 7 - - - 6 3 - - - 13 | | \\ \\ / / | | \\ \\ / / | 18 - - - - 8 5 - - - 4 12 - - - - 16 \\ \\ / \\ / / \\ \\ / \\ / / \\ 9 - - - 10 - - - 11 / \\ | / \\ | / \\ | / - - - - - - 17 - - - - - - - - ''' cave_system = Cave_System(TUNNELS, MAP) What does cave_system look like in memory? We can picture it like this:","title":"class Cave_System"},{"location":"10_OOD/08_Class_cave_system/#class-cave_system","text":"Generally I like to write my classes from simplest to most complicated, but that's not always possible. In this case for instance, because all our other objects need to refer to the cave system we have to begin with its class definition. Recall that in our first pass at the cave system object we said it consists of multiple rooms connected by multiple tunnels. This means that it will have to be a container type of some sort. Attributes: 20 caves ; the pattern of connections between caves. Methods: Should be able to tell us where you can go from here /what rooms are connected to this one; if a room has a bat ; if a room has a pit ; if the player is in a room. Looking at our pseudocode it looks like I was right about the container type, notice the square brackets in lines 6 and 9 which indicate a list: 6 print('Choose from: ', cave_system.rooms[player.location].tunnels) ... 9 new_room = cave_system.rooms[player.location] # Note simplifying alias. Those show us that Cave_System s have a rooms attribute that is a list. Based on its name, rooms is a list of the Room objects in the cave system. Now how to represent the pattern of connections between rooms? One simple way would be for each Room to know what other Room s it is connected to, and that seems like a reasonable thing for a Room object to know so we'll make it an attribute of Room objects. Looking at line 6 above you can see that that's how it's written: the Room s in the Cave_System 's rooms attribute have an attribute tunnels that presumably lists the rooms the tunnels connect this room to. So far so good, but I didn't do as well in my initial guess about the cave system's methods. My initial guess was that a cave system \"should be able to tell us where you can go from here /what rooms are connected to this one; if a room has a bat ; if a room has a pit ; if the player is in a room.\" But, if you look at the pseudocode where these questions are actually asked you can see that they are asked of Room objects not of the cave system as a whole: 10 if new_room.has_bat(): ... 12 elif new_room.has_pit(): ... 15 elif new_room.has_wumpus(): ... This means that these methods properly belong to Room objects not Cave_System s so we'll move them there. What methods do cave systems have then? Almost none, but there is one slightly non-obvious one. Try spotting it... Did you spot it in this line? 2 print(cave_system) There's no explicit method call there, i.e. no parentheses, but remember that for an object to be printable it has to provide an __str__ method so there is an implicit call to cave_system.__str__ in this line. Thus a Cave_System 's only method (beyond __init__ ) will be __str__ . In sum this class doesn't have that much in it. It has to initialize a list of Room objects and provide an __str__ method. Here's its code, Note that the constructor is passed a list of tunnel connections between rooms, and a map of the system. We can tell that tunnels is a list because of the way it is used with square brackets in the sixth line: tunnels[i] . We can tell system_map will need to be a string containing a printable map of the system because it is returned by __str__ and that method has to return a string. To make this more concrete here's the code to create a Cave_System object corresponding to our squashed dodecahedron cave system: TUNNELS = [[1,7,19], [0,2,14], [1,3,6], [2,4,13], [3,5,11], [4,6,9], [2,5,7], [0,6,8], [7,9,18], [5,8,10], [9,11,17], [4,10,12], [11,13,16], [3,12,14], [1,13,15], [14,16,19], [12,15,17], [10,16,18], [8,17,19], [0,15,18] ] MAP = ''' 19 - - - - - - - - - - - - - - - - 15 / \\ / \\ / \\ - - - - 1 - - - - / \\ / \\ / | \\ / \\ / \\ / | \\ / \\ | 0 2 14 | | / / \\ \\ | | / / \\ \\ | | / / \\ \\ | | 7 - - - 6 3 - - - 13 | | \\ \\ / / | | \\ \\ / / | 18 - - - - 8 5 - - - 4 12 - - - - 16 \\ \\ / \\ / / \\ \\ / \\ / / \\ 9 - - - 10 - - - 11 / \\ | / \\ | / \\ | / - - - - - - 17 - - - - - - - - ''' cave_system = Cave_System(TUNNELS, MAP) What does cave_system look like in memory? We can picture it like this:","title":"class Cave_System"},{"location":"10_OOD/09_Aside_iterative_design/","text":"Aside: Iterative Design Most software design is iterative. This means that we iterate from general code to specific code, gradually adding more detail on each pass (iteration). It also means that we iterate or alternate between the control code in the main routine and the code in the class definitions. Did you notice the mistakes I made in my first pass at Cave_System s' methods? We are moving back and forth (iterating) between the main control code and the class definitions just so that we can spot these misfits as early as possible so correcting them is easy. If we had done a complete class hierarchy and only then tried to write the main routine we would have \"baked in\" and expanded on these errors and they would be harder to fix. In fact the temptation to write convoluted code to deal with the shortcomings of our classes might be too hard to resist! Similarly, if we were to write our main routine in detail before considering what classes we should use, we would only end up with well designed classes by sheer luck since they would not in fact have been designed . So was there a mistake in my original class design? Sure. But the iterative approach ensured that I caught it early when it was easy to fix. So let's fix it by turning to the Room class.","title":"Aside: Iterative Design"},{"location":"10_OOD/09_Aside_iterative_design/#aside-iterative-design","text":"Most software design is iterative. This means that we iterate from general code to specific code, gradually adding more detail on each pass (iteration). It also means that we iterate or alternate between the control code in the main routine and the code in the class definitions. Did you notice the mistakes I made in my first pass at Cave_System s' methods? We are moving back and forth (iterating) between the main control code and the class definitions just so that we can spot these misfits as early as possible so correcting them is easy. If we had done a complete class hierarchy and only then tried to write the main routine we would have \"baked in\" and expanded on these errors and they would be harder to fix. In fact the temptation to write convoluted code to deal with the shortcomings of our classes might be too hard to resist! Similarly, if we were to write our main routine in detail before considering what classes we should use, we would only end up with well designed classes by sheer luck since they would not in fact have been designed . So was there a mistake in my original class design? Sure. But the iterative approach ensured that I caught it early when it was easy to fix. So let's fix it by turning to the Room class.","title":"Aside: Iterative Design"},{"location":"10_OOD/10_Class_room/","text":"class Room Rooms have the attributes and methods we identified in our first pass plus the methods we have shifted from Cave_System s to Room s: Attributes: 3 tunnels , possibly a bat , possibly a pit , possibly a wumpus . Methods: Should be able to tell us if it has a bat , has a pit , or has a wumpus, plus should be able to tell us where you can go from here , what rooms are connected to this one; if a room has a bat ; if a room has a pit ; if the player is in a room. Note the duplication in the methods list has a bat and has a pit appears twice! That means that in our first pass we had assigned two classes responsibility for answering that question. It's almost always better to have one class responsible for each action, so this revision already looks like an improvement. But not perfect. In our pseudocode we ask the player for its location repeatedly (look for the references to player.location ). Note that we don't ask a room if a player is in it, we ask the player. So we'll remove that method from class Room , leaving us with, Attributes: 3 tunnels , possibly a bat , possibly a pit , possibly a wumpus . Methods: Should be able to tell us where you can go from here (what rooms are connected to this one) and if it has a bat , has a pit , or has a wumpus . In Python we get, Notes: We will identify rooms by their number as shown in MAP previously. connections here is a list of rooms connected by tunnels to this one, e.g. [1, 7, 4] meaning this room is connected to room number 1, room number 7, and room number 4. By default a room does not have a bat, pit or wumpus ( b=None, p=None, w=None ). These will be sprinkled around the cave system later. The has_... methods that answer questions look to see if the relevant attribute is defined and if it is, returns True , otherwise False . In memory a single Room object can be pictured like this (for room 12 which connects to rooms 11, 13 and 16, and has a Bat but no Pit or Wumpus), and an entire cave system can be pictured as (with most rooms left out and only the details for room 12 shown), The remaining classes are relatively straightforward compared to these first two.","title":"class Room"},{"location":"10_OOD/10_Class_room/#class-room","text":"Rooms have the attributes and methods we identified in our first pass plus the methods we have shifted from Cave_System s to Room s: Attributes: 3 tunnels , possibly a bat , possibly a pit , possibly a wumpus . Methods: Should be able to tell us if it has a bat , has a pit , or has a wumpus, plus should be able to tell us where you can go from here , what rooms are connected to this one; if a room has a bat ; if a room has a pit ; if the player is in a room. Note the duplication in the methods list has a bat and has a pit appears twice! That means that in our first pass we had assigned two classes responsibility for answering that question. It's almost always better to have one class responsible for each action, so this revision already looks like an improvement. But not perfect. In our pseudocode we ask the player for its location repeatedly (look for the references to player.location ). Note that we don't ask a room if a player is in it, we ask the player. So we'll remove that method from class Room , leaving us with, Attributes: 3 tunnels , possibly a bat , possibly a pit , possibly a wumpus . Methods: Should be able to tell us where you can go from here (what rooms are connected to this one) and if it has a bat , has a pit , or has a wumpus . In Python we get, Notes: We will identify rooms by their number as shown in MAP previously. connections here is a list of rooms connected by tunnels to this one, e.g. [1, 7, 4] meaning this room is connected to room number 1, room number 7, and room number 4. By default a room does not have a bat, pit or wumpus ( b=None, p=None, w=None ). These will be sprinkled around the cave system later. The has_... methods that answer questions look to see if the relevant attribute is defined and if it is, returns True , otherwise False . In memory a single Room object can be pictured like this (for room 12 which connects to rooms 11, 13 and 16, and has a Bat but no Pit or Wumpus), and an entire cave system can be pictured as (with most rooms left out and only the details for room 12 shown), The remaining classes are relatively straightforward compared to these first two.","title":"class Room"},{"location":"10_OOD/11_Class_Pit/","text":"class Pit We'll write our remaining classes from simplest to most complex. You'll recall that a pit has one attribute, location , and just one method, swallow . In Python: In a modern graphic game a Pit 's swallow method would trigger some fabulous animation of the player tumbling downward, but since this is text-based we have to settle for saying what is happening, and leaving the special effects to the user's imagination.","title":"class Pit"},{"location":"10_OOD/11_Class_Pit/#class-pit","text":"We'll write our remaining classes from simplest to most complex. You'll recall that a pit has one attribute, location , and just one method, swallow . In Python: In a modern graphic game a Pit 's swallow method would trigger some fabulous animation of the player tumbling downward, but since this is text-based we have to settle for saying what is happening, and leaving the special effects to the user's imagination.","title":"class Pit"},{"location":"10_OOD/12_Class_Bat/","text":"class Bat Like Pit s, Bat s have one attribute, location , and one method called snatch . Snatching is a little more involved than swallowing. The bat has to move the player to a new randomly chosen room, and then flap off to another randomly chosen room. We will correct the bug shortly. In the meantime you might want to think about it and see if you can determine what the bug is.","title":"class Bat"},{"location":"10_OOD/12_Class_Bat/#class-bat","text":"Like Pit s, Bat s have one attribute, location , and one method called snatch . Snatching is a little more involved than swallowing. The bat has to move the player to a new randomly chosen room, and then flap off to another randomly chosen room. We will correct the bug shortly. In the meantime you might want to think about it and see if you can determine what the bug is.","title":"class Bat"},{"location":"10_OOD/13_Class_Wumpus/","text":"class Wumpus The Wumpus is not unlike the Bat s: a location attribute, and a single method, this time called wake_up . Hopefully the comments are self-explanatory.","title":"class Wumpus"},{"location":"10_OOD/13_Class_Wumpus/#class-wumpus","text":"The Wumpus is not unlike the Bat s: a location attribute, and a single method, this time called wake_up . Hopefully the comments are self-explanatory.","title":"class Wumpus"},{"location":"10_OOD/14_Class_Player/","text":"class Player Like the other objects in the cave system Player s have locations. They also have two methods: they can move and they can shoot arrows. Note that the move method receives an argument saying what room to move to, but it doesn't blindly trust the argument to be valid and instead checks that the destination room is linked to the current room.","title":"class Player"},{"location":"10_OOD/14_Class_Player/#class-player","text":"Like the other objects in the cave system Player s have locations. They also have two methods: they can move and they can shoot arrows. Note that the move method receives an argument saying what room to move to, but it doesn't blindly trust the argument to be valid and instead checks that the destination room is linked to the current room.","title":"class Player"},{"location":"10_OOD/15_Putting_the_pieces_together/","text":"Putting the pieces together If you gather together the pieces we have written so far, and add a little glue code to the main routine, you have a program that will run. This is the longest program in the course so take some time to read it over. You'll notice that there is: some new code (whose details I'll explain), some bugs (that you'll be correcting as part of the assignment!), and a few pieces that are missing (that you'll be adding as part of the assignment).","title":"Putting the pieces together"},{"location":"10_OOD/15_Putting_the_pieces_together/#putting-the-pieces-together","text":"If you gather together the pieces we have written so far, and add a little glue code to the main routine, you have a program that will run. This is the longest program in the course so take some time to read it over. You'll notice that there is: some new code (whose details I'll explain), some bugs (that you'll be correcting as part of the assignment!), and a few pieces that are missing (that you'll be adding as part of the assignment).","title":"Putting the pieces together"},{"location":"10_OOD/16_New_code_initializing_the_bats/","text":"New code: Initializing the bats # Initialize Bats. NUMBATS = 2 for bat in range(NUMBATS): room = random.choice(cave_system.rooms) # Now check if we have already put a bat in this room, while room.has_bat(): # and if we have pick another room. room = random.choice(cave_system.rooms) room.bat = Bat(room.number) You'll notice there's some new code to initialize the bats. Its job is to place two bats in two different randomly chosen rooms. It does this by choosing a room at random and checking to see if there is already a bat in it. If there is, it chooses another and keeps on doing so until it finds a room unoccupied by a bat. Once it has a room without a bat, it creates a bat and places it there. Notes: The \"magic number\" 2 has been assigned to the symbolic constant NUMBATS so the number of bats can be changed by changing a single line of code. The jargon for this is to say that the number of bats has been parameterized . The method random.choice may be new to you (I can't remember if I have used it before). It chooses an item at random from a list. It offers a compact alternative to: room = cave_system.rooms[random.randint(0, len(cave_system.rooms) - 1)]","title":"New code: Initializing the bats"},{"location":"10_OOD/16_New_code_initializing_the_bats/#new-code-initializing-the-bats","text":"# Initialize Bats. NUMBATS = 2 for bat in range(NUMBATS): room = random.choice(cave_system.rooms) # Now check if we have already put a bat in this room, while room.has_bat(): # and if we have pick another room. room = random.choice(cave_system.rooms) room.bat = Bat(room.number) You'll notice there's some new code to initialize the bats. Its job is to place two bats in two different randomly chosen rooms. It does this by choosing a room at random and checking to see if there is already a bat in it. If there is, it chooses another and keeps on doing so until it finds a room unoccupied by a bat. Once it has a room without a bat, it creates a bat and places it there. Notes: The \"magic number\" 2 has been assigned to the symbolic constant NUMBATS so the number of bats can be changed by changing a single line of code. The jargon for this is to say that the number of bats has been parameterized . The method random.choice may be new to you (I can't remember if I have used it before). It chooses an item at random from a list. It offers a compact alternative to: room = cave_system.rooms[random.randint(0, len(cave_system.rooms) - 1)]","title":"New code: Initializing the bats"},{"location":"10_OOD/17_New_code_pointing_to_a_missing_class_shoot_and_arrows/","text":"New code (pointing to a missing class): shoot and Arrow s Some detail has been added to the Player.shoot method compared to the pseudocode. First, inside the Player class we have the method, def shoot(self): roomlist = input('What rooms [a, b, c]? ') self.arrows = self.arrows - 1 print 'Shooting...' # Uncomment the next line when you are ready to add the code it requires. # The return below it is a temporary statement to allow the program # to execute. # return Arrow(self.location, roomlist).fly() return MISS The shoot method will get the list of rooms for the arrow to fly through from the user, decrement the number of arrows left by 1, and then create an Arrow object and tell it to fly . Note that the line Arrow(self.location, roomlist).fly() does two things. First it creates an Arrow object with Arrow(self.location, roomlist) , and then it immediately sends it the message to fly with the appended .fly() . This line is commented out at the moment since it would just throw an error because there is no class Arrow (you will be creating it as part of the assignment). To make the code runnable I have simply added an artificial return statement that returns a legal value of MISS . MISS is one of three values that the fly method can return; the other two are HIT and OOPS . These three values correspond to the three possible outcomes of shooting an arrow: you could hit the wumpus ( HIT ), miss the wumpus ( MISS ), or shoot yourself ( OOPS ). Shooting yourself can happen either if you include your current room in your flight path (not too likely) or if you include unconnected rooms in your flight path. In the latter case the arrow will begin to fly randomly and may come back at you and hit you. The constants are assigned by the statement, (HIT, OOPS, MISS) = range(3) # Possible outcomes of shooting an arrow. The section of the main routine handling shooting was expanded to deal with each possible return value appropriately, elif action == 's': outcome = player.shoot() if outcome == HIT: print('You hit the wumpus! You win!') game_over = True elif outcome == OOPS: print('Ouch! You shot yourself!') game_over = True elif outcome == MISS: print('I\\'m afraid the Wumpus wasn\\'t in any of those rooms.') print('You wasted your arrow.')","title":"New code (pointing to a missing class):\u00a0shoot\u00a0and\u00a0Arrows"},{"location":"10_OOD/17_New_code_pointing_to_a_missing_class_shoot_and_arrows/#new-code-pointing-to-a-missing-class-shoot-and-arrows","text":"Some detail has been added to the Player.shoot method compared to the pseudocode. First, inside the Player class we have the method, def shoot(self): roomlist = input('What rooms [a, b, c]? ') self.arrows = self.arrows - 1 print 'Shooting...' # Uncomment the next line when you are ready to add the code it requires. # The return below it is a temporary statement to allow the program # to execute. # return Arrow(self.location, roomlist).fly() return MISS The shoot method will get the list of rooms for the arrow to fly through from the user, decrement the number of arrows left by 1, and then create an Arrow object and tell it to fly . Note that the line Arrow(self.location, roomlist).fly() does two things. First it creates an Arrow object with Arrow(self.location, roomlist) , and then it immediately sends it the message to fly with the appended .fly() . This line is commented out at the moment since it would just throw an error because there is no class Arrow (you will be creating it as part of the assignment). To make the code runnable I have simply added an artificial return statement that returns a legal value of MISS . MISS is one of three values that the fly method can return; the other two are HIT and OOPS . These three values correspond to the three possible outcomes of shooting an arrow: you could hit the wumpus ( HIT ), miss the wumpus ( MISS ), or shoot yourself ( OOPS ). Shooting yourself can happen either if you include your current room in your flight path (not too likely) or if you include unconnected rooms in your flight path. In the latter case the arrow will begin to fly randomly and may come back at you and hit you. The constants are assigned by the statement, (HIT, OOPS, MISS) = range(3) # Possible outcomes of shooting an arrow. The section of the main routine handling shooting was expanded to deal with each possible return value appropriately, elif action == 's': outcome = player.shoot() if outcome == HIT: print('You hit the wumpus! You win!') game_over = True elif outcome == OOPS: print('Ouch! You shot yourself!') game_over = True elif outcome == MISS: print('I\\'m afraid the Wumpus wasn\\'t in any of those rooms.') print('You wasted your arrow.')","title":"New code (pointing to a missing class):\u00a0shoot\u00a0and\u00a0Arrows"},{"location":"10_OOD/18_New_code_show_cheats/","text":"New code: show_cheats() You'll also notice that a stand alone function called show_cheats has been added. Hunt the Wumpus is very time-consuming to debug efficiently unless you know where the hazards are so you can go straight to them and see if your program handles them properly. show_cheats has been included to give you that information. It tells you where the wumpus, bats, and pits are so you can head toward (or away!) from them during testing. def show_cheats(): '''Shows information about the cave system to ease debugging. Should be disabled in the final version.''' print 'Psst!' for room in cave_system.rooms: if room.has_bat(): print ' There\\'s a bat in room', room.number if room.has_pit(): print ' There\\'s a pit in room', room.number if room.has_wumpus(): print ' There\\'s a wumpus in room', room.number","title":"New code:\u00a0show_cheats()"},{"location":"10_OOD/18_New_code_show_cheats/#new-code-show_cheats","text":"You'll also notice that a stand alone function called show_cheats has been added. Hunt the Wumpus is very time-consuming to debug efficiently unless you know where the hazards are so you can go straight to them and see if your program handles them properly. show_cheats has been included to give you that information. It tells you where the wumpus, bats, and pits are so you can head toward (or away!) from them during testing. def show_cheats(): '''Shows information about the cave system to ease debugging. Should be disabled in the final version.''' print 'Psst!' for room in cave_system.rooms: if room.has_bat(): print ' There\\'s a bat in room', room.number if room.has_pit(): print ' There\\'s a pit in room', room.number if room.has_wumpus(): print ' There\\'s a wumpus in room', room.number","title":"New code:\u00a0show_cheats()"},{"location":"10_OOD/19_New_code_display_status_and_warnings/","text":"New code: Display status and warnings It wasn't shown in the pseudocode to save space, but we need to display the status of the game after each move so the player can plan what to do, and we need to issue the appropriate warnings when we get close to a hazard. This is done by this code just inside the main event loop: # Display status: print(cave_system) print('You are in room', player.location) print('You have', player.arrows, 'arrows left.') # Display warnings: for room_number in cave_system.rooms[player.location].tunnels: if cave_system.rooms[room_number].has_pit(): print('I feel a draft!') if cave_system.rooms[room_number].has_wumpus(): print('I smell a wumpus!') if cave_system.rooms[room_number].has_bat(): print('Bats nearby!') It displays the whole cave system and reminds the player where they are and how many arrows they have left. The warnings code loops through the rooms connected by tunnels to this one. It checks whether each one has a pit, a wumpus, or a bat and displays the appropriate warning. Note that since a room can have more than one hazard this code needs to use separate if statements rather an if followed by elif s.","title":"New code: Display status and warnings"},{"location":"10_OOD/19_New_code_display_status_and_warnings/#new-code-display-status-and-warnings","text":"It wasn't shown in the pseudocode to save space, but we need to display the status of the game after each move so the player can plan what to do, and we need to issue the appropriate warnings when we get close to a hazard. This is done by this code just inside the main event loop: # Display status: print(cave_system) print('You are in room', player.location) print('You have', player.arrows, 'arrows left.') # Display warnings: for room_number in cave_system.rooms[player.location].tunnels: if cave_system.rooms[room_number].has_pit(): print('I feel a draft!') if cave_system.rooms[room_number].has_wumpus(): print('I smell a wumpus!') if cave_system.rooms[room_number].has_bat(): print('Bats nearby!') It displays the whole cave system and reminds the player where they are and how many arrows they have left. The warnings code loops through the rooms connected by tunnels to this one. It checks whether each one has a pit, a wumpus, or a bat and displays the appropriate warning. Note that since a room can have more than one hazard this code needs to use separate if statements rather an if followed by elif s.","title":"New code: Display status and warnings"},{"location":"10_OOD/20_Memory_diagram/","text":"Memory diagram To understand the bat snatching bugs you will need to understand how the program objects are related in memory. Hopefully this diagram will help with that. Many lines have been left off the diagram to keep it readable, but at least one connection of each type is shown. It is important to understand the difference between the solid lines and the dotted lines. The solid lines represent a standard Python object reference where a name directly refers to an object. The dotted lines show where it is possible to make an indirect reference by using a list index number, i.e. to use the number to access the object by using the number as an index into the list cave_system.rooms . In both cases the object at the end of the arrow can be referenced, the difference is whether it requires a subscript to do it or not. The symbol, \u23da, is used to signify None , i.e. that the object reference is undefined. One striking feature of the diagram is that only two objects in it have names, cave_system and player , and all the others are referenced through cave_system . That is one reason it is forgivable to have cave_system as a global variable in our program: it is effectively the single point of access for all the objects.","title":"Memory diagram"},{"location":"10_OOD/20_Memory_diagram/#memory-diagram","text":"To understand the bat snatching bugs you will need to understand how the program objects are related in memory. Hopefully this diagram will help with that. Many lines have been left off the diagram to keep it readable, but at least one connection of each type is shown. It is important to understand the difference between the solid lines and the dotted lines. The solid lines represent a standard Python object reference where a name directly refers to an object. The dotted lines show where it is possible to make an indirect reference by using a list index number, i.e. to use the number to access the object by using the number as an index into the list cave_system.rooms . In both cases the object at the end of the arrow can be referenced, the difference is whether it requires a subscript to do it or not. The symbol, \u23da, is used to signify None , i.e. that the object reference is undefined. One striking feature of the diagram is that only two objects in it have names, cave_system and player , and all the others are referenced through cave_system . That is one reason it is forgivable to have cave_system as a global variable in our program: it is effectively the single point of access for all the objects.","title":"Memory diagram"},{"location":"10_OOD/21_Bug_fixing_mostly_snatch/","text":"Bug: Fixing (mostly) snatch Now keeping the memory diagram open in another window, or perhaps at your side in print form, let's consider the bug identified in the original Bat.snatch method. The code is this, This seems sensible. Remember that self is a Bat , so the line says to change self 's location attribute to a random room number. There is nothing wrong with this as far as it goes , but more needs to be done. Look at Room 12 in the diagram which contains a Bat . Suppose the Bat 's new location is Room 8. If we only change the Bat's location attribute to be 8, then Room 12 will still think it has a Bat in it (see the arrow from Room 12's bat attribute?) and Room 8 won't know it now has a Bat in it because we haven't assigned it one. So in addition to changing the Bat 's location attribute to 8 we need to change Room 12's bat attribute to None , and Room 8s bat attribute to reference this Bat object. In visual terms we are starting with this, and only ending up with this, but we need to end up with this, The new code does that, Another Bug Another smaller less subtle bug remains. When the bat's new room is chosen it shouldn't be a room with a Bat already in it, nor should it be the room it has just dropped the player in (which will happen approximately 1 in 20 times since we are choosing randomly). Fixing this secondary bug will be part of your assignment.","title":"Bug: Fixing (mostly) snatch"},{"location":"10_OOD/21_Bug_fixing_mostly_snatch/#bug-fixing-mostly-snatch","text":"Now keeping the memory diagram open in another window, or perhaps at your side in print form, let's consider the bug identified in the original Bat.snatch method. The code is this, This seems sensible. Remember that self is a Bat , so the line says to change self 's location attribute to a random room number. There is nothing wrong with this as far as it goes , but more needs to be done. Look at Room 12 in the diagram which contains a Bat . Suppose the Bat 's new location is Room 8. If we only change the Bat's location attribute to be 8, then Room 12 will still think it has a Bat in it (see the arrow from Room 12's bat attribute?) and Room 8 won't know it now has a Bat in it because we haven't assigned it one. So in addition to changing the Bat 's location attribute to 8 we need to change Room 12's bat attribute to None , and Room 8s bat attribute to reference this Bat object. In visual terms we are starting with this, and only ending up with this, but we need to end up with this, The new code does that,","title":"Bug: Fixing (mostly) snatch"},{"location":"10_OOD/21_Bug_fixing_mostly_snatch/#another-bug","text":"Another smaller less subtle bug remains. When the bat's new room is chosen it shouldn't be a room with a Bat already in it, nor should it be the room it has just dropped the player in (which will happen approximately 1 in 20 times since we are choosing randomly). Fixing this secondary bug will be part of your assignment.","title":"Another Bug"},{"location":"10_OOD/22_Aside_Data_structure_maintenance/","text":"Aside: Data structure maintenance Fixing the Bat snatch method gives a nice example of a change of emphasis in our programming. Early in the course the emphasis was on figuring out algorithms, e.g. simulating the game of craps, where the challenge was dealing with the intricacy of the algorithm. Now there is a new challenge: maintaining the integrity of intricate data structures. The key to doing this successfully is to be aware of the meaning of the connections between objects and of the implications of object actions on those connections. I find all but the simplest data structures difficult to visualize just by looking at the code that creates them so I draw diagrams like the ones in this module to help me see what manipulations need to be done. You may want to too.","title":"Aside: Data structure maintenance"},{"location":"10_OOD/22_Aside_Data_structure_maintenance/#aside-data-structure-maintenance","text":"Fixing the Bat snatch method gives a nice example of a change of emphasis in our programming. Early in the course the emphasis was on figuring out algorithms, e.g. simulating the game of craps, where the challenge was dealing with the intricacy of the algorithm. Now there is a new challenge: maintaining the integrity of intricate data structures. The key to doing this successfully is to be aware of the meaning of the connections between objects and of the implications of object actions on those connections. I find all but the simplest data structures difficult to visualize just by looking at the code that creates them so I draw diagrams like the ones in this module to help me see what manipulations need to be done. You may want to too.","title":"Aside: Data structure maintenance"},{"location":"10_OOD/23_Two_more_small_problems/","text":"Two more (small) problems Bug: Wumpus movement The Wumpus position is not updated properly after moving for the same reason that Bat s' movements were not properly updating. Fixing this will be part of your assignment. Missing Piece: Initialize Pit s You have probably noticed that although the Bat s and Wumpus are initialized, the Pit s are not. Adding this is another part of your assignment.","title":"Two more (small) problems"},{"location":"10_OOD/23_Two_more_small_problems/#two-more-small-problems","text":"","title":"Two more (small) problems"},{"location":"10_OOD/23_Two_more_small_problems/#bug-wumpus-movement","text":"The Wumpus position is not updated properly after moving for the same reason that Bat s' movements were not properly updating. Fixing this will be part of your assignment.","title":"Bug: Wumpus movement"},{"location":"10_OOD/23_Two_more_small_problems/#missing-piece-initialize-pits","text":"You have probably noticed that although the Bat s and Wumpus are initialized, the Pit s are not. Adding this is another part of your assignment.","title":"Missing Piece: Initialize\u00a0Pits"},{"location":"10_OOD/24_Howd_we_do/","text":"How'd we do? We are going to stop working on our Hunt the Wumpus game at this point, but this isn't to say it is completely done. Quite apart from game features we might add (see the assignment for some ideas), the OO design is not as polished as it could be. If you look again at the memory diagram of our objects you will see both solid and dotted lines. Generally 1 a direct reference (solid line) is preferred to an indirect one (dotted line). There are some dotted lines here we could replace with solid ones. For example the tunnels attributes could be lists of direct references to Room objects rather than lists of room numbers. This would simplify the syntax of using them and is semantically more accurate, but it makes initializing the cave system quite a bit trickier. Likewise, the hazard and Player location attributes could contain direct references to their respective Room objects rather than room numbers that have to be used as indices to indirectly access the rooms, but there are some initial complications in setting that up too. In sum our design may not be as OOPy as it could be, but it is as OOPy as we had the time and the skills to make it. The word generally here should signal to you that there are situations in which the indirect references are preferred as indeed there are, but you won't go wrong on the kinds of problems you will encounter in this course preferring direct references. \u21a9","title":"How'd we do?"},{"location":"10_OOD/24_Howd_we_do/#howd-we-do","text":"We are going to stop working on our Hunt the Wumpus game at this point, but this isn't to say it is completely done. Quite apart from game features we might add (see the assignment for some ideas), the OO design is not as polished as it could be. If you look again at the memory diagram of our objects you will see both solid and dotted lines. Generally 1 a direct reference (solid line) is preferred to an indirect one (dotted line). There are some dotted lines here we could replace with solid ones. For example the tunnels attributes could be lists of direct references to Room objects rather than lists of room numbers. This would simplify the syntax of using them and is semantically more accurate, but it makes initializing the cave system quite a bit trickier. Likewise, the hazard and Player location attributes could contain direct references to their respective Room objects rather than room numbers that have to be used as indices to indirectly access the rooms, but there are some initial complications in setting that up too. In sum our design may not be as OOPy as it could be, but it is as OOPy as we had the time and the skills to make it. The word generally here should signal to you that there are situations in which the indirect references are preferred as indeed there are, but you won't go wrong on the kinds of problems you will encounter in this course preferring direct references. \u21a9","title":"How'd we do?"},{"location":"10_OOD/90_Assignment_10/","text":"Assignment 10 Problems Complete the code given in this module to create a working Hunt the Wumpus program, i.e. you should fix the bugs and add the necessary new code. Make as few changes to the code as possible. Ideally you will just make additions to it. The file wumpus_4_partial.py will save you some typing (but doesn't contain all the code shown in wumpus_4.py, you'll need to enter some of it yourself). Add two more cave systems to your Hunt the Wumpus game. It should have different cave connection patterns with different numbers of rooms. The cave system to be used should be chosen at random when the game is begun. Add one of the following features to Hunt the Wumpus, e.g. Add a new hazard type, e.g. riddlesand, like quicksand you sink into it, but you can save yourself if you can guess the secret number (from 1 to 10) in three tries. Add extra arrows in some of the rooms that get automatically added to your quiver when you enter the room. Have the Wumpus start out sleepy with a 0.75 chance of being startled and running away, but as the game progresses have the Wumpus become more alert and more likely to eat the player. Have the Wumpus move toward the player on each turn. This is a way of having it hunt the player, the challenge is figuring out which way is \"towards\". Multiple players A limited number of moves in which to finish the game A spring of visions that answers questions about the location of hazards. Your mark will reflect the scope of your additions, and the quality of your code. Be sure to describe the changes in your comments so I do not overlook them when I run your program, and be sure to add any \"cheat\" information needed to make them easy to test. Logistics Use the following naming scheme for your program file: a assignment# yourname .py . So your code for this assignment will be named a10bob.py (adjusted obviously to use your name). Please submit your .py file to the Moodle dropbox.","title":"Assignment 10"},{"location":"10_OOD/90_Assignment_10/#assignment-10","text":"","title":"Assignment 10"},{"location":"10_OOD/90_Assignment_10/#problems","text":"Complete the code given in this module to create a working Hunt the Wumpus program, i.e. you should fix the bugs and add the necessary new code. Make as few changes to the code as possible. Ideally you will just make additions to it. The file wumpus_4_partial.py will save you some typing (but doesn't contain all the code shown in wumpus_4.py, you'll need to enter some of it yourself). Add two more cave systems to your Hunt the Wumpus game. It should have different cave connection patterns with different numbers of rooms. The cave system to be used should be chosen at random when the game is begun. Add one of the following features to Hunt the Wumpus, e.g. Add a new hazard type, e.g. riddlesand, like quicksand you sink into it, but you can save yourself if you can guess the secret number (from 1 to 10) in three tries. Add extra arrows in some of the rooms that get automatically added to your quiver when you enter the room. Have the Wumpus start out sleepy with a 0.75 chance of being startled and running away, but as the game progresses have the Wumpus become more alert and more likely to eat the player. Have the Wumpus move toward the player on each turn. This is a way of having it hunt the player, the challenge is figuring out which way is \"towards\". Multiple players A limited number of moves in which to finish the game A spring of visions that answers questions about the location of hazards. Your mark will reflect the scope of your additions, and the quality of your code. Be sure to describe the changes in your comments so I do not overlook them when I run your program, and be sure to add any \"cheat\" information needed to make them easy to test.","title":"Problems"},{"location":"10_OOD/90_Assignment_10/#logistics","text":"Use the following naming scheme for your program file: a assignment# yourname .py . So your code for this assignment will be named a10bob.py (adjusted obviously to use your name). Please submit your .py file to the Moodle dropbox.","title":"Logistics"},{"location":"11_OOP2_Polymorphism_and_Inheritance/","text":"Introduction: The rest of OOP \ud83d\ude0e And now the course begins to wind down... Last week's Wumpus program is the largest one we'll work on this term at around 400 lines of code. You've come a long way from the early weeks of the course when getting a dozen lines right could be challenging. This week we'll finish off the remaining two parts of OOP: inheritance and polymorphism. Inheritance is a fairly straightforward idea and is achieved with just one small syntactic addition. Adding inheritance to large programs often means getting to delete lots of code, so programs become shorter and clearer: win-win! To explore inheritance we'll revisit playing cards. Polymorphism isn't difficult to understand, but implementing it often involves adding lots of code. Fortunately that code is largely boilerplate, as opposed to subtle algorithms, and the benefit is that we can make our types look like built-in types by using operators like + and * to combine them. Our example for polymorphism is fairly pedestrian, fractions, so we can keep it simple and focus on the new syntactic elements polymorphism uses. Inheritance and Polymorphism Inheritance example: Playing Cards class CardCollection class Deck class Hand Putting the pieces together Aside: Refactoring Polymorphism Example: Fractions Reverse engineering class Fraction Example: Playing cards A subtle point: Semantics Conclusion: Adding Types","title":"Introduction: The rest of OOP \ud83d\ude0e"},{"location":"11_OOP2_Polymorphism_and_Inheritance/#introduction-the-rest-of-oop","text":"And now the course begins to wind down... Last week's Wumpus program is the largest one we'll work on this term at around 400 lines of code. You've come a long way from the early weeks of the course when getting a dozen lines right could be challenging. This week we'll finish off the remaining two parts of OOP: inheritance and polymorphism. Inheritance is a fairly straightforward idea and is achieved with just one small syntactic addition. Adding inheritance to large programs often means getting to delete lots of code, so programs become shorter and clearer: win-win! To explore inheritance we'll revisit playing cards. Polymorphism isn't difficult to understand, but implementing it often involves adding lots of code. Fortunately that code is largely boilerplate, as opposed to subtle algorithms, and the benefit is that we can make our types look like built-in types by using operators like + and * to combine them. Our example for polymorphism is fairly pedestrian, fractions, so we can keep it simple and focus on the new syntactic elements polymorphism uses. Inheritance and Polymorphism Inheritance example: Playing Cards class CardCollection class Deck class Hand Putting the pieces together Aside: Refactoring Polymorphism Example: Fractions Reverse engineering class Fraction Example: Playing cards A subtle point: Semantics Conclusion: Adding Types","title":"Introduction: The rest of OOP \ud83d\ude0e"},{"location":"11_OOP2_Polymorphism_and_Inheritance/01_Inheritance_and_polymorphism/","text":"Inheritance and Polymorphism Of OOP's three defining traits, encapsulation, inheritance and polymorphism, we have so far concentrated on encapsulation. In this module we will turn our attention to inheritance and polymorphism. Recall that inheritance enables one class to inherit the characteristics of another one (where by characteristics we mean attributes and methods). Polymorphism refers to the ability of the same operation to trigger different behaviours in different contexts, or in syntactic terms for the same operator, e.g. + , to do different things to different object types.","title":"Inheritance and Polymorphism"},{"location":"11_OOP2_Polymorphism_and_Inheritance/01_Inheritance_and_polymorphism/#inheritance-and-polymorphism","text":"Of OOP's three defining traits, encapsulation, inheritance and polymorphism, we have so far concentrated on encapsulation. In this module we will turn our attention to inheritance and polymorphism. Recall that inheritance enables one class to inherit the characteristics of another one (where by characteristics we mean attributes and methods). Polymorphism refers to the ability of the same operation to trigger different behaviours in different contexts, or in syntactic terms for the same operator, e.g. + , to do different things to different object types.","title":"Inheritance and Polymorphism"},{"location":"11_OOP2_Polymorphism_and_Inheritance/02_Inheritance_example_playing_cards/","text":"Inheritance example: Playing Cards Think back to our earlier Deck and Hand playing card classes. While there are obvious differences between decks of cards and hands of cards there are also similarities. Let's focus on the similarities for a moment. Both of them are collections of the same kind of object, i.e. playing cards. Both need to be displayed, and in quite similar ways. At times we remove cards from both of them, and at other times we add cards to them. Finally we can ask how many cards are in each of them. OOP recommends that we remove this common functionality from both Deck and Hand to a separate base class and have our Deck and Hand classes inherit this functionality from it. This way if we need to modify some part of it, e.g. the card list representation, we get to do it in a single place and the changes will be automatically propagated to the descendant classes. It's a small win in a shallow hierarchy like this one, but it's a huge win when the hierarchy is deep because then we get to make a change in one place rather than dozens. Here's how this is done in Python.","title":"Inheritance example: Playing Cards"},{"location":"11_OOP2_Polymorphism_and_Inheritance/02_Inheritance_example_playing_cards/#inheritance-example-playing-cards","text":"Think back to our earlier Deck and Hand playing card classes. While there are obvious differences between decks of cards and hands of cards there are also similarities. Let's focus on the similarities for a moment. Both of them are collections of the same kind of object, i.e. playing cards. Both need to be displayed, and in quite similar ways. At times we remove cards from both of them, and at other times we add cards to them. Finally we can ask how many cards are in each of them. OOP recommends that we remove this common functionality from both Deck and Hand to a separate base class and have our Deck and Hand classes inherit this functionality from it. This way if we need to modify some part of it, e.g. the card list representation, we get to do it in a single place and the changes will be automatically propagated to the descendant classes. It's a small win in a shallow hierarchy like this one, but it's a huge win when the hierarchy is deep because then we get to make a change in one place rather than dozens. Here's how this is done in Python.","title":"Inheritance example: Playing Cards"},{"location":"11_OOP2_Polymorphism_and_Inheritance/03_Class_Card_Collection/","text":"class CardCollection First we define our base class that contains the functionality common to collections of cards: class CardCollection: def __init__(self): self.cards = [] def size(self): return len(self.cards) def add(self, card): self.cards.append(card) def remove(self): return self.cards.pop() def __str__(self): return ', '.join( str(card) for card in self.cards ) Everything here should be familiar: The attributes and methods have just been extracted from our earlier Deck and Hand classes.","title":"class CardCollection"},{"location":"11_OOP2_Polymorphism_and_Inheritance/03_Class_Card_Collection/#class-cardcollection","text":"First we define our base class that contains the functionality common to collections of cards: class CardCollection: def __init__(self): self.cards = [] def size(self): return len(self.cards) def add(self, card): self.cards.append(card) def remove(self): return self.cards.pop() def __str__(self): return ', '.join( str(card) for card in self.cards ) Everything here should be familiar: The attributes and methods have just been extracted from our earlier Deck and Hand classes.","title":"class CardCollection"},{"location":"11_OOP2_Polymorphism_and_Inheritance/04_Class_Deck/","text":"class Deck Now we define our Deck and Hand classes by inheriting from this CardCollection base class. The mechanism to show inheritance in Python is simply to include the base class name in parentheses after the derived class name, 1 class Deck(CardCollection): 2 # Override ancestor's constructor, i.e. replace the default. 3 def __init__(self): 4 self.cards = [] 5 for cardnum in range(52): 6 self.add( Card(cardnum) ) 7 8 # Alias the inherited method \"size\" as \"cards_left\", 9 # because we usually ask how many cards are left in a 10 # deck rather than asking about its size. 11 def cards_left(self): 12 return self.size() 13 14 # Another alias. When using a deck of cards we talk about \"dealing\" 15 # cards not \"removing\" them from the deck. 16 def deal(self): 17 return self.remove() 18 19 # Add a new method, shuffle, that does not exist in ancestor class. 20 def shuffle(self): 21 for i in range( 2*self.size() ): 22 self.cards.insert(random.randrange(len(self.cards)), self.cards.pop()) This example shows most of what you can do with inheritance: \u2192 line 1 The syntax to define a class Deck that inherits from the class CardCollection . Jargon: Deck is the derived or descendant class; CardCollection is the base class , superclass or ancestor class . \u2192 lines 3-6 Replace a method from the base class with a customized version. This is just done by redefining the method, i.e. if you use the same name in the derived class it hides the version in the base class. The jargon for this is specialization because we specialize the operation of the method for our derived class' characteristics. \u2192 lines 11-12 We provide an \"alias\", i.e. a more meaningful name, for a method in the base class. In this case we can refer to cards_left() instead of size() . Note that this is not a re naming; it is providing a second name . We can still access the method size() if we wish. \u2192 lines 16-17 Another alias, this time allowing us to refer to the method remove by the name deal . \u2192 lines 20-22 We can add new methods in the derived class that do not exist in the base class. In this case we add a shuffle method to our derived class. Note that inheritance is one way: we cannot call the shuffle method on a CardCollection object only on a Deck object. The jargon for this is augmentation since we are augmenting the functionality of our base class.","title":"class Deck"},{"location":"11_OOP2_Polymorphism_and_Inheritance/04_Class_Deck/#class-deck","text":"Now we define our Deck and Hand classes by inheriting from this CardCollection base class. The mechanism to show inheritance in Python is simply to include the base class name in parentheses after the derived class name, 1 class Deck(CardCollection): 2 # Override ancestor's constructor, i.e. replace the default. 3 def __init__(self): 4 self.cards = [] 5 for cardnum in range(52): 6 self.add( Card(cardnum) ) 7 8 # Alias the inherited method \"size\" as \"cards_left\", 9 # because we usually ask how many cards are left in a 10 # deck rather than asking about its size. 11 def cards_left(self): 12 return self.size() 13 14 # Another alias. When using a deck of cards we talk about \"dealing\" 15 # cards not \"removing\" them from the deck. 16 def deal(self): 17 return self.remove() 18 19 # Add a new method, shuffle, that does not exist in ancestor class. 20 def shuffle(self): 21 for i in range( 2*self.size() ): 22 self.cards.insert(random.randrange(len(self.cards)), self.cards.pop()) This example shows most of what you can do with inheritance: \u2192 line 1 The syntax to define a class Deck that inherits from the class CardCollection . Jargon: Deck is the derived or descendant class; CardCollection is the base class , superclass or ancestor class . \u2192 lines 3-6 Replace a method from the base class with a customized version. This is just done by redefining the method, i.e. if you use the same name in the derived class it hides the version in the base class. The jargon for this is specialization because we specialize the operation of the method for our derived class' characteristics. \u2192 lines 11-12 We provide an \"alias\", i.e. a more meaningful name, for a method in the base class. In this case we can refer to cards_left() instead of size() . Note that this is not a re naming; it is providing a second name . We can still access the method size() if we wish. \u2192 lines 16-17 Another alias, this time allowing us to refer to the method remove by the name deal . \u2192 lines 20-22 We can add new methods in the derived class that do not exist in the base class. In this case we add a shuffle method to our derived class. Note that inheritance is one way: we cannot call the shuffle method on a CardCollection object only on a Deck object. The jargon for this is augmentation since we are augmenting the functionality of our base class.","title":"class Deck"},{"location":"11_OOP2_Polymorphism_and_Inheritance/05_Class_Hand/","text":"class Hand The code for the Hand class may surprise you: class Hand(CardCollection): pass It is so short because Hand objects do not have any extra methods that CardCollection s do not, nor do they need to customize any CardCollection methods. In fact with the code above Hand is effectively an alias for CardCollection .","title":"class Hand"},{"location":"11_OOP2_Polymorphism_and_Inheritance/05_Class_Hand/#class-hand","text":"The code for the Hand class may surprise you: class Hand(CardCollection): pass It is so short because Hand objects do not have any extra methods that CardCollection s do not, nor do they need to customize any CardCollection methods. In fact with the code above Hand is effectively an alias for CardCollection .","title":"class Hand"},{"location":"11_OOP2_Polymorphism_and_Inheritance/06_Putting_the_pieces_together/","text":"Putting the pieces together Here's a module that combines the new CardCollection , Deck and Hand classes with our earlier Card class and a main routine that exercises them a little. Try it out. # playing_cards_5.py import random class Card: face_values = ['A','2','3','4','5','6','7','8','9','T','J','Q','K'] suits = ['Clubs','Diamonds','Hearts','Spades'] def __init__(self, cardnum): self.number = cardnum def __str__(self): return self.face_value() + ' of ' + self.suit() def face_value(self): return Card.face_values[ self.number % 13 ] def suit( self ): return Card.suits[ self.number // 13 ] class CardCollection: def __init__(self): self.cards = [] def size(self): return len(self.cards) def add(self, card): self.cards.append(card) def remove(self): return self.cards.pop() def __str__(self): return ', '.join( str(card) for card in self.cards ) class Deck(CardCollection): # Override ancestor's constructor, i.e. replace the default. def __init__(self): self.cards = [] for cardnum in range(52): self.add( Card(cardnum) ) # Alias the inherited method \"size\" as \"cards_left\", # because we usually ask how many cards are left in a # deck rather than asking about its size. def cards_left(self): return self.size() # Another alias. When using a deck of cards we talk about \"dealing\" # cards not \"removing\" them from the deck. def deal(self): return self.remove() # Add a new method, shuffle, that does not exist in ancestor class. def shuffle(self): for i in range( 2*self.size() ): self.cards.insert(random.randrange(len(self.cards)), self.cards.pop()) class Hand(CardCollection): pass if __name__ == '__main__': print('==================') print('Testing Card class') print('------------------') print() print('Your card number is 42.') c = Card(42) print('It\\'s face value is:', c.face_value()) print('It\\'s suit is:', c.suit()) print('It\\'s printable representation is:', c) print() print('==================') print('Testing Deck class') print('------------------') print() print('Creating a new Deck...') print() d = Deck() print('The deck\\'s printable representation:') print(d) print() print('Shuffling the deck...') d.shuffle() print('The deck after shuffling:') print(d) print() print('The deck has', d.cards_left(), 'cards.') print() print('Dealing a card...') card = d.deal() print('The card dealt is:', card) print('Dealing another card...') print('The card dealt is:', d.deal()) print() print('Now the deck has', d.cards_left(), 'cards') print() print('==================') print('Testing Hand class') print('------------------') print() print('Creating a hand...') h = Hand() print('Dealing five cards from the deck into the hand...') for card in range(5): h.add(d.deal()) print('Your hand of', h.size(), 'cards contains:', h)","title":"Putting the pieces together"},{"location":"11_OOP2_Polymorphism_and_Inheritance/06_Putting_the_pieces_together/#putting-the-pieces-together","text":"Here's a module that combines the new CardCollection , Deck and Hand classes with our earlier Card class and a main routine that exercises them a little. Try it out. # playing_cards_5.py import random class Card: face_values = ['A','2','3','4','5','6','7','8','9','T','J','Q','K'] suits = ['Clubs','Diamonds','Hearts','Spades'] def __init__(self, cardnum): self.number = cardnum def __str__(self): return self.face_value() + ' of ' + self.suit() def face_value(self): return Card.face_values[ self.number % 13 ] def suit( self ): return Card.suits[ self.number // 13 ] class CardCollection: def __init__(self): self.cards = [] def size(self): return len(self.cards) def add(self, card): self.cards.append(card) def remove(self): return self.cards.pop() def __str__(self): return ', '.join( str(card) for card in self.cards ) class Deck(CardCollection): # Override ancestor's constructor, i.e. replace the default. def __init__(self): self.cards = [] for cardnum in range(52): self.add( Card(cardnum) ) # Alias the inherited method \"size\" as \"cards_left\", # because we usually ask how many cards are left in a # deck rather than asking about its size. def cards_left(self): return self.size() # Another alias. When using a deck of cards we talk about \"dealing\" # cards not \"removing\" them from the deck. def deal(self): return self.remove() # Add a new method, shuffle, that does not exist in ancestor class. def shuffle(self): for i in range( 2*self.size() ): self.cards.insert(random.randrange(len(self.cards)), self.cards.pop()) class Hand(CardCollection): pass if __name__ == '__main__': print('==================') print('Testing Card class') print('------------------') print() print('Your card number is 42.') c = Card(42) print('It\\'s face value is:', c.face_value()) print('It\\'s suit is:', c.suit()) print('It\\'s printable representation is:', c) print() print('==================') print('Testing Deck class') print('------------------') print() print('Creating a new Deck...') print() d = Deck() print('The deck\\'s printable representation:') print(d) print() print('Shuffling the deck...') d.shuffle() print('The deck after shuffling:') print(d) print() print('The deck has', d.cards_left(), 'cards.') print() print('Dealing a card...') card = d.deal() print('The card dealt is:', card) print('Dealing another card...') print('The card dealt is:', d.deal()) print() print('Now the deck has', d.cards_left(), 'cards') print() print('==================') print('Testing Hand class') print('------------------') print() print('Creating a hand...') h = Hand() print('Dealing five cards from the deck into the hand...') for card in range(5): h.add(d.deal()) print('Your hand of', h.size(), 'cards contains:', h)","title":"Putting the pieces together"},{"location":"11_OOP2_Polymorphism_and_Inheritance/07_Aside_Refactoring/","text":"Aside: Refactoring What we did in taking two existing classes and removing their common functionality to a new class from which they inherit is one form of refactoring . Refactoring refers to processes by which we modify a program without affecting its behaviour, i.e. we clean up its internal structure without affecting its external behaviour. Until the 1990s programmers just thought of it as cleaning up code, but with the development of agile development processes, and their emphasis on iterative development, refactoring became a key programming activity. Agile developers have refined many rules and techniques for successful refactoring.","title":"Aside: Refactoring"},{"location":"11_OOP2_Polymorphism_and_Inheritance/07_Aside_Refactoring/#aside-refactoring","text":"What we did in taking two existing classes and removing their common functionality to a new class from which they inherit is one form of refactoring . Refactoring refers to processes by which we modify a program without affecting its behaviour, i.e. we clean up its internal structure without affecting its external behaviour. Until the 1990s programmers just thought of it as cleaning up code, but with the development of agile development processes, and their emphasis on iterative development, refactoring became a key programming activity. Agile developers have refined many rules and techniques for successful refactoring.","title":"Aside: Refactoring"},{"location":"11_OOP2_Polymorphism_and_Inheritance/08_Polymorphism/","text":"Polymorphism Polymorphism allows the same syntax to be used with objects of different types, or equivalently, polymorphism occurs when the meaning of a method or operator depends on the type of object(s) it is applied to. For example the + symbol triggers three different operations in the code below each determined by the objects surrounding it, i.e. by its context. x = y + 5 salutation = 'Mr.' + last_name t = [3, 7] + [6, 2] From the developer's perspective the question is how we can make our object types trigger appropriate behaviour. Or to put it another way, can we give our objects the same status and abilities as Python's built-in objects? The answer is yes. All we need to do is to define some special methods for our classes. This is all we have to do because when Python encounters an operator in an expression it looks at the objects on each side of it (for a binary operator) and then calls a method from their class definitions if one is provided . For example when it encounters a + sign it checks to see if the object on the left hand side of the + sign has a method called __add__ . If it does, it invokes it. Nor is this limited to binary arithmetic operators. We saw earlier that the print command just looks for an __str__ method to invoke. Similarly square brackets for list indexing look for a method called __getitem__ . In all, Python defines dozen of available \"hooks\" for operations. The more of them you define for your classes the more they will seem like built-in classes. To see the full list of possibilities see section 3.4 of the documentation . What we will do in this module is to work with a small handful of them to get a feel for the issues involved.","title":"Polymorphism"},{"location":"11_OOP2_Polymorphism_and_Inheritance/08_Polymorphism/#polymorphism","text":"Polymorphism allows the same syntax to be used with objects of different types, or equivalently, polymorphism occurs when the meaning of a method or operator depends on the type of object(s) it is applied to. For example the + symbol triggers three different operations in the code below each determined by the objects surrounding it, i.e. by its context. x = y + 5 salutation = 'Mr.' + last_name t = [3, 7] + [6, 2] From the developer's perspective the question is how we can make our object types trigger appropriate behaviour. Or to put it another way, can we give our objects the same status and abilities as Python's built-in objects? The answer is yes. All we need to do is to define some special methods for our classes. This is all we have to do because when Python encounters an operator in an expression it looks at the objects on each side of it (for a binary operator) and then calls a method from their class definitions if one is provided . For example when it encounters a + sign it checks to see if the object on the left hand side of the + sign has a method called __add__ . If it does, it invokes it. Nor is this limited to binary arithmetic operators. We saw earlier that the print command just looks for an __str__ method to invoke. Similarly square brackets for list indexing look for a method called __getitem__ . In all, Python defines dozen of available \"hooks\" for operations. The more of them you define for your classes the more they will seem like built-in classes. To see the full list of possibilities see section 3.4 of the documentation . What we will do in this module is to work with a small handful of them to get a feel for the issues involved.","title":"Polymorphism"},{"location":"11_OOP2_Polymorphism_and_Inheritance/09_Example_Fractions/","text":"Example: Fractions Suppose we are working on a suite of programs for carpenters who want to work with fractions, e.g 3/4 of an inch, 5/16 of an inch and so on. Not surprisingly our design of this suite calls for a Fraction class. Of course with one eye on the future we don't want to just handle the fractions common in carpentry we want a general Fraction class we will be able to reuse in many settings. We'd like to be able to do things like this, >>> d1 = Fraction(2,5) >>> print(d1) 2/5 >>> d2 = Fraction(4) >>> print(d2) 4/1 >>> d3 = d1 + d2 >>> print(d3) 22/5 >>> if d1 <= d2: print('d1 is less than or equal to d2') else: print('d2 is greater than d1') d2 is greater than d1 >>> print(d1[0], d1[1]) 2 5 >>> print(d1 + 2) 12/5 >>> print(d1 - 2) -8/5 >>>","title":"Example: Fractions"},{"location":"11_OOP2_Polymorphism_and_Inheritance/09_Example_Fractions/#example-fractions","text":"Suppose we are working on a suite of programs for carpenters who want to work with fractions, e.g 3/4 of an inch, 5/16 of an inch and so on. Not surprisingly our design of this suite calls for a Fraction class. Of course with one eye on the future we don't want to just handle the fractions common in carpentry we want a general Fraction class we will be able to reuse in many settings. We'd like to be able to do things like this, >>> d1 = Fraction(2,5) >>> print(d1) 2/5 >>> d2 = Fraction(4) >>> print(d2) 4/1 >>> d3 = d1 + d2 >>> print(d3) 22/5 >>> if d1 <= d2: print('d1 is less than or equal to d2') else: print('d2 is greater than d1') d2 is greater than d1 >>> print(d1[0], d1[1]) 2 5 >>> print(d1 + 2) 12/5 >>> print(d1 - 2) -8/5 >>>","title":"Example: Fractions"},{"location":"11_OOP2_Polymorphism_and_Inheritance/10_Reverse_engineering/","text":"Reverse engineering You can figure out a lot about a class given an example of its use. From the sample output of using our imagined Fraction class we can tell that: >>> d1 = Fraction(2,5) >>> print(d1) 2/5 \u2192 It will have a constructor that takes two arguments, the first one the numerator, the second the denominator. >>> print(d1) \u2192 It defines a __str__ method for display. >>> d2 = Fraction(4)` 4/1 \u2192 The constructor can handle getting a single number. It does so by using it as the numerator and 1 as the denominator of the Fraction it constructs. >>> d3 = d1 + d2 \u2192 It defines the __add__ function. >>> if d1 <= d2: \u2192 It defines the __le__ method. >>> print(d1[0], d1[1]) \u2192 It defines the __getitem__ method. >>> print(d1 + 2) \u2192 Its __add__ method works when the second argument is an integer and not another Fraction . >>> print(d1 - 2) \u2192 It defines __sub__ and like __add__ , __sub__ works with integer values as well as Fraction values.","title":"Reverse engineering"},{"location":"11_OOP2_Polymorphism_and_Inheritance/10_Reverse_engineering/#reverse-engineering","text":"You can figure out a lot about a class given an example of its use. From the sample output of using our imagined Fraction class we can tell that: >>> d1 = Fraction(2,5) >>> print(d1) 2/5 \u2192 It will have a constructor that takes two arguments, the first one the numerator, the second the denominator. >>> print(d1) \u2192 It defines a __str__ method for display. >>> d2 = Fraction(4)` 4/1 \u2192 The constructor can handle getting a single number. It does so by using it as the numerator and 1 as the denominator of the Fraction it constructs. >>> d3 = d1 + d2 \u2192 It defines the __add__ function. >>> if d1 <= d2: \u2192 It defines the __le__ method. >>> print(d1[0], d1[1]) \u2192 It defines the __getitem__ method. >>> print(d1 + 2) \u2192 Its __add__ method works when the second argument is an integer and not another Fraction . >>> print(d1 - 2) \u2192 It defines __sub__ and like __add__ , __sub__ works with integer values as well as Fraction values.","title":"Reverse engineering"},{"location":"11_OOP2_Polymorphism_and_Inheritance/11_Class_Fraction/","text":"class Fraction The code needed to implement a class Fraction that can produce the shell session shown earlier is, class Fraction: def __init__(self, n, d = 1): self.num = n # numerator self.den = d # denominator def __str__(self): return str(self.num) + '/' + str(self.den) def __add__(self, other): if isinstance(other, Fraction): bottom = self.den * other.den top = (self.num * other.den) + (other.num * self.den) return Fraction(top, bottom) elif isinstance(other, int): other = Fraction(other) bottom = self.den * other.den top = (self.num * other.den) + (other.num * self.den) return Fraction(top, bottom) def __le__(self, other): return self.num*other.den <= other.den*self.num def __getitem__(self, key): if key == 0: return self.num elif key == 1: return self.den def __sub__(self, other): if isinstance(other, int): other = Fraction(other) if isinstance(other, Fraction): bottom = self.den * other.den top = (self.num * other.den) - (other.num * self.den) return Fraction(top, bottom) if __name__ == '__main__': d1 = Fraction(2, 5) print(d1, '(s/b 2/5)') d2 = Fraction(4) print(d2, '(s/b 4/1)') d3 = d1 + d2 print(d3, '(s/b 22/5)') if d1 <= d2: print(d1, 'is less than or equal', d2) else: print(d2, 'is greater than', d1) print(d1[0], d1[1], '(s/b 2 5)') print(d1 + 2, '(s/b 12/5)') print(d1 - 2, '(s/b -8/5)') The output when this module is run is (note that s/b is a short form for \"should be\") >>> 2/5 (s/b 2/5) 4/1 (s/b 4/1) 22/5 (s/b 22/5) 2/5 is less than or equal 4/1 2 5 (s/b 2 5) 12/5 (s/b 12/5) -8/5 (s/b -8/5) >>> Notes: Notice that __str__ uses the str() method to change the numerical values of num and den to strings since it has to return a string in the end. __add__ has to check the type of the thing being added to it (using isinstance ) to decide how to behave (more polymorphism!) In __add__ I used a clear structure which converts other from an int to a Fraction when necessary, but it can be done more briefly as demonstrated in __sub__ . __getitem__ is the special method called when the interpreter encounters [] s, i.e. when it encounters the expression obj[key] it calls obj.__getitem__(key) . That is not very much code to add a new datatype to a language and bring it toward first-class status!","title":"class Fraction"},{"location":"11_OOP2_Polymorphism_and_Inheritance/11_Class_Fraction/#class-fraction","text":"The code needed to implement a class Fraction that can produce the shell session shown earlier is, class Fraction: def __init__(self, n, d = 1): self.num = n # numerator self.den = d # denominator def __str__(self): return str(self.num) + '/' + str(self.den) def __add__(self, other): if isinstance(other, Fraction): bottom = self.den * other.den top = (self.num * other.den) + (other.num * self.den) return Fraction(top, bottom) elif isinstance(other, int): other = Fraction(other) bottom = self.den * other.den top = (self.num * other.den) + (other.num * self.den) return Fraction(top, bottom) def __le__(self, other): return self.num*other.den <= other.den*self.num def __getitem__(self, key): if key == 0: return self.num elif key == 1: return self.den def __sub__(self, other): if isinstance(other, int): other = Fraction(other) if isinstance(other, Fraction): bottom = self.den * other.den top = (self.num * other.den) - (other.num * self.den) return Fraction(top, bottom) if __name__ == '__main__': d1 = Fraction(2, 5) print(d1, '(s/b 2/5)') d2 = Fraction(4) print(d2, '(s/b 4/1)') d3 = d1 + d2 print(d3, '(s/b 22/5)') if d1 <= d2: print(d1, 'is less than or equal', d2) else: print(d2, 'is greater than', d1) print(d1[0], d1[1], '(s/b 2 5)') print(d1 + 2, '(s/b 12/5)') print(d1 - 2, '(s/b -8/5)') The output when this module is run is (note that s/b is a short form for \"should be\") >>> 2/5 (s/b 2/5) 4/1 (s/b 4/1) 22/5 (s/b 22/5) 2/5 is less than or equal 4/1 2 5 (s/b 2 5) 12/5 (s/b 12/5) -8/5 (s/b -8/5) >>> Notes: Notice that __str__ uses the str() method to change the numerical values of num and den to strings since it has to return a string in the end. __add__ has to check the type of the thing being added to it (using isinstance ) to decide how to behave (more polymorphism!) In __add__ I used a clear structure which converts other from an int to a Fraction when necessary, but it can be done more briefly as demonstrated in __sub__ . __getitem__ is the special method called when the interpreter encounters [] s, i.e. when it encounters the expression obj[key] it calls obj.__getitem__(key) . That is not very much code to add a new datatype to a language and bring it toward first-class status!","title":"class Fraction"},{"location":"11_OOP2_Polymorphism_and_Inheritance/12_Example_Playing_cards/","text":"Example: Playing cards Our first example of polymorphism dealt with Fraction s, an immutable type like other numbers and strings. There are some subtle issues that arise when dealing with mutable objects like container types. Our card classes provide a familiar container type for us to work with. Let's say we would like to be able to use a plus sign, + , to add cards to a CardCollection object. Specifically we want to enable code like this to work, cc = CardCollection() card = Card(42) cc = cc + card Here's what it would take to be able to use a plus sign in this way, class CardCollection: ... def __add__(self, other): self.cards.append(other) return self All we need to do is append the card to the cards in the CardCollection and return the CardCollection object. Why do we have to return the whole object? For that matter why do we have to return anything? Remember what the assignment operation is doing. It evaluates the expression on the right hand side (RHS), cc + card , and assigns the result of the expression to the name on the left hand side, cc . But the RHS operation just calls the function __add__ so the result of the expression will be the value returned by __add__ . If __add__ doesn't return a value then the value assigned to cc will be None \u2014 we will have deleted our list! That's why we have to be careful to return the modified object. Notice that thanks to inheritance we can use the plus sign operator on Hand s and Deck s too without writing any new code at all. Score one for inheritance! roxx = Hand() roxx = roxx + Card(42) roxx = roxx + Card(18) print(roxx) will produce the output, >>> 4 of Spades, 6 of Diamonds >>> Python's internals are well enough designed that we can chain + operations without having to write any additional code, e.g. roxx = Hand() roxx = roxx + Card(42) + Card(13) + Card(2) print(roxx) produces the output, >>> 4 of Spades, A of Diamonds, 3 of Clubs >>> This is nice, very nice in fact, but the built-in + operator does more than this when used with the built-in types. It can add two integers, but it can also add an integer and a float. So far we are adding a Card to a CardCollection , but what if we also wanted to be able to add two CardCollection s together? We would have to modify our code to detect the type of object it is being asked to add (just like we did with __add__ for Fraction s previously). def __add__(self, other): if isinstance(other, Card): self.cards.append(other) return self elif isinstance(other, CardCollection): self.cards.extend(other.cards) return self else: print('You can only add Cards or other CardCollections to CardCollections!') With this version we can now write code like this, roxx = Hand() roxx = roxx + Card(42) + Card(13) + Card(2) print('roxx:', roxx) chris = Hand() chris = chris + Card(3) + Card(4) print('chris:', chris) new = roxx + chris print('new:', new) which produces as output, >>> roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs new: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs >>>","title":"Example: Playing cards"},{"location":"11_OOP2_Polymorphism_and_Inheritance/12_Example_Playing_cards/#example-playing-cards","text":"Our first example of polymorphism dealt with Fraction s, an immutable type like other numbers and strings. There are some subtle issues that arise when dealing with mutable objects like container types. Our card classes provide a familiar container type for us to work with. Let's say we would like to be able to use a plus sign, + , to add cards to a CardCollection object. Specifically we want to enable code like this to work, cc = CardCollection() card = Card(42) cc = cc + card Here's what it would take to be able to use a plus sign in this way, class CardCollection: ... def __add__(self, other): self.cards.append(other) return self All we need to do is append the card to the cards in the CardCollection and return the CardCollection object. Why do we have to return the whole object? For that matter why do we have to return anything? Remember what the assignment operation is doing. It evaluates the expression on the right hand side (RHS), cc + card , and assigns the result of the expression to the name on the left hand side, cc . But the RHS operation just calls the function __add__ so the result of the expression will be the value returned by __add__ . If __add__ doesn't return a value then the value assigned to cc will be None \u2014 we will have deleted our list! That's why we have to be careful to return the modified object. Notice that thanks to inheritance we can use the plus sign operator on Hand s and Deck s too without writing any new code at all. Score one for inheritance! roxx = Hand() roxx = roxx + Card(42) roxx = roxx + Card(18) print(roxx) will produce the output, >>> 4 of Spades, 6 of Diamonds >>> Python's internals are well enough designed that we can chain + operations without having to write any additional code, e.g. roxx = Hand() roxx = roxx + Card(42) + Card(13) + Card(2) print(roxx) produces the output, >>> 4 of Spades, A of Diamonds, 3 of Clubs >>> This is nice, very nice in fact, but the built-in + operator does more than this when used with the built-in types. It can add two integers, but it can also add an integer and a float. So far we are adding a Card to a CardCollection , but what if we also wanted to be able to add two CardCollection s together? We would have to modify our code to detect the type of object it is being asked to add (just like we did with __add__ for Fraction s previously). def __add__(self, other): if isinstance(other, Card): self.cards.append(other) return self elif isinstance(other, CardCollection): self.cards.extend(other.cards) return self else: print('You can only add Cards or other CardCollections to CardCollections!') With this version we can now write code like this, roxx = Hand() roxx = roxx + Card(42) + Card(13) + Card(2) print('roxx:', roxx) chris = Hand() chris = chris + Card(3) + Card(4) print('chris:', chris) new = roxx + chris print('new:', new) which produces as output, >>> roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs new: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs >>>","title":"Example: Playing cards"},{"location":"11_OOP2_Polymorphism_and_Inheritance/13_A_subtle_point_Semantics/","text":"A subtle point: Semantics If it looks too easy so far, that's because it isn't quite this easy. What we have at the moment looks like it works only because we have not investigated what it has done closely enough. Let's add a few more print statements and rerun that last program. Code: print('Before:') roxx = Hand() roxx = roxx + Card(42) + Card(13) + Card(2) print('roxx:', roxx) chris = Hand() chris = chris + Card(3) + Card(4) print('chris:', chris) print('After:') new = roxx + chris print('new:', new) print('roxx:', roxx) print('chris:', chris) Output: >>> Before: roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs After: new: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs roxx: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs chris: 4 of Clubs, 5 of Clubs >>> Uh oh! The value of roxx is changed by what we've done in creating new which may or may not be the semantics we intended by the statement new = roxx + chris . The problem here is that we are building our return value from an existing object so we are changing the existing object as we do so, and then ending up with a shared reference to a single modified object. And we know from our first encounter with shared references that they can be a serious problem. The fix is to create a new CardCollection object in __add__ , fill it with the necessary values, and then return it. The result is code like this, def __add__(self, other): # Create a new CardCollection. new_cc = CardCollection() # Put a copy of self's cards into it. new_cc.cards = self.cards[:] if isinstance(other, Card): new_cc.cards.append(other) return new_cc elif isinstance(other, CardCollection): new_cc.cards.extend(other.cards[:]) return new_cc else: print('You can only add Cards to CardCollections!') which produces the output, Before: roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs After: new: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs >>> There are further semantic issues. When we write new = roxx + chris , to create a new Hand from roxx and chris , should roxx and chris be emptied? That is, are we taking the cards out of the hands roxx and chris to create new like a game of Go Fish? Or does new = roxx + chris mean to make a hand called new that is like the combination of new = roxx + chris ? Sorting out the meaning of operations is semantics, and the semantics of collection types is notoriously tricky. There aren't universally right and wrong answers to these questions. What we strive for are answers that fit the problem domain, i.e. code that matches our experience of the real-world situation we are modelling.","title":"A subtle point: Semantics"},{"location":"11_OOP2_Polymorphism_and_Inheritance/13_A_subtle_point_Semantics/#a-subtle-point-semantics","text":"If it looks too easy so far, that's because it isn't quite this easy. What we have at the moment looks like it works only because we have not investigated what it has done closely enough. Let's add a few more print statements and rerun that last program. Code: print('Before:') roxx = Hand() roxx = roxx + Card(42) + Card(13) + Card(2) print('roxx:', roxx) chris = Hand() chris = chris + Card(3) + Card(4) print('chris:', chris) print('After:') new = roxx + chris print('new:', new) print('roxx:', roxx) print('chris:', chris) Output: >>> Before: roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs After: new: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs roxx: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs chris: 4 of Clubs, 5 of Clubs >>> Uh oh! The value of roxx is changed by what we've done in creating new which may or may not be the semantics we intended by the statement new = roxx + chris . The problem here is that we are building our return value from an existing object so we are changing the existing object as we do so, and then ending up with a shared reference to a single modified object. And we know from our first encounter with shared references that they can be a serious problem. The fix is to create a new CardCollection object in __add__ , fill it with the necessary values, and then return it. The result is code like this, def __add__(self, other): # Create a new CardCollection. new_cc = CardCollection() # Put a copy of self's cards into it. new_cc.cards = self.cards[:] if isinstance(other, Card): new_cc.cards.append(other) return new_cc elif isinstance(other, CardCollection): new_cc.cards.extend(other.cards[:]) return new_cc else: print('You can only add Cards to CardCollections!') which produces the output, Before: roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs After: new: 4 of Spades, A of Diamonds, 3 of Clubs, 4 of Clubs, 5 of Clubs roxx: 4 of Spades, A of Diamonds, 3 of Clubs chris: 4 of Clubs, 5 of Clubs >>> There are further semantic issues. When we write new = roxx + chris , to create a new Hand from roxx and chris , should roxx and chris be emptied? That is, are we taking the cards out of the hands roxx and chris to create new like a game of Go Fish? Or does new = roxx + chris mean to make a hand called new that is like the combination of new = roxx + chris ? Sorting out the meaning of operations is semantics, and the semantics of collection types is notoriously tricky. There aren't universally right and wrong answers to these questions. What we strive for are answers that fit the problem domain, i.e. code that matches our experience of the real-world situation we are modelling.","title":"A subtle point: Semantics"},{"location":"11_OOP2_Polymorphism_and_Inheritance/14_Conclusion_Adding_types/","text":"Conclusion: Adding Types Using classes to add new types to a programming language is a very powerful technique that makes it easier (ideally simple) to write programs in domains the language does not natively support. It is perhaps the crowning achievement of object-oriented programming. However such achievements are not always easy to attain. To do it well requires close attention to the semantics of the situation you are modelling, especially where mutable types are used.","title":"Conclusion: Adding Types"},{"location":"11_OOP2_Polymorphism_and_Inheritance/14_Conclusion_Adding_types/#conclusion-adding-types","text":"Using classes to add new types to a programming language is a very powerful technique that makes it easier (ideally simple) to write programs in domains the language does not natively support. It is perhaps the crowning achievement of object-oriented programming. However such achievements are not always easy to attain. To do it well requires close attention to the semantics of the situation you are modelling, especially where mutable types are used.","title":"Conclusion: Adding Types"},{"location":"11_OOP2_Polymorphism_and_Inheritance/90_Assignment_11/","text":"Assignment 11 Problems Using a class does not necessarily make a program object oriented. Consider the code below. The first warning bells are that the class has no methods and the functions in the module are stand alone functions not class methods. The code uses a class , but if you look carefully you will see that the class is used to represent not one type of object but several types of objects. The give-away is the attribute kind and the way it is tested by the remaining functions in the module to decide what to do. YOU DO NOT ACTUALLY HAVE TO DRAW OR MANIPULATE SHAPES! This is just an example of how to implement good object oriented design. # Suppose we need to support circles, equilateral triangles and squares. (CIRCLE, TRIANGLE, SQUARE) = range(3) class Shape: def __init__(self, k, c, s): self.kind = k self.centre = c self.size = s ... def draw(shape): if shape.kind == CIRCLE: # code to draw a circle ... elif shape.kind == TRIANGLE: # code to draw a triangle ... else: # code to draw a square ... def fill(shape, colour): # Fills the shape with colour. if shape.kind == CIRCLE: # code to fill in a circle ... elif shape.kind == TRIANGLE: # code to fill in a triangle ... else: # code to fill in a square ... def rotate(shape, angle): # Rotates the shape about its centre by angle. if shape.kind == CIRCLE: # code to rotate a circle ... elif shape.kind == TRIANGLE: # code to rotate a triangle ... else: # code to rotate a square ... def groovy(shape_list): for shape in shape_list: draw(shape) rotate(shape, math.pi/2) fill(shape, random.randint(0,15)) a. Suppose you are given this code and told you must add support for an additional shape, pentagons. What changes would you have to make to the module? Call this version a11_1_1a.py. b. Now refactor this code so it uses three classes Circle, Triangle and Square instead of one where each class has its own draw, fill, etc. methods. Call this version a11_1_1b.py. c. Finally, what changes have to be made to version a11_1_1b.py to support a new pentagon shape type? Call this version a11_1_1c.py d. Compare the changes you made in a. and c. above. In each case how much existing code did you have to modify? Which approach is most likely to result in breaking existing code? You can put your answers to these questions in your submission comment. The class CoinJar represents a jar of Canadian coins. Write the necessary code so this program will run correctly. tims = CoinJar(pennies=3, quarters=2, loonies=1,toonies=0) mollys = CoinJar(pennies=48, nickels=12, dimes=7, quarters=14) print(tims.value()) # Displays 1.53 print(mollys.value()) # Displays 5.28 print(tims.dimes) # Displays 0. print(tims[0]) # Displays 0. print(mollys.quarters) # Displays 14. print(mollys[3]) # Displays 7. if tims > mollys: print('Tim is richer than Molly.') else: print('Molly is at least as rich as Tim.') # ^ Displays: Molly is at least as rich as Tim. tims = tims + mollys print(tims) # Fancy display of your design. Hint: Since the order of the parameters varies between the two constructor calls in lines 1 and 2 we can tell that named parameters are being used. The file WumpusAdjMatrixMap.py contains an alternative representation of a wumpus cave system (one based on an adjacency matrix* rather than the list of lists of tunnels we have been using) and stubs for two functions: tunnels_from and tunnels_to. Write the bodies of these functions so they will work as the docstrings describe. The docstrings contain one test of each function, but these are meant to be illustrative rather than exhaustive. Note that you don't have to integrate this representation into your earlier Hunt the Wumpus program. This is a stand alone problem. Hint: You might want to peek ahead at Module 12 to see how to activate the tests in the docstrings. Logistics Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So your code for the the first problen of this assignment will be named a11p1bob.py (adjusted obviously to use your name). Please submit your .py file to the Moodle dropbox.","title":"Assignment 11"},{"location":"11_OOP2_Polymorphism_and_Inheritance/90_Assignment_11/#assignment-11","text":"","title":"Assignment 11"},{"location":"11_OOP2_Polymorphism_and_Inheritance/90_Assignment_11/#problems","text":"Using a class does not necessarily make a program object oriented. Consider the code below. The first warning bells are that the class has no methods and the functions in the module are stand alone functions not class methods. The code uses a class , but if you look carefully you will see that the class is used to represent not one type of object but several types of objects. The give-away is the attribute kind and the way it is tested by the remaining functions in the module to decide what to do. YOU DO NOT ACTUALLY HAVE TO DRAW OR MANIPULATE SHAPES! This is just an example of how to implement good object oriented design. # Suppose we need to support circles, equilateral triangles and squares. (CIRCLE, TRIANGLE, SQUARE) = range(3) class Shape: def __init__(self, k, c, s): self.kind = k self.centre = c self.size = s ... def draw(shape): if shape.kind == CIRCLE: # code to draw a circle ... elif shape.kind == TRIANGLE: # code to draw a triangle ... else: # code to draw a square ... def fill(shape, colour): # Fills the shape with colour. if shape.kind == CIRCLE: # code to fill in a circle ... elif shape.kind == TRIANGLE: # code to fill in a triangle ... else: # code to fill in a square ... def rotate(shape, angle): # Rotates the shape about its centre by angle. if shape.kind == CIRCLE: # code to rotate a circle ... elif shape.kind == TRIANGLE: # code to rotate a triangle ... else: # code to rotate a square ... def groovy(shape_list): for shape in shape_list: draw(shape) rotate(shape, math.pi/2) fill(shape, random.randint(0,15)) a. Suppose you are given this code and told you must add support for an additional shape, pentagons. What changes would you have to make to the module? Call this version a11_1_1a.py. b. Now refactor this code so it uses three classes Circle, Triangle and Square instead of one where each class has its own draw, fill, etc. methods. Call this version a11_1_1b.py. c. Finally, what changes have to be made to version a11_1_1b.py to support a new pentagon shape type? Call this version a11_1_1c.py d. Compare the changes you made in a. and c. above. In each case how much existing code did you have to modify? Which approach is most likely to result in breaking existing code? You can put your answers to these questions in your submission comment. The class CoinJar represents a jar of Canadian coins. Write the necessary code so this program will run correctly. tims = CoinJar(pennies=3, quarters=2, loonies=1,toonies=0) mollys = CoinJar(pennies=48, nickels=12, dimes=7, quarters=14) print(tims.value()) # Displays 1.53 print(mollys.value()) # Displays 5.28 print(tims.dimes) # Displays 0. print(tims[0]) # Displays 0. print(mollys.quarters) # Displays 14. print(mollys[3]) # Displays 7. if tims > mollys: print('Tim is richer than Molly.') else: print('Molly is at least as rich as Tim.') # ^ Displays: Molly is at least as rich as Tim. tims = tims + mollys print(tims) # Fancy display of your design. Hint: Since the order of the parameters varies between the two constructor calls in lines 1 and 2 we can tell that named parameters are being used. The file WumpusAdjMatrixMap.py contains an alternative representation of a wumpus cave system (one based on an adjacency matrix* rather than the list of lists of tunnels we have been using) and stubs for two functions: tunnels_from and tunnels_to. Write the bodies of these functions so they will work as the docstrings describe. The docstrings contain one test of each function, but these are meant to be illustrative rather than exhaustive. Note that you don't have to integrate this representation into your earlier Hunt the Wumpus program. This is a stand alone problem. Hint: You might want to peek ahead at Module 12 to see how to activate the tests in the docstrings.","title":"Problems"},{"location":"11_OOP2_Polymorphism_and_Inheritance/90_Assignment_11/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So your code for the the first problen of this assignment will be named a11p1bob.py (adjusted obviously to use your name). Please submit your .py file to the Moodle dropbox.","title":"Logistics"},{"location":"12_Testing_and_Documentation/","text":"Introduction: Testing and documentation \ud83d\udd75\ufe0f Last (substantive) module of the course! Well except for that pesky exam. No heavy lifting in this module, just two non-programming software development topics. The first is a way to document our OOP designs using diagrams: Unified Modeling Language (UML). The second is a way to embed tests of our methods in our Python code which makes them easy to run when we \"improve\" that code, and makes our programs more self-documenting since it shows the exact behaviour we are expecting of our code. UML and Testing with doctest Unified Modelling Language (UML) Aside: is-a versus has-a UML class diagram visual syntax Example: Playing card classes Testing with doctest","title":"Introduction: Testing and documentation \ud83d\udd75\ufe0f"},{"location":"12_Testing_and_Documentation/#introduction-testing-and-documentation","text":"Last (substantive) module of the course! Well except for that pesky exam. No heavy lifting in this module, just two non-programming software development topics. The first is a way to document our OOP designs using diagrams: Unified Modeling Language (UML). The second is a way to embed tests of our methods in our Python code which makes them easy to run when we \"improve\" that code, and makes our programs more self-documenting since it shows the exact behaviour we are expecting of our code. UML and Testing with doctest Unified Modelling Language (UML) Aside: is-a versus has-a UML class diagram visual syntax Example: Playing card classes Testing with doctest","title":"Introduction: Testing and documentation \ud83d\udd75\ufe0f"},{"location":"12_Testing_and_Documentation/01_UML_and_testing_with_doctest/","text":"UML and Testing with doctest We are all but done. There will be no heavy lifting in this module, no complex algorithms or complex data structures to sort out, but there are a couple of important topics for us to cover. The first is the use of UML class diagrams as both design aid and documentation of our OO designs. The second is Python's doctest module.","title":"UML and Testing with doctest"},{"location":"12_Testing_and_Documentation/01_UML_and_testing_with_doctest/#uml-and-testing-with-doctest","text":"We are all but done. There will be no heavy lifting in this module, no complex algorithms or complex data structures to sort out, but there are a couple of important topics for us to cover. The first is the use of UML class diagrams as both design aid and documentation of our OO designs. The second is Python's doctest module.","title":"UML and Testing with doctest"},{"location":"12_Testing_and_Documentation/02_Unified_modelling_language_uml/","text":"Unified Modelling Language (UML) UML stands for Unified 1 Modeling Language. Rather than being a spoken (like English) or written (like Python) language UML specifies a graphical language for describing the production of software. UML includes 13 kinds of diagrams that provide for the depiction of business processes, database schemas, project activities and programming language statements. We are just going to use one of them, UML class diagrams , and we'll look at them in a slightly simplified form. The goal of a class diagram is to summarize the characteristics of individual classes, and the relationships between them. This means that for individual classes we want to show each class' name, attributes and methods. As for the relationship between classes we want to show \"is-a\" (or inheritance) and \"has-a\" (or composition) relationships. The word \"unified\" appears in the name because UML was the unification of several competing systems. As usual you can find a useful summary and background on Wikipedia. \u21a9","title":"Unified Modelling Language (UML)"},{"location":"12_Testing_and_Documentation/02_Unified_modelling_language_uml/#unified-modelling-language-uml","text":"UML stands for Unified 1 Modeling Language. Rather than being a spoken (like English) or written (like Python) language UML specifies a graphical language for describing the production of software. UML includes 13 kinds of diagrams that provide for the depiction of business processes, database schemas, project activities and programming language statements. We are just going to use one of them, UML class diagrams , and we'll look at them in a slightly simplified form. The goal of a class diagram is to summarize the characteristics of individual classes, and the relationships between them. This means that for individual classes we want to show each class' name, attributes and methods. As for the relationship between classes we want to show \"is-a\" (or inheritance) and \"has-a\" (or composition) relationships. The word \"unified\" appears in the name because UML was the unification of several competing systems. As usual you can find a useful summary and background on Wikipedia. \u21a9","title":"Unified Modelling Language (UML)"},{"location":"12_Testing_and_Documentation/03_Aside_is_a_versus_has_a/","text":"Aside: is-a versus has-a We have used both is-a and has-a relations already but without drawing attention to the distinction between them. The is-a relationship typifies inheritance, in which we can say of each subtype or descendant class that it \"is a\" superclass. For instance consider the small hierarchy below, class Person: ... class Student(Person): ... class Employee(Person): ... class Instructor(Employee): ... class Administrator(Employee): ... In this case we can say that a Student is a Person and that an Employee is a Person . Similarly we can say that an Instructor is an Employee and that an Administrator is an Employee . Now since an Instructor is an Employee and an Employee is a Person it follows that through inheritance an Instructor is a Person and similarly that an Administrator is a Person . Let's add some more classes and show some of the attributes. class Date: ... class CourseList: ... class Person: def __init__(...): self.birthdate = ... ... class Student(Person): def __init__(...): self.courses = ... ... class Employee(Person): ... class Instructor(Employee): def __init__(...): self.courses = ... ... class Administrator(Employee): ... Here we can see some has-a relationships. A Person has a birthdate which is presumably of type Date . Thus since all the classes listed below Person are also Person s they all have birthdate s too and we can say everyone has a Date . We can also see that both Students and Instructors have a courses attribute (of type CourseList , take my word for it) so we can say that a Student has a CourseList (of the ones s/he takes) and that an Instructor has a CourseList (of the ones s/he teaches).","title":"Aside:\u00a0is-a\u00a0versus\u00a0has-a"},{"location":"12_Testing_and_Documentation/03_Aside_is_a_versus_has_a/#aside-is-a-versus-has-a","text":"We have used both is-a and has-a relations already but without drawing attention to the distinction between them. The is-a relationship typifies inheritance, in which we can say of each subtype or descendant class that it \"is a\" superclass. For instance consider the small hierarchy below, class Person: ... class Student(Person): ... class Employee(Person): ... class Instructor(Employee): ... class Administrator(Employee): ... In this case we can say that a Student is a Person and that an Employee is a Person . Similarly we can say that an Instructor is an Employee and that an Administrator is an Employee . Now since an Instructor is an Employee and an Employee is a Person it follows that through inheritance an Instructor is a Person and similarly that an Administrator is a Person . Let's add some more classes and show some of the attributes. class Date: ... class CourseList: ... class Person: def __init__(...): self.birthdate = ... ... class Student(Person): def __init__(...): self.courses = ... ... class Employee(Person): ... class Instructor(Employee): def __init__(...): self.courses = ... ... class Administrator(Employee): ... Here we can see some has-a relationships. A Person has a birthdate which is presumably of type Date . Thus since all the classes listed below Person are also Person s they all have birthdate s too and we can say everyone has a Date . We can also see that both Students and Instructors have a courses attribute (of type CourseList , take my word for it) so we can say that a Student has a CourseList (of the ones s/he takes) and that an Instructor has a CourseList (of the ones s/he teaches).","title":"Aside:\u00a0is-a\u00a0versus\u00a0has-a"},{"location":"12_Testing_and_Documentation/04_UML_class_diagram_visual_syntax/","text":"UML class diagram visual syntax The visual syntax that UML class diagrams use to show classes' attributes, methods, and is-a or has-a relationships is fairly straightforward. Each class is represented by a three-part rectangular box. The top portion is used for the class name. The middle portion lists the attributes and their types. The bottom portion lists the methods, the types of arguments they expect, and the type of value they return. The relationships between classes are shown using two types of arrows. One with a traditional arrow head indicate is-a relationships. For example the diagram below shows that a Pentagon is-a type of Shape. Arrows with a diamond head indicate has-a relationships. In the diagram below we can see that a Shape has-a Location attribute named center. UML class diagrams can have other adornments, in particular they can show the cardinality of the connections, but we will not be making use of that feature. Finally, it is important to notice the difference between a UML class diagram and a memory diagram, e.g. the one drawn for Hunt the Wumpus in Module 10. A UML class diagram shows the relation between abstract classes. The memory diagram shows the relation between objects, i.e. between multiple instantiations of classes. It follows that in a UML diagram you will only ever see one box for each class. In a memory diagram you will see as many boxes of each class type as there are objects of that type in the running program. The UML diagram shows class methods, whereas most memory diagrams just show the object attributes and ignore the methods (because while all objects of a given type have the same methods their attribute values may differ).","title":"UML class diagram visual syntax"},{"location":"12_Testing_and_Documentation/04_UML_class_diagram_visual_syntax/#uml-class-diagram-visual-syntax","text":"The visual syntax that UML class diagrams use to show classes' attributes, methods, and is-a or has-a relationships is fairly straightforward. Each class is represented by a three-part rectangular box. The top portion is used for the class name. The middle portion lists the attributes and their types. The bottom portion lists the methods, the types of arguments they expect, and the type of value they return. The relationships between classes are shown using two types of arrows. One with a traditional arrow head indicate is-a relationships. For example the diagram below shows that a Pentagon is-a type of Shape. Arrows with a diamond head indicate has-a relationships. In the diagram below we can see that a Shape has-a Location attribute named center. UML class diagrams can have other adornments, in particular they can show the cardinality of the connections, but we will not be making use of that feature. Finally, it is important to notice the difference between a UML class diagram and a memory diagram, e.g. the one drawn for Hunt the Wumpus in Module 10. A UML class diagram shows the relation between abstract classes. The memory diagram shows the relation between objects, i.e. between multiple instantiations of classes. It follows that in a UML diagram you will only ever see one box for each class. In a memory diagram you will see as many boxes of each class type as there are objects of that type in the running program. The UML diagram shows class methods, whereas most memory diagrams just show the object attributes and ignore the methods (because while all objects of a given type have the same methods their attribute values may differ).","title":"UML class diagram visual syntax"},{"location":"12_Testing_and_Documentation/05_Example_Playing_card_classes/","text":"Example: Playing card classes Here is a UML diagram of some playing card classes without inheritance: And here is one of our refactored playing card classes:","title":"Example: Playing card classes"},{"location":"12_Testing_and_Documentation/05_Example_Playing_card_classes/#example-playing-card-classes","text":"Here is a UML diagram of some playing card classes without inheritance: And here is one of our refactored playing card classes:","title":"Example: Playing card classes"},{"location":"12_Testing_and_Documentation/06_Testing_with_doctest/","text":"Testing with doctest By example I've illustrated a large number of ways of writing testing harnesses for code during this course. The way they were constructed depended on the kinds of tests needed to verify the code works. Python provides a nice built-in mechanism that makes it easy to express tests for many kinds of programs and produces useful documentation at the same time. The doctest module lets you include test specifications in docstrings and then automatically extracts and uses them and reports on the results. The rationale behind it is roughly that (i) we all agree that documentation is good, and (ii) we all agree that testing is good, so, why not combine the two and have the tests supplement the documentation? This has the added benefit of keeping the tests right with the code they test and not somewhere else in the module. Here's a familiar bit of code with tests in it and a main routine that will run and report on the tests: # WumpusAdjMatrixMap.py # # Adjacency matrix representation of a cave_system. # A 1 at entry [i, j] indicates that you can get from room i to room j. # # Note that this cave_system is not a dodecahedron and that some tunnels # are 1-way. cave_system = [] cave_system.append([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]) cave_system.append([0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1]) cave_system.append([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]) cave_system.append([0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]) cave_system.append([0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]) cave_system.append([1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1]) cave_system.append([0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0]) cave_system.append([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1]) cave_system.append([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]) cave_system.append([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]) cave_system.append([0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1]) cave_system.append([0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]) def tunnels_from(cave_map, room_number): ''' returns a list of the rooms that can be reached from room room_number. >>> tunnels_from(cave_system, 0) [1, 4, 7] ''' pass def tunnels_to(cave_map, room_number): ''' returns a list of the rooms that have tunnels leading to room room_number. >>> tunnels_to(cave_system, 0) [1, 11, 14, 17] ''' pass if __name__=='__main__': import doctest doctest.testmod() The testmod method will extract the lines in the docstrings that look like interactive python sessions, i.e. the ones beginning with >>> and the lines following them. It will execute the commands after the >>> s and compare their output with the lines following them. If the actual output matches the specified output it counts as a success. If they do not match it counts as a failure, and reports on it. For example here is the output from executing the module above: >>> ********************************************************************** File \"__main__\", line 32, in __main__.tunnels_from Failed example: tunnels_from(cave_system, 0) Expected: [1, 4, 7] Got nothing ********************************************************************** File \"__main__\", line 39, in __main__.tunnels_to Failed example: tunnels_to(cave_system, 0) Expected: [1, 11, 14, 17] Got nothing ********************************************************************** 2 items had failures: 1 of 1 in __main__.tunnels_from 1 of 1 in __main__.tunnels_to ***Test Failed*** 2 failures. >>> You can see that the output shows what it expected to get and what it actually got test by test, and at the end it summarizes the failures. testmod 's default setting is to be silent on successes so had there been successful tests they would have generated no output. The strengths of the doctest approach to testing are that: It enables you to embed your tests in your documentation. It requires you to be specific about the exact result you expect. The tests enhance the documentation by providing specific examples of how a function should operate. The tests become part of the function definition. In concrete terms they are kept near the function rather than elsewhere in the module or worse, spread around the module. The downside to the doctest approach is just that not all methods lend themselves to being run in a shell session, and that is doctest's only paradigm. It also can't help you catch runtime errors in interactive programs, e.g. problems with bat snatching in Hunt the Wumpus. On balance it is best to think about doctest as a good starting point, but not necessarily sufficient on its own. You can read more about doctest in Section 26.2 of the Python documentation .","title":"Testing with doctest"},{"location":"12_Testing_and_Documentation/06_Testing_with_doctest/#testing-with-doctest","text":"By example I've illustrated a large number of ways of writing testing harnesses for code during this course. The way they were constructed depended on the kinds of tests needed to verify the code works. Python provides a nice built-in mechanism that makes it easy to express tests for many kinds of programs and produces useful documentation at the same time. The doctest module lets you include test specifications in docstrings and then automatically extracts and uses them and reports on the results. The rationale behind it is roughly that (i) we all agree that documentation is good, and (ii) we all agree that testing is good, so, why not combine the two and have the tests supplement the documentation? This has the added benefit of keeping the tests right with the code they test and not somewhere else in the module. Here's a familiar bit of code with tests in it and a main routine that will run and report on the tests: # WumpusAdjMatrixMap.py # # Adjacency matrix representation of a cave_system. # A 1 at entry [i, j] indicates that you can get from room i to room j. # # Note that this cave_system is not a dodecahedron and that some tunnels # are 1-way. cave_system = [] cave_system.append([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]) cave_system.append([0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1]) cave_system.append([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]) cave_system.append([0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]) cave_system.append([0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]) cave_system.append([1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1]) cave_system.append([0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0]) cave_system.append([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]) cave_system.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1]) cave_system.append([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]) cave_system.append([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]) cave_system.append([0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1]) cave_system.append([0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]) def tunnels_from(cave_map, room_number): ''' returns a list of the rooms that can be reached from room room_number. >>> tunnels_from(cave_system, 0) [1, 4, 7] ''' pass def tunnels_to(cave_map, room_number): ''' returns a list of the rooms that have tunnels leading to room room_number. >>> tunnels_to(cave_system, 0) [1, 11, 14, 17] ''' pass if __name__=='__main__': import doctest doctest.testmod() The testmod method will extract the lines in the docstrings that look like interactive python sessions, i.e. the ones beginning with >>> and the lines following them. It will execute the commands after the >>> s and compare their output with the lines following them. If the actual output matches the specified output it counts as a success. If they do not match it counts as a failure, and reports on it. For example here is the output from executing the module above: >>> ********************************************************************** File \"__main__\", line 32, in __main__.tunnels_from Failed example: tunnels_from(cave_system, 0) Expected: [1, 4, 7] Got nothing ********************************************************************** File \"__main__\", line 39, in __main__.tunnels_to Failed example: tunnels_to(cave_system, 0) Expected: [1, 11, 14, 17] Got nothing ********************************************************************** 2 items had failures: 1 of 1 in __main__.tunnels_from 1 of 1 in __main__.tunnels_to ***Test Failed*** 2 failures. >>> You can see that the output shows what it expected to get and what it actually got test by test, and at the end it summarizes the failures. testmod 's default setting is to be silent on successes so had there been successful tests they would have generated no output. The strengths of the doctest approach to testing are that: It enables you to embed your tests in your documentation. It requires you to be specific about the exact result you expect. The tests enhance the documentation by providing specific examples of how a function should operate. The tests become part of the function definition. In concrete terms they are kept near the function rather than elsewhere in the module or worse, spread around the module. The downside to the doctest approach is just that not all methods lend themselves to being run in a shell session, and that is doctest's only paradigm. It also can't help you catch runtime errors in interactive programs, e.g. problems with bat snatching in Hunt the Wumpus. On balance it is best to think about doctest as a good starting point, but not necessarily sufficient on its own. You can read more about doctest in Section 26.2 of the Python documentation .","title":"Testing with doctest"},{"location":"12_Testing_and_Documentation/90_Assignment_12/","text":"Assignment 12 Problems Split into two groups and draw a UML class diagram for Hunt the Wumpus. One group will wirte the UML for the design given in in class and the other group will do a UML for an alternative design (Simon's implementation). You can do this by hand or using software (for example MS Visio or Gliffy), it's up to you. Once both groups have a UML diagram we will compare and discuss the advantages and disadvantages of each design. Add a docstring containing a sufficient set of doctest tests and a call to run those tests to the module below, # ScrabbleScoring.py LETTER_VALUES = {'A':1, 'B':3, 'C':3, 'D':2, 'E':1, 'F':4, 'G':2, 'H':4, 'I':1, 'J':8, 'K':5, 'L':1, 'M':3, 'N':1, 'O':1, 'P':3, 'Q':10, 'R':1, 'S':1, 'T':1, 'U':1, 'V':4, 'W':4, 'X':8, 'Y':4, 'Z':10} def scrabble_value(s): 'Returns the Scrabble score for the letters in the string s.' total_value = 0 for letter in s: total_value = total_value + LETTER_VALUES[letter] return total_value Replace the code below that tests the function isStraight with an equivalent set of doctests. Fill in the body of isStraight and run the tests on it. # is_straight_doctest.py def isStraight(hand): pass if __name__ == '__main__': # TEST_HANDS is a list containing the hands of cards to use in testing # the function isStraight, and the correct result for each hand. # Note that not all hands have five cards, and some are straights, # while some are not. TEST_HANDS = [ [[ 1, 2, 3, 4, 5 ], True], [[ 5, 4, 3, 2, 1 ], True], [[ 14, 0, 28, 42, 4 ], True], [[ 1, 2, 3, 4, 5, 6 ], True], [[ 5 ], True], [[ 1, 2, 2, 4, 5 ], False], [[ 1, 2, 2, 5, 5 ], False], [[ 1, 3, 5, 7, 9 ], False] ] print 'Testing isStraight ... ' # Loop through the list of TEST_HANDS, to test each sample hand. for test in TEST_HANDS: # If the function isStraight does not return the correct # result... if isStraight(test[0]) != test[1]: # ... display an error message print 'isStraight fails on', test[0] Logistics Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So your code for the the first problen of this assignment will be named a11p1bob.py (adjusted obviously to use your name). Please submit your .py file to the Moodle dropbox.","title":"Assignment 12"},{"location":"12_Testing_and_Documentation/90_Assignment_12/#assignment-12","text":"","title":"Assignment 12"},{"location":"12_Testing_and_Documentation/90_Assignment_12/#problems","text":"Split into two groups and draw a UML class diagram for Hunt the Wumpus. One group will wirte the UML for the design given in in class and the other group will do a UML for an alternative design (Simon's implementation). You can do this by hand or using software (for example MS Visio or Gliffy), it's up to you. Once both groups have a UML diagram we will compare and discuss the advantages and disadvantages of each design. Add a docstring containing a sufficient set of doctest tests and a call to run those tests to the module below, # ScrabbleScoring.py LETTER_VALUES = {'A':1, 'B':3, 'C':3, 'D':2, 'E':1, 'F':4, 'G':2, 'H':4, 'I':1, 'J':8, 'K':5, 'L':1, 'M':3, 'N':1, 'O':1, 'P':3, 'Q':10, 'R':1, 'S':1, 'T':1, 'U':1, 'V':4, 'W':4, 'X':8, 'Y':4, 'Z':10} def scrabble_value(s): 'Returns the Scrabble score for the letters in the string s.' total_value = 0 for letter in s: total_value = total_value + LETTER_VALUES[letter] return total_value Replace the code below that tests the function isStraight with an equivalent set of doctests. Fill in the body of isStraight and run the tests on it. # is_straight_doctest.py def isStraight(hand): pass if __name__ == '__main__': # TEST_HANDS is a list containing the hands of cards to use in testing # the function isStraight, and the correct result for each hand. # Note that not all hands have five cards, and some are straights, # while some are not. TEST_HANDS = [ [[ 1, 2, 3, 4, 5 ], True], [[ 5, 4, 3, 2, 1 ], True], [[ 14, 0, 28, 42, 4 ], True], [[ 1, 2, 3, 4, 5, 6 ], True], [[ 5 ], True], [[ 1, 2, 2, 4, 5 ], False], [[ 1, 2, 2, 5, 5 ], False], [[ 1, 3, 5, 7, 9 ], False] ] print 'Testing isStraight ... ' # Loop through the list of TEST_HANDS, to test each sample hand. for test in TEST_HANDS: # If the function isStraight does not return the correct # result... if isStraight(test[0]) != test[1]: # ... display an error message print 'isStraight fails on', test[0]","title":"Problems"},{"location":"12_Testing_and_Documentation/90_Assignment_12/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem# yourname .py . So your code for the the first problen of this assignment will be named a11p1bob.py (adjusted obviously to use your name). Please submit your .py file to the Moodle dropbox.","title":"Logistics"},{"location":"13_Exam_Preparation/","text":"Introduction: The Final Exam \ud83e\udee3 \ud83d\ude40 Here is what I can tell you about the final exam. Examinable Topics Sample_Exam","title":"Introduction: The Final Exam \ud83e\udee3 \ud83d\ude40"},{"location":"13_Exam_Preparation/#introduction-the-final-exam","text":"Here is what I can tell you about the final exam. Examinable Topics Sample_Exam","title":"Introduction: The Final Exam \ud83e\udee3 \ud83d\ude40"},{"location":"13_Exam_Preparation/01_Examinable_topics/","text":"Examinable Topics I will attempt to cover all the following topics on the final exam, though not all topics will be given equal weight. For example, the single most important skill is the ability to devise solution procedures for problems in terms of sequence, selection ( if ) and iteration ( for and while ). Base skill : IPO programming: Using Python to calculate values of formulas, e.g. wind-chill, unit conversions. Core skill : Combining if , while , for to express algorithmic procedures. Technique Packaging quantities using // and % ; pulling apart numbers using % and // . Technique Formatting output using f-strings. Technique Input validation using while . Technique Using counters in programs. Technique Using flag variables, i.e. Boolean variables that record state, e.g. while not done: , if game_lost: . Core skill : Defining functions. Knowing how to do it, and knowing when to do it. Approach Using randomness to simulate events, e.g. four daughters, hockey series. Data representation : Representing things using lists, e.g. playing cards. Data representation : Creating and interpreting heterogeneous data structures (lists of lists, lists of dictionaries, dictionaries of lists, etc.), e.g. the cave system for Hunt the Wumpus. Technique Processing strings using string operations, as in the password checking program. Technique Processing lists, e.g. CD shuffle, is_straight() . Technique Using vs changing lists, i.e. how to change a list in place, and how to avoid changing a list. Technique Converting lists to strings and vice versa. Data representation : Using and processing dictionaries, e.g. for counting. Data representation : File processing, e.g. the temperature data file. Approach Parameterizing code for generality. (And on a minor note, using 'constants'). OOD object types \u2192 classes \u2192 attributes & methods (tell, ask) _OOP_concepts: Abstraction, Inheritance, Polymorphism. OOP Defining (base) classes, reverse engineering them when necessary. OOP Modifying a class via inheritance. Using inheritance to avoid code duplication. UML Creating class diagrams from code, and code from class diagrams. Software development : By hand \u2192 Pseudocode \u2192 Python Documentation Divide and conquer Design first; code second Incremental development Testing frameworks, including doctest strings. Problem domains : Playing cards, Tic-Tac-Toe, Hangman, Hunt the Wumpus.","title":"Examinable Topics"},{"location":"13_Exam_Preparation/01_Examinable_topics/#examinable-topics","text":"I will attempt to cover all the following topics on the final exam, though not all topics will be given equal weight. For example, the single most important skill is the ability to devise solution procedures for problems in terms of sequence, selection ( if ) and iteration ( for and while ). Base skill : IPO programming: Using Python to calculate values of formulas, e.g. wind-chill, unit conversions. Core skill : Combining if , while , for to express algorithmic procedures. Technique Packaging quantities using // and % ; pulling apart numbers using % and // . Technique Formatting output using f-strings. Technique Input validation using while . Technique Using counters in programs. Technique Using flag variables, i.e. Boolean variables that record state, e.g. while not done: , if game_lost: . Core skill : Defining functions. Knowing how to do it, and knowing when to do it. Approach Using randomness to simulate events, e.g. four daughters, hockey series. Data representation : Representing things using lists, e.g. playing cards. Data representation : Creating and interpreting heterogeneous data structures (lists of lists, lists of dictionaries, dictionaries of lists, etc.), e.g. the cave system for Hunt the Wumpus. Technique Processing strings using string operations, as in the password checking program. Technique Processing lists, e.g. CD shuffle, is_straight() . Technique Using vs changing lists, i.e. how to change a list in place, and how to avoid changing a list. Technique Converting lists to strings and vice versa. Data representation : Using and processing dictionaries, e.g. for counting. Data representation : File processing, e.g. the temperature data file. Approach Parameterizing code for generality. (And on a minor note, using 'constants'). OOD object types \u2192 classes \u2192 attributes & methods (tell, ask) _OOP_concepts: Abstraction, Inheritance, Polymorphism. OOP Defining (base) classes, reverse engineering them when necessary. OOP Modifying a class via inheritance. Using inheritance to avoid code duplication. UML Creating class diagrams from code, and code from class diagrams. Software development : By hand \u2192 Pseudocode \u2192 Python Documentation Divide and conquer Design first; code second Incremental development Testing frameworks, including doctest strings. Problem domains : Playing cards, Tic-Tac-Toe, Hangman, Hunt the Wumpus.","title":"Examinable Topics"}]}